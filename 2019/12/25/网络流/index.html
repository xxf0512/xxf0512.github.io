<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="网络流重在建图,再套模版 -最大流、最小割、最大匹配、最大权闭合图 Blog：https://www.cnblogs.com/Paul-Guderian/p/6657639.html       https://www.cnblogs.com/zsnuo/p/8909613.html        https://loj.ac/problems/tag/30,6 模版模版1(Dinic-SPFA">
<meta name="keywords" content="图论">
<meta property="og:type" content="article">
<meta property="og:title" content="网络流">
<meta property="og:url" content="http://xxf0512.github.io/2019/12/25/网络流/index.html">
<meta property="og:site_name" content="XXF">
<meta property="og:description" content="网络流重在建图,再套模版 -最大流、最小割、最大匹配、最大权闭合图 Blog：https://www.cnblogs.com/Paul-Guderian/p/6657639.html       https://www.cnblogs.com/zsnuo/p/8909613.html        https://loj.ac/problems/tag/30,6 模版模版1(Dinic-SPFA">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdn.net/2018082410112922?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjI3ODQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:updated_time" content="2019-08-30T03:20:28.264Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络流">
<meta name="twitter:description" content="网络流重在建图,再套模版 -最大流、最小割、最大匹配、最大权闭合图 Blog：https://www.cnblogs.com/Paul-Guderian/p/6657639.html       https://www.cnblogs.com/zsnuo/p/8909613.html        https://loj.ac/problems/tag/30,6 模版模版1(Dinic-SPFA">
<meta name="twitter:image" content="https://img-blog.csdn.net/2018082410112922?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjI3ODQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">





  
  
  <link rel="canonical" href="http://xxf0512.github.io/2019/12/25/网络流/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>网络流 | XXF</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/xxf0512" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XXF</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">少说废话</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xxf0512.github.io/2019/12/25/网络流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XXF">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XXF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">网络流

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-25 19:41:12" itemprop="dateCreated datePublished" datetime="2019-12-25T19:41:12+08:00">2019-12-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-30 11:20:28" itemprop="dateModified" datetime="2019-08-30T11:20:28+08:00">2019-08-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/图论/" itemprop="url" rel="index"><span itemprop="name">图论</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">34k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">31 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><pre><code>重在建图,再套模版 -最大流、最小割、最大匹配、最大权闭合图
Blog：https://www.cnblogs.com/Paul-Guderian/p/6657639.html
      https://www.cnblogs.com/zsnuo/p/8909613.html

      https://loj.ac/problems/tag/30,6
</code></pre><h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><h5 id="模版1-Dinic-SPFA-from-CSL-O-nnm"><a href="#模版1-Dinic-SPFA-from-CSL-O-nnm" class="headerlink" title="模版1(Dinic-SPFA from CSL  O(nnm))"></a>模版1(Dinic-SPFA from CSL  O(n<em>n</em>m))</h5><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e4+5;
struct Edge{
    int from,to,cap,flow;
    Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){}
};
struct Dinic{
    int n,m,s,t;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool vis[maxn];
    int d[maxn],cur[maxn];
    void init(int n){
        this-&gt;n=n;
        for(int i=0;i&lt;n;i++) G[i].clear();
        edges.clear();
    }
    void AddEdge(int from,int to,int cap){
        edges.emplace_back(from,to,cap,0);
        edges.emplace_back(to,from,0,0);
        m=edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }
    bool BFS(){
        memset(vis,0,sizeof(vis));
        memset(d,0,sizeof(d));
        queue&lt;int&gt; q;q.push(s);
        d[s]=0;vis[s]=1;
        while(!q.empty()){
            int x=q.front();q.pop();
            for(int i=0;i&lt;G[x].size();i++){
                Edge&amp; e=edges[G[x][i]];
                if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){
                    vis[e.to]=1;d[e.to]=d[x]+1;q.push(e.to);
                }
            }
        }
        return vis[t];
    }
    int DFS(int x,int a){
        if(x==t||a==0) return a;
        int flow=0,f;
        for(int&amp; i=cur[x];i&lt;G[x].size();i++){
            Edge&amp; e=edges[G[x][i]];
            if(d[x]+1==d[e.to]&amp;&amp;(f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){
                e.flow+=f;edges[G[x][i]^1].flow-=f;
                flow+=f;a-=f;if(a==0) break;
            }
        }
        return flow;
    }
    int Maxflow(int s,int t){
        this-&gt;s=s;this-&gt;t=t;
        int flow=0;
        while(BFS()){
            memset(cur,0,sizeof(cur));
            flow+=DFS(s,INF);
        }
        return flow;
    }
};
</code></pre><h5 id="模版2-Dijkstr-MCMF-from-NBWY"><a href="#模版2-Dijkstr-MCMF-from-NBWY" class="headerlink" title="模版2(Dijkstr-MCMF from NBWY)"></a>模版2(Dijkstr-MCMF from NBWY)</h5><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; pii;
const int maxn=1e4;
const int INF=0x7fffffff;
struct edge{
    int to,capacity,cost,rev;
    edge(){}
    edge(int to,int _capacity,int _cost,int _rev):to(to),capacity(_capacity),cost(_cost),rev(_rev) {}
};
struct Min_Cost_Max_Flow {
    int V,H[maxn],dis[maxn+5],PreV[maxn+5],PreE[maxn+5];
    vector&lt;edge&gt; G[maxn];
    void init(int n){
        V=n;for(int i=0;i&lt;=V;++i)G[i].clear();
    }
    void Add_Edge(int from,int to,int cap,int cost){
        G[from].push_back(edge(to, cap, cost, G[to].size()));
        G[to].push_back(edge(from, 0, -cost, G[from].size() - 1));
    }
    //flow是自己传进去的变量，就是最后的最大流，返回的是最小费用
    int Min_cost_max_flow(int s,int t,int f,int&amp; flow){
        int res=0;fill(H,H+1+V,0);
        while(f){
            priority_queue &lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt; &gt; q;
            fill(dis,dis+1+V,INF);
            dis[s]=0;q.push(pair&lt;int,int&gt;(0,s));
            while(!q.empty()){
                pair&lt;int,int&gt; now=q.top();q.pop();
                int v=now.second;
                if(dis[v]&lt;now.first) continue;
                for(int i=0;i&lt;G[v].size();++i){
                    edge&amp; e=G[v][i];
                    if(e.capacity&gt;0&amp;&amp;dis[e.to]&gt;dis[v]+e.cost+H[v]-H[e.to]){
                        dis[e.to]=dis[v]+e.cost+H[v]-H[e.to];
                        PreV[e.to]=v;PreE[e.to]=i;
                        q.push(pair&lt;int,int&gt;(dis[e.to],e.to));
                    }
                }
            }
            if(dis[t]==INF)break;
            for(int i=0;i&lt;=V;++i) H[i]+=dis[i];
            int d=f;
            for(int v=t;v!=s;v=PreV[v]) d=min(d,G[PreV[v]][PreE[v]].capacity);
            f-=d;flow+=d;res+=d*H[t];
            for (int v=t;v!=s;v=PreV[v]){
                edge&amp; e=G[PreV[v]][PreE[v]];
                e.capacity-=d;
                G[v][e.rev].capacity+=d;
            }
        }
        return res;
    }
    int Max_cost_max_flow(int s,int t,int f, int&amp; flow) {
        int res=0;
        fill(H,H+1+V,0);
        while(f){
            priority_queue &lt;pair&lt;int, int&gt;&gt; q;
            fill(dis,dis+1+V,-INF);
            dis[s]=0;
            q.push(pair&lt;int,int&gt;(0,s));
            while(!q.empty()){
                pair&lt;int,int&gt; now=q.top();q.pop();
                int v=now.second;
                if(dis[v]&gt;now.first)continue;
                for (int i=0;i&lt;G[v].size();i++){
                    edge&amp; e=G[v][i];
                    if(e.capacity&gt;0&amp;&amp;dis[e.to]&lt;dis[v]+e.cost+H[v]-H[e.to]){
                        dis[e.to]=dis[v]+e.cost+H[v]-H[e.to];
                        PreV[e.to]=v;PreE[e.to]=i;
                        q.push(pair&lt;int,int&gt;(dis[e.to],e.to));
                    }
                }
            }
            if(dis[t]==-INF)break;
            for(int i=0;i&lt;=V;i++) H[i]+=dis[i];
            int d=f;
            for(int v=t;v!=s;v=PreV[v]) d=min(d,G[PreV[v]][PreE[v]].capacity);
            f-=d;flow+=d;
            res+=d*H[t];
            for(int v=t;v!=s;v=PreV[v]){
                edge&amp; e=G[PreV[v]][PreE[v]];
                e.capacity-=d;
                G[v][e.rev].capacity+=d;
            }
        }
        return res;
    }
};
int flow,a[maxn];
Min_Cost_Max_Flow MCMF;
int main()
{
int T;scanf(&quot;%d&quot;,&amp;T);
while(T--){
    int n,k;scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    MCMF.init(2*n+2);
    for(int i=1;i&lt;= n;i++) {
    scanf(&quot;%d&quot;,&amp;a[i]);
    MCMF.Add_Edge(i,i+n,1,-a[i]);
    }
    for(int i=1;i&lt;=n;i++)
    for(int j=i+1;j&lt;=n;j++)
        if (a[i]&lt;=a[j]) MCMF.Add_Edge(i+n,j,1,0);
    MCMF.Add_Edge(0,2*n+1,k,0);
    for(int i=1;i&lt;=n;++i) {
    MCMF.Add_Edge(2*n+1,i,1,0);
    MCMF.Add_Edge(i+n,2*n+2,1,0);
    }
    cout&lt;&lt;-MCMF.Min_cost_max_flow(0,2*n+2,INF,flow)&lt;&lt;endl;
    return 0;
}
}
</code></pre><h5 id="模版3-Dijkstr-Bellman-from-CSL"><a href="#模版3-Dijkstr-Bellman-from-CSL" class="headerlink" title="模版3(Dijkstr-Bellman from CSL)"></a>模版3(Dijkstr-Bellman from CSL)</h5><pre><code>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
using namespace std;
const int INF=0x3f3f3f3f;
const int maxn=2005;
struct Edge{
    int from,to,cap,flow,cost;
    Edge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w){}
};
struct MCMF
{
    int n,m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    int inq[maxn];
    int d[maxn];
    int p[maxn];
    int a[maxn];
    void init(int n){
        this-&gt;n=n;
        for(int i=0;i&lt;=n;i++) G[i].clear();
        edges.clear();
    } 
    void AddEdge(int from,int to,int cap,int cost){
        edges.emplace_back(from,to,cap,0,cost);
        edges.emplace_back(to,from,0,0,-cost);
        int m=edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }
    bool BellmanFord(int s,int t,int &amp;flow,ll &amp;cost){
        for(int i=0;i&lt;n;i++) d[i]=INF;
        memset(inq,0,sizeof(inq));d[s]=0;inq[s]=1;p[s]=0;a[s]=INF;
        queue&lt;int&gt; q;q.push(s);
        while(!q.empty()){
            int  u=q.front();q.pop();inq[u]=0;
            for(int i=0;i&lt;G[u].size();i++){
                Edge&amp; e=edges[G[u][i]];
                if(e.cap&gt;e.flow&amp;&amp;d[e.to]&gt;d[u]+e.cost){
                    d[e.to]=d[u]+e.cost;p[e.to]=G[u][i];
                    a[e.to]=min(a[u],e.cap-e.flow);
                    if(!inq[e.to]){
                        q.push(e.to);inq[e.to]=1;
                    }
                }
            }
        }
        if(d[t]==INF) return 0;
        flow+=a[t];
        cost+=(ll)d[t]*(ll)a[t];
        for(int u=t;u!=s;u=edges[p[u]].from){
            edges[p[u]].flow+=a[t];
            edges[p[u]^1].flow-=a[t];
        }
        return 1;
    }
    int MincostMAXflow(int s,int t,ll &amp;cost){
        int flow=0;cost=0;
        while(BellmanFord(s,t,flow,cost));
        return flow;
    }
}Mc;
</code></pre><h5 id="模版4-最大匹配"><a href="#模版4-最大匹配" class="headerlink" title="模版4(最大匹配)"></a>模版4(最大匹配)</h5><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 105;
int n, m;
vector&lt;int&gt; G[maxn];
int linker[maxn];
bool used[maxn];
inline void init(int n) {
    for (int i = 0; i &lt;= n; i++) G[i].clear();
}
inline void addedge(int u, int v) { G[u].push_back(v); }
inline bool dfs(int u) {
    for (auto &amp;v : G[u]) {
        if (!used[v]) {
            used[v] = 1;
            if (linker[v] == -1 || dfs(linker[v])) {
                linker[v] = u;
                return 1;
            }
        }
    }
    return 0;
}
inline int hungary() {
    int ans = 0;
    memset(linker, -1, sizeof(linker));
    for (int u = 1; u &lt;= m; u++) {//左边点的个数
        memset(used, 0, sizeof(used));
        if (dfs(u))
            ans++;
    }
    return ans;
}
int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int u, v;
    while (~scanf(&quot;%d%d&quot;, &amp;u, &amp;v)) {
        addedge(u, v);
    }
    printf(&quot;%d\n&quot;, hungary());
}
</code></pre><hr>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><pre><code>题源：https://loj.ac/problems/search?keyword=%E7%BD%91%E7%BB%9C%E6%B5%81
</code></pre><hr>
<h5 id="1-飞行员配对方案问题-最大匹配"><a href="#1-飞行员配对方案问题-最大匹配" class="headerlink" title="1.飞行员配对方案问题(最大匹配)"></a>1.飞行员配对方案问题(最大匹配)</h5><pre><code>题意：每架飞机需要两个驾驶员，一个正驾驶员和一个副驾驶员。由于种种原因，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。两个正驾驶员或两个副驾驶员都不能同机飞行。
思路：拆点跑网络流或二分图最大匹配裸题，备忘两种都写了

1.拆点网络流
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=500;
const int INF=0x3f3f3f3f;
struct Edge{
    int from,to,cap,flow;
    Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){}
};
struct Dinic{
    int n,m,s,t;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool vis[maxn];
    int d[maxn],cur[maxn];
    void init(int n){
        this-&gt;n=n;
        for(int i=0;i&lt;=n;i++) G[i].clear();
        edges.clear();
    }
    void AddEdge(int from,int to,int cap){
        edges.emplace_back(from,to,cap,0);
        edges.emplace_back(to,from,0,0);
        m=edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }
    bool BFS(){
        memset(vis,0,sizeof(vis));
        memset(d,0,sizeof(d));
        queue&lt;int&gt; q;q.push(s);
        d[s]=0;vis[s]=1;
        while(!q.empty()){
            int x=q.front();q.pop();
            for(int i=0;i&lt;G[x].size();i++){
                Edge&amp; e=edges[G[x][i]];
                if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){
                    vis[e.to]=1;d[e.to]=d[x]+1;q.push(e.to);
                }
            }
        }
        return vis[t];
    }
    int DFS(int x,int a){
        if(x==t||a==0) return a;
        int flow=0,f;
        for(int&amp; i=cur[x];i&lt;G[x].size();i++){
            Edge&amp; e=edges[G[x][i]];
            if(d[x]+1==d[e.to]&amp;&amp;(f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){
                e.flow+=f;edges[G[x][i]^1].flow-=f;
                flow+=f;a-=f;if(a==0) break;
            }
        }
        return flow;
    }
    int Maxflow(int s,int t){
        this-&gt;s=s;this-&gt;t=t;
        int flow=0;
        while(BFS()){
            memset(cur,0,sizeof(cur));
            flow+=DFS(s,INF);
        }
        return flow;
    }
}Dic;
int main()
{
    int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int x=0;
    Dic.init(2*n+2);
    for(int i=1;i&lt;=n;i++) Dic.AddEdge(i,i+n,1);
    int u,v;
    while(~scanf(&quot;%d%d&quot;,&amp;u,&amp;v)){
        Dic.AddEdge(u+n,v,1);
    }
    for(int i=1;i&lt;=m;i++) Dic.AddEdge(0,i,1);
    for(int i=m+1;i&lt;=n;i++) Dic.AddEdge(i+n,2*n+1,1);
    int ans=Dic.Maxflow(0,2*n+1);
    printf(&quot;%d\n&quot;,ans);
}


2.二分图最大匹配

#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 105;
int n, m;
vector&lt;int&gt; G[maxn];
int linker[maxn];
bool used[maxn];
inline void init(int n) {
    for (int i = 0; i &lt;= n; i++) G[i].clear();
}
inline void addedge(int u, int v) { G[u].push_back(v); }
inline bool dfs(int u) {
    for (auto &amp;v : G[u]) {
        if (!used[v]) {
            used[v] = 1;
            if (linker[v] == -1 || dfs(linker[v])) {
                linker[v] = u;
                return 1;
            }
        }
    }
    return 0;
}
inline int hungary() {
    int ans = 0;
    memset(linker, -1, sizeof(linker));
    for (int u = 1; u &lt;= m; u++) {
        memset(used, 0, sizeof(used));
        if (dfs(u))
            ans++;
    }
    return ans;
}
int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int u, v;
    while (~scanf(&quot;%d%d&quot;, &amp;u, &amp;v)) {
        addedge(u, v);
    }
    printf(&quot;%d\n&quot;, hungary());
}
</code></pre><hr>
<h5 id="2-太空飞行计划（最大点权闭合子图）"><a href="#2-太空飞行计划（最大点权闭合子图）" class="headerlink" title="2.太空飞行计划（最大点权闭合子图）"></a>2.太空飞行计划（最大点权闭合子图）</h5><pre><code>最大权闭合子图：给定带权图G(权值可正可负),求一个权和最大的点集，使得起点在该点集中的任意弧，终点也在该点集中
解法：新增源点s和汇点t，从s向所有正权点引一条边，容量为权值；从所有负权点向汇点引一条边，容量为权值的相反数。求出最小割f,S-{s}就是最大权闭合子图。

题意：现已确定了一个可供选择的实验集合 E={E1,E2,⋯,Em}，和进行这些实验需要使用的全部仪器的集合 I={I1,I2,⋯,In}。实验 Ej 需要用到的仪器是 I 的子集 Rj⊆I。
配置仪器 Ik​​ 的费用为 ck​​ 美元。实验 Ej 的赞助商已同意为该实验结果支付 pj 美元。对于给定的实验和仪器配置情况，找出净收益最大的试验计划.

思路：最大权闭合子图。从 S 向每个实验连一条容量为 pi 的边，每个实验向所需要的仪器连一条容量为INF的边，每个仪器向 T 连一条容量为 ci 的边。答案为 ∑pi−maxflow 。
对于输出方案，如果d[i]!=0那么i点显然走过了。输出即可

输入输出太坑了！！！

vector&lt;int&gt; v1,v2;
int main()
{
    int n,m;scanf(&quot;%d%d&quot;,&amp;m,&amp;n);Dic.init(n+m+2);
    int S=0;
    for(int i=1;i&lt;=m;i++){
        int p,v;char ch;scanf(&quot;%d&quot;,&amp;p);S+=p;
        Dic.AddEdge(0,i,p);
        while(getchar()==&apos; &apos;){
            scanf(&quot;%d&quot;,&amp;v);
            Dic.AddEdge(i,v+m,INF);
        }
    }
    for(int i=m+1;i&lt;=n+m;i++){
        int c;scanf(&quot;%d&quot;,&amp;c);
        Dic.AddEdge(i,n+m+1,c);
    }
    int ans=S-Dic.Maxflow(0,n+m+1);
    v1.clear();v2.clear();
    for(int i=1;i&lt;=m;i++) if(Dic.d[i]!=0) v1.push_back(i);
    for(int i=1;i&lt;=n;i++) if(Dic.d[i+m]!=0) v2.push_back(i);
    printf(&quot;%d&quot;,v1[0]);for(int i=1;i&lt;v1.size();i++) printf(&quot; %d&quot;,v1[i]);printf(&quot;\n&quot;);
    printf(&quot;%d&quot;,v2[0]);for(int i=1;i&lt;v2.size();i++) printf(&quot; %d&quot;,v2[i]);printf(&quot;\n&quot;);
    printf(&quot;%d\n&quot;,ans);
}
</code></pre><hr>
<h5 id="3-最小路径覆盖-二分图匹配"><a href="#3-最小路径覆盖-二分图匹配" class="headerlink" title="3.最小路径覆盖(二分图匹配)"></a>3.最小路径覆盖(二分图匹配)</h5><p><img src="https://img-blog.csdn.net/2018082410112922?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjI3ODQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="最小路径覆盖"></p>
<pre><code>定义：通俗点讲，就是在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。
最小路径覆盖分为最小不相交路径覆盖和最小可相交路径覆盖。

最小不相交路径覆盖：每一条路径经过的顶点各不相同。如图，其最小路径覆盖数为3。即1-&gt;3&gt;4，2，5。
最小可相交路径覆盖：每一条路径经过的顶点可以相同。如果其最小路径覆盖数为2。即1-&gt;3-&gt;4，2-&gt;3&gt;5。

DAG的最小不相交路径覆盖:拆点得二分图，最小路径覆盖=原图节点数-新图最大匹配数
    把原图的每个点V拆成Vx和Vy两个点，如果有一条有向边A-&gt;B，那么就加边Ax−&gt;By。这样就得到了一个二分图。那么最小路径覆盖=原图的结点数-新图的最大匹配数
    一开始每个点都是独立的为一条路径，总共有n条不相交路径。我们每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，也就相当于路径数减少了1。所以找到了几条匹配边，路径数就减少了多少。所以有最小路径覆盖=原图的结点数-新图的最大匹配数。

DAG的最小可相交路径覆盖：先用floyd求出原图的传递闭包，即如果a到b有路径，那么就加边a-&gt;b。然后就转化成了最小不相交路径覆盖问题。
为了连通两个点，某条路径可能经过其它路径的中间点。比如1-&gt;3-&gt;4，2-&gt;4-&gt;5。但是如果两个点a和b是连通的，只不过中间需要经过其它的点，那么可以在这两个点之间加边，那么a就可以直达b，不必经过中点的，那么就转化成了最小不相交路径覆盖。


题意：给定有向图 G=(V,E)。设 P 是 G 的一个简单路（顶点不相交）的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。 P 中路径可以从 V 的任何一个顶点开始，长度也是任意的，
特别地，可以为 0。G 的最小路径覆盖是 G 的所含路径条数最少的路径覆盖。 求一个有向无环图 G 的最小路径覆盖。

分析：二分图最大匹配。将每个点拆为两个点，在新图中对应连边。二分图的每一个合法匹配都可以视为一种路径覆盖的方式，路径条数为总点数-匹配数。最小不相交路径覆盖即为总点数-二分图最大匹配。（建图方式仅限DAG）

此题需要输出路径，根据匹配找路径即可，注意记录路径

#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 505;
vector&lt;int&gt; G[maxn];
int linker[maxn];
bool used[maxn];
inline void init(int n){
    for(int i=0;i&lt;=n;i++) G[i].clear();
}
inline void addedge(int u,int v){G[u].push_back(v);}
inline bool dfs(int u){
    for (auto &amp;v:G[u]){
        if (!used[v]){
            used[v]=1;
            if(linker[v]==-1||dfs(linker[v])){
                linker[v] = u;linker[u]=v;//记录路径
                return 1;
            }
        }
    }
    return 0;
}
inline int hungary(int n){
    int ans=0;
    memset(linker,-1,sizeof(linker));
    for (int u=1;u&lt;=n;u++){//左边点的个数
        memset(used,0,sizeof(used));
        if(dfs(u)) ans++;
    }
    return ans;
}
inline void print(int u,int n){
    printf(&quot; %d&quot;,u-n);
    if(linker[u-n]!=-1) print(linker[u-n],n);
}
int main() {
    int n,m,u,v;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    while(m--){
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        addedge(u,v+n);
    }
    int ans=hungary(n);
    for(int i=n+1;i&lt;=2*n;i++){
        if(linker[i]==-1){
            printf(&quot;%d&quot;,i-n);
            if(linker[i-n]!=-1) print(linker[i-n],n);
            printf(&quot;\n&quot;);
        }
    }
    printf(&quot;%d\n&quot;,n-ans);
}

若使用网络流算法可以根据每两点之间流量的关系找回路径，下面是NB网友的代码：

int main()
{
    n=read();m=read();S=0;T=n*2+1;
    for(int i=1;i&lt;=m;i++)
    {
        x=read();y=read();
        insert(x,y+n,1);
    }
    for(int i=1;i&lt;=n;i++)insert(S,i,1);
    for(int i=1;i&lt;=n;i++)insert(i+n,T,1);
    while(bfs())
    {
        for(int i=S;i&lt;=T;i++)cur[i]=first[i];
        ans+=dfs(S,inf);
    }
    for(int x=1;x&lt;=n;x++)
        for(int i=first[x];i;i=e[i].next)
            if(!e[i].flow&amp;&amp;e[i].to)to[x]=e[i].to-n,ind[e[i].to-n]++;
    for(int x=1;x&lt;=n;x++)
        if(!ind[x])
        {
            for(int i=x;i;i=to[i])printf(&quot;%d &quot;,i);
            printf(&quot;\n&quot;);
        }
    printf(&quot;%d\n&quot;,n-ans);
    return 0;
}
</code></pre><hr>
<h5 id="4-魔术球-待补"><a href="#4-魔术球-待补" class="headerlink" title="4.魔术球(待补)"></a>4.魔术球(待补)</h5><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e4+5;
const int INF=0x3f3f3f3f;
struct Edge{
    int from,to,cap,flow;
    Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){}
};
struct Dinic{
    int n,m,s,t;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool vis[maxn];
    int d[maxn],cur[maxn];
    void init(int n){
        this-&gt;n=n;
        for(int i=0;i&lt;=n;i++) G[i].clear();
        edges.clear();
    }
    void AddEdge(int from,int to,int cap){
        edges.emplace_back(from,to,cap,0);
        edges.emplace_back(to,from,0,0);
        m=edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }
    bool BFS(){
        memset(vis,0,sizeof(vis));
        memset(d,0,sizeof(d));
        queue&lt;int&gt; q;q.push(s);
        d[s]=0;vis[s]=1;
        while(!q.empty()){
            int x=q.front();q.pop();
            for(int i=0;i&lt;G[x].size();i++){
                Edge&amp; e=edges[G[x][i]];
                if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){
                    vis[e.to]=1;d[e.to]=d[x]+1;q.push(e.to);
                }
            }
        }
        return vis[t];
    }
    int DFS(int x,int a){
        if(x==t||a==0) return a;
        int flow=0,f;
        for(int&amp; i=cur[x];i&lt;G[x].size();i++){
            Edge&amp; e=edges[G[x][i]];
            if(d[x]+1==d[e.to]&amp;&amp;(f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){
                e.flow+=f;edges[G[x][i]^1].flow-=f;
                flow+=f;a-=f;if(a==0) break;
            }
        }
        return flow;
    }
    int Maxflow(int s,int t){
        this-&gt;s=s;this-&gt;t=t;
        int flow=0;
        while(BFS()){
            memset(cur,0,sizeof(cur));
            flow+=DFS(s,INF);
        }
        return flow;
    }
}Dic;
bool check(int x,int y){
    int t=sqrt(x+y);
    return t*t==x+y;
}
int to[maxn];
int main()
{
    int n;
    while(~scanf(&quot;%d&quot;,&amp;n)){
        int s=0,t=401,cnt=0,ans=0;Dic.init(401);
        while(1){
            ans++;cnt++;Dic.AddEdge(s,ans,1);
            Dic.AddEdge(ans+200,t,1);
            for(int i=1;i&lt;ans;i++)
                if(check(i,ans)) Dic.AddEdge(i,ans+200,1);
            cnt-=Dic.Maxflow(s,t);
            if(cnt&gt;n) break;
        }ans--;
        printf(&quot;%d\n&quot;,ans);
        for(int i=1;i&lt;=ans;i++)
            for(auto &amp;v:Dic.G[i])
                if(!Dic.edges[v].flow&amp;&amp;Dic.edges[v].to){
                    to[i]=Dic.edges[v].to-200;break;
                }
        for(int i=1;i&lt;=ans;i++)
            if(!Dic.vis[i]){
                for(int j=i;j;j=to[j])
                    printf(&quot;%d &quot;,j),Dic.vis[i]=1;
                printf(&quot;\n&quot;);
            }
    }
}
</code></pre><hr>
<h5 id="5-圆桌聚餐-最大流"><a href="#5-圆桌聚餐-最大流" class="headerlink" title="5.圆桌聚餐(最大流)"></a>5.圆桌聚餐(最大流)</h5><pre><code>题意：来自n个不同单位的代表参加一次国际会议。每个单位的代表数分别为ri。会议餐厅共有m张餐桌，每张餐桌可容纳ci个代表就餐。为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试给出满足要求的代表就餐方案。

思路：最大流。从S向每个单位连一条容量为人数的边，从餐桌向T连接一条容量为餐桌容量的边，从单位向每个餐桌连一条容量为1的边。直接跑最大流求解。

注意判断是否有解应该是将最大流与总人数比较，若最大流等于总人数输出1，否则输出0；

int main()
{
    int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int s=0,t=n+m+1,sum=0;Dic.init(n+m+1);
    for(int i=1;i&lt;=n;i++){
        int x;scanf(&quot;%d&quot;,&amp;x);Dic.AddEdge(s,i,x);sum+=x;
    }
    for(int i=n+1;i&lt;=n+m;i++){
        int x;scanf(&quot;%d&quot;,&amp;x);Dic.AddEdge(i,t,x);
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=n+1;j&lt;=n+m;j++){
            Dic.AddEdge(i,j,1);
        }
    }
    int ans=Dic.Maxflow(s,t);
    if(ans&gt;=sum) printf(&quot;1\n&quot;);
    else {printf(&quot;0\n&quot;);return 0;}
    for(int i=1;i&lt;=n;i++){
        for(auto &amp;v:Dic.G[i]){
            if(Dic.edges[v].flow&gt;0) printf(&quot;%d &quot;,Dic.edges[v].to-n);
        }
        printf(&quot;\n&quot;);
    }
}
</code></pre><hr>
<h6 id="6-最长递增子序列问题-最大流"><a href="#6-最长递增子序列问题-最大流" class="headerlink" title="6.最长递增子序列问题(最大流)"></a>6.最长递增子序列问题(最大流)</h6><pre><code>题意：给定正整数序列x1∼xn,以下递增均为非严格递增.计算其最长递增子序列的长度s;计算从给定的序列中最多可取出多少个长度为s的递增子序列。 
如果允许在取出的序列中多次使用x1​和xn,则从给定序列中最多可取出多少个长度为s的递增子序列。

令fi表示以第i位开头的最长递增子序列长度，可用dp求解。若fi=s,则从S向i连一条容量为1的边;若fi=1,则从i向T连一条容量为1的边；
限定每个点只选一次,拆点，连一条容量为1的边；若i&lt;j且xi&lt;=xj且fi=fj+1，则从i向j连一条容量为1的边。直接跑最大流求解即可。
回答第三问时，把对应边的限制放成 inf，再跑一次最大流。

int main()
{
    int n;scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++) {scanf(&quot;%d&quot;,&amp;a[i]);dp[i]=1;}
    for(int i=n;i&gt;=1;i--){
        for(int j=n;j&gt;i;j--){
            if(a[j]&gt;=a[i]) dp[i]=max(dp[i],dp[j]+1);
        }
    }
    int MAX=0;
    for(int i=1;i&lt;=n;i++) MAX=max(MAX,dp[i]);
    if(MAX==1) {printf(&quot;1\n&quot;);printf(&quot;%d\n&quot;,n);printf(&quot;%d\n&quot;,n);return 0;}

    int s=0,t=2*n+1;Dic.init(2*n+1);
    for(int i=1;i&lt;=n;i++){
        Dic.AddEdge(i,i+n,1);
        if(dp[i]==MAX) Dic.AddEdge(s,i,1);
        if(dp[i]==1) Dic.AddEdge(i+n,t,1);
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=i+1;j&lt;=n;j++){
            if(a[j]&gt;=a[i]&amp;&amp;dp[i]==dp[j]+1) Dic.AddEdge(i,j,1);
        }
    }
    int ans1=Dic.Maxflow(s,t);

    Dic.init(2*n+1);Dic.AddEdge(1,1+n,INF);Dic.AddEdge(n,n+n,INF);
    for(int i=2;i&lt;n;i++) Dic.AddEdge(i,i+n,1);
    for(int i=1;i&lt;=n;i++){
        if(dp[i]==MAX){
            if(i==1||i==n) Dic.AddEdge(s,i,INF);
            else Dic.AddEdge(s,i,1);
        }
        if(dp[i]==1){
            if(i==1||i==n) Dic.AddEdge(i+n,t,INF);
            else Dic.AddEdge(i+n,t,1);
        }
        for(int j=i+1;j&lt;=n;j++){
            if(a[j]&gt;=a[i]&amp;&amp;dp[i]==dp[j]+1) Dic.AddEdge(i,j,1);
        }
    }
    int ans2=Dic.Maxflow(s,t);
    printf(&quot;%d\n&quot;,MAX);printf(&quot;%d\n&quot;,ans1);printf(&quot;%d\n&quot;,ans2);
}
</code></pre><hr>
<h5 id="7-试题库问题-最大流"><a href="#7-试题库问题-最大流" class="headerlink" title="7.试题库问题(最大流)"></a>7.试题库问题(最大流)</h5><pre><code>题意：假设一个试题库中有n道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。
现要从题库中抽取m道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。

分析：最大流。从S向每种类别连一条容量为需求的边，从题目向T连接一条容量为1的边,从每个类别向题目连一条容量为1的边。直接跑最大流求解即可。

int main()
{
    int k,n,sum=0;scanf(&quot;%d%d&quot;,&amp;k,&amp;n);
    int s=0,t=n+k+1;Dic.init(n+k+1);
    for(int i=1;i&lt;=k;i++){
        int c;scanf(&quot;%d&quot;,&amp;c);Dic.AddEdge(0,i,c);sum+=c;
    }
    for(int i=k+1;i&lt;=k+n;i++){
        int c;scanf(&quot;%d&quot;,&amp;c);
        while(c--){
            int x;scanf(&quot;%d&quot;,&amp;x);
            Dic.AddEdge(x,i,1);
        }
        Dic.AddEdge(i,t,1);
    }
    int ans=Dic.Maxflow(s,t);
    if(ans!=sum) {printf(&quot;No Solution!\n&quot;);return 0;}
    for(int i=1;i&lt;=k;i++){
        printf(&quot;%d:&quot;,i);
        for(auto &amp;v:Dic.G[i]){
            if(Dic.edges[v].flow&gt;0)
            printf(&quot; %d&quot;,Dic.edges[v].to-k);
        }
        printf(&quot;\n&quot;);
    }
}
</code></pre><hr>
<h5 id="8-机器人路径规划问题"><a href="#8-机器人路径规划问题" class="headerlink" title="8.机器人路径规划问题"></a>8.机器人路径规划问题</h5><hr>
<h5 id="9-方格取数问题-最大点权独立集"><a href="#9-方格取数问题-最大点权独立集" class="headerlink" title="9.方格取数问题(最大点权独立集)"></a>9.方格取数问题(最大点权独立集)</h5><pre><code>最大独立集：从一个图中找出一种点集，任意两点之间没有边，且点的数量最大 
最大点权独立集：从一个图中找出一种点集，任意两点之间没有边，每个点有相应的权值，要求所有点的权值和最大。 
最小覆盖集：在一个图中找出这么一个点击，使得所有的边的至少一个端点属于这个集合，并要求点的数量最小 
最小点权覆盖：在一个图中找出这么一个点击，使得所有的边的至少一个端点属于这个集合，每个点有权值，要求点的权值和最小。 
结论：最大独立集+最小覆盖集=总点数 
最大点权独立集+最小点权覆盖=总点权和 
最小点权覆盖=最大流 
二分图建成网络流以后，，可以用最小割的概念去理解，找出最小的边权（实际上是把点权移到边上了）使得二分图的两个点集不连通，而不连通就是满足了题意 

**********************************************************

二分图最小点覆盖和最大独立集都可以转化为最大匹配求解。在这个基础上，把每个点赋予一个非负的权值，这两个问题就转化为：二分图最小点权覆盖和二分图最大点权独立集。

二分图最小点权覆盖：从x或者y集合中选取一些点，使这些点覆盖所有的边，并且选出来的点的权值尽可能小。
建模：原二分图中的边(u,v)替换为容量为INF的有向边(u,v)，设立源点s和汇点t，将s和x集合中的点相连，容量为该点的权值；将y中的点同t相连，容量为该点的权值。在新图上求最大流，最大流量即为最小点权覆盖的权值和。

二分图最大点权独立集：在二分图中找到权值和最大的点集，使得它们之间两两没有边。
其实它是最小点权覆盖的对偶问题。答案=总权值-最小点覆盖集=总权值-最大流。具体证明参考胡波涛的论文。

**********************************************************
题意：在一个有n×m个方格的棋盘中,每个方格中有一个正整数。现要从方格中取数,使任意 2个数所在方格没有公共边,且取出的数的总和最大。试设计一个满足要求的取数算法。

分析：最大点权独立集。先将棋盘黑白染色，从S向每个黑点连一条容量为黑点数值的边，从白点向T连接一条容量为白点数值的边，从每个黑点向相邻白点连一条容量为INF的边。
答案为总价值-最小割,即总价值-最大流。

为什么要这样做呢？
可以从最小割来理解，把相邻的黑白点转化为一个二分图，要使其两部分不连通，即连通边隔断，即最小割

注意：在分黑白点时可以按照坐标分，(坐标之和为奇数为黑点，否则是白点，点的下标设为(i-1)*m+j )

int a[35][35];
int dir[4][2]={0,-1,1,0,0,1,-1,0};
int main()
{
    int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int s=0,t=n*m+1,sum=0;Dic.init(n*m+1);
    for(int i=1;i&lt;=n;i++){    
        for(int j=1;j&lt;=m;j++){
            scanf(&quot;%d&quot;,&amp;a[i][j]);sum+=a[i][j];
            if((i+j)&amp;1) Dic.AddEdge(0,(i-1)*m+j,a[i][j]);
            else Dic.AddEdge((i-1)*m+j,t,a[i][j]);
        }
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=m;j++){
            if((i+j)&amp;1){
                for(int k=0;k&lt;4;k++){
                    int x=i+dir[k][0],y=j+dir[k][1];
                    if(x&lt;=n&amp;&amp;x&gt;=1&amp;&amp;y&lt;=m&amp;&amp;y&gt;=1)
                    Dic.AddEdge((i-1)*m+j,(x-1)*m+y,INF);
                }
            }
        }
    }
    int ans=sum-Dic.Maxflow(s,t);
    printf(&quot;%d\n&quot;,ans);
}
</code></pre><hr>
<h5 id="10-餐巾计划问题-最小费用最大流-好难啊"><a href="#10-餐巾计划问题-最小费用最大流-好难啊" class="headerlink" title="10.餐巾计划问题(最小费用最大流)(好难啊!!!)"></a>10.餐巾计划问题(最小费用最大流)(好难啊!!!)</h5><pre><code>题意：一个餐厅在相继的 n 天里，每天需用的餐巾数不尽相同。假设第 i 天需要 ri ​​ 块餐巾。餐厅可以购买新的餐巾，每块餐巾的费用为 P 分；
或者把旧餐巾送到快洗部，洗一块需 M 天，其费用为 F 分；或者送到慢洗部，洗一块需 N 天，其费用为 S 分（S&lt;F）。 
每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。
但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。 试设计一个算法为餐厅合理地安排好 n 天中餐巾使用计划,使总的花费最小。

分析：把每一天都拆成一对点 xi 和 yi ，xi 表示脏的餐巾，yi 表示干净的餐巾。从 S 向 yi 连一条容量为 inf 费用为 P 的边，代表购买决策；
从 yi 向 T 连一条容量为 ri 费用为 0 的边，代表每天需求；从 S 向 xi 连一条容量为 ri 费用为 0 的边，代表每天剩余的未洗餐巾；
从 xi 向 xi+1 连一条容量为 inf 费用为 0 的边，代表将脏餐巾屯到下一天；从 xi 向 yi+m 连一条容量为 inf 费用为 F 的边，代表快洗决策；
从 xi 向 yi+n 连一条容量为 inf 费用为 S 的边，代表慢洗决策。直接跑最小费用最大流即可。

#include&lt;bits/stdc++.h&gt;
typedef long long ll;
using namespace std;
const int INF=0x3f3f3f3f;
const int maxn=2005;
struct Edge{
    int from,to,cap,flow,cost;
    Edge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w){}
};
struct MCMF
{
    int n,m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    int inq[maxn];
    int d[maxn];
    int p[maxn];
    int a[maxn];
    void init(int n){
        this-&gt;n=n;
        for(int i=0;i&lt;=n;i++) G[i].clear();
        edges.clear();
    } 
    void AddEdge(int from,int to,int cap,int cost){
        edges.emplace_back(from,to,cap,0,cost);
        edges.emplace_back(to,from,0,0,-cost);
        int m=edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }
    bool BellmanFord(int s,int t,int &amp;flow,ll &amp;cost){
        for(int i=0;i&lt;n;i++) d[i]=INF;
        memset(inq,0,sizeof(inq));d[s]=0;inq[s]=1;p[s]=0;a[s]=INF;
        queue&lt;int&gt; q;q.push(s);
        while(!q.empty()){
            int  u=q.front();q.pop();inq[u]=0;
            for(int i=0;i&lt;G[u].size();i++){
                Edge&amp; e=edges[G[u][i]];
                if(e.cap&gt;e.flow&amp;&amp;d[e.to]&gt;d[u]+e.cost){
                    d[e.to]=d[u]+e.cost;p[e.to]=G[u][i];
                    a[e.to]=min(a[u],e.cap-e.flow);
                    if(!inq[e.to]){
                        q.push(e.to);inq[e.to]=1;
                    }
                }
            }
        }
        if(d[t]==INF) return 0;
        flow+=a[t];
        cost+=(ll)d[t]*(ll)a[t];
        for(int u=t;u!=s;u=edges[p[u]].from){
            edges[p[u]].flow+=a[t];
            edges[p[u]^1].flow-=a[t];
        }
        return 1;
    }
    int MincostMAXflow(int s,int t,ll &amp;cost){
        int flow=0;cost=0;
        while(BellmanFord(s,t,flow,cost));
        return flow;
    }
}Mc;

int a[1005];
int main()
{
    int n,P,M,F,N,S;scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;P,&amp;M,&amp;F,&amp;N,&amp;S);
    for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
    int s=0,t=2*n+1;Mc.init(2*n+2);
    for(int i=1;i&lt;=n;i++){
        Mc.AddEdge(s,i+n,INF,P);Mc.AddEdge(i+n,t,a[i],0);
    }
    for(int i=1;i&lt;n;i++){
        Mc.AddEdge(s,i,a[i],0);Mc.AddEdge(i,i+1,INF,0);
    }
    for(int i=1;i&lt;=n-M;i++) Mc.AddEdge(i,i+n+M,INF,F);
    for(int i=1;i&lt;=n-N;i++) Mc.AddEdge(i,i+n+N,INF,S);
    ll cost=0;
    int ans=Mc.MincostMAXflow(s,t,cost);
    printf(&quot;%d\n&quot;,cost);
}
</code></pre><hr>
<h5 id="11-航空路线问题-最小费用最大流-输出路径"><a href="#11-航空路线问题-最小费用最大流-输出路径" class="headerlink" title="11.航空路线问题(最小费用最大流-输出路径)"></a>11.航空路线问题(最小费用最大流-输出路径)</h5><pre><code>题意：给定一张航空图，图中顶点代表城市，边代表两个城市间的直通航线。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线：
从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）；
除起点城市外，任何城市只能访问一次。对于给定的航空图，试设计一个算法找出一条满足要求的最佳航空旅行路线。

分析：问题转化为求两条不相交的路径且路径之和最长。考虑拆点，连一条容量为1费用为−1的边(1和n的容量为2)。跑最小费用最大流求解，若最大流不等于2则无解。

建图不难，输出方案调死我了 *.*  被傻屌网友忽悠半天，最后写了个dfs水过去了。。。
从起点开始dfs，
第一趟走到终点，第二趟从起点再次走到终点，两个路径以终点分隔，把第二条路径倒过来输出就可以了


map&lt;string,int&gt; mmp;
map&lt;int,string&gt; mmp1;
bool vis[maxn];
vector&lt;int&gt; ANS,ans1;
void dfs(int u,int n){
    if(u&lt;=n+1&amp;&amp;!vis[u]) ANS.push_back(u);vis[u]=1;
    for(auto &amp;v:Mc.G[u+n]){
        if((Mc.edges[v].flow&gt;0)&amp;&amp;!vis[Mc.edges[v].to]) dfs(Mc.edges[v].to,n);
    }
}
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);
    int n,m;cin&gt;&gt;n&gt;&gt;m;int S=1,T=2*n;
    string s;Mc.init(n*2);
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;s;mmp[s]=i;mmp1[i]=s;
    }
    for(int i=2;i&lt;n;i++) Mc.AddEdge(i,i+n,1,-1);
    Mc.AddEdge(1,1+n,2,-1);Mc.AddEdge(n,n*2,2,-1);
    for(int i=1;i&lt;=m;i++){
        string a,b;cin&gt;&gt;a&gt;&gt;b;
        int A=mmp[a],B=mmp[b];
        if(A&gt;B) swap(A,B);
        if(A==1&amp;&amp;B==n) Mc.AddEdge(n+1,n,2,0);//起点到终点的直达路线的费用应该为0
        Mc.AddEdge(A+n,B,1,0);
    }
    ll cost=0;
    int ans=Mc.MincostMAXflow(S,T,cost);
    if(ans!=2) {cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl;return 0;}
    cout&lt;&lt;-cost-2&lt;&lt;endl;dfs(1,n);
    int f=0;
    for(int i=0;i&lt;ANS.size();i++){
        if(ANS[i]==n) {f=1;cout&lt;&lt;mmp1[ANS[i]]&lt;&lt;endl;}
        else if(f) ans1.push_back(ANS[i]);
        else cout&lt;&lt;mmp1[ANS[i]]&lt;&lt;endl;
    }
    reverse(ans1.begin(),ans1.end());
    for(int i=0;i&lt;ans1.size();i++) cout&lt;&lt;mmp1[ans1[i]]&lt;&lt;endl;
    cout&lt;&lt;mmp1[1]&lt;&lt;endl;
}
</code></pre><hr>
<h5 id="12-软件补丁问题-待补-太难了"><a href="#12-软件补丁问题-待补-太难了" class="headerlink" title="12.软件补丁问题(待补-太难了!!!)"></a>12.软件补丁问题(待补-太难了!!!)</h5><hr>
<h5 id="13-星际转移问题-分层图动态加边-最大流"><a href="#13-星际转移问题-分层图动态加边-最大流" class="headerlink" title="13.星际转移问题(分层图动态加边-最大流)"></a>13.星际转移问题(分层图动态加边-最大流)</h5><pre><code>题意：现有n个太空站位于地球与月球之间，且有m艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而每艘太空船i只可容纳Hi个人。每艘太空船将周期性地停靠一系列的太空站，例如：1,3,4 表示该太空船将周期性地停靠太空站134134134⋯ 
每一艘太空船从一个太空站驶往任一太空站耗时均为1。人们只能在太空船停靠太空站（或月球、地球）时上、下船。初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。

分析：建立分层图。从S向每一天的地球连一条容量为inf的边；从每一天的月球向T连一条容量为inf的边；从每一天的节点向下一天的对应节点连一条容量为inf的边；
对于每一艘飞船，从每一天的位置向下一天的位置连一条容量为Hi的边。枚举天数建图，跑最大流直到不小于总人数即可

注意：每次枚举一个新的天数，加一层新的边。在重新跑网络流之前要记得把上次跑网络流的流量清空，因为上一次残留的流量会对重新跑的网络流造成误差。

int h[maxn],r[maxn],p[maxn][50],pos[maxn];
int main()
{
    int n,m,k;scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);n+=2;
    int S=0,T=10000;Dic.init(T+2);
    for(int i=1;i&lt;=m;i++){
        scanf(&quot;%d%d&quot;,&amp;h[i],&amp;r[i]);
        for(int j=0;j&lt;r[i];j++){//地球-&gt;1  月球-&gt;n  太空站-&gt;2~n-1
            int t;scanf(&quot;%d&quot;,&amp;t);p[i][j]=t+1;
            if(p[i][j]==0) p[i][j]=n;//p[i][j]记录飞船i，在循环运动到相对第j个位置 所处的绝对位置
        }
    }
    Dic.AddEdge(S,1,INF);Dic.AddEdge(n,T,INF);//建源点和汇点
    int ans=0;
    while(ans&lt;100){
        ans++;
        Dic.AddEdge(S,ans*n+1,INF);Dic.AddEdge(ans*n+n,T,INF);//地球连源点、月球连汇点
        for(int i=1;i&lt;=m;i++){
            int u=p[i][pos[i]];pos[i]=(pos[i]+1)%r[i];//pos记录飞船i在其循环运动中的第几个位置
            int v=p[i][pos[i]];Dic.AddEdge(n*ans+u-n,n*ans+v,h[i]);//飞船在星球间运动
        }
        for(int i=2;i&lt;n;i++) Dic.AddEdge(ans*n-n+i,ans*n+i,INF);//对每个星球，前一天的星球应该向下一天连一条边
        for(auto &amp;v:Dic.edges) v.flow=0;//清空残余流量
        int FLOW=Dic.Maxflow(S,T);
        if(FLOW&gt;=k) {printf(&quot;%d\n&quot;,ans);return 0;}
    }
    printf(&quot;0\n&quot;);return 0;//无解输出0
}
</code></pre><hr>
<h5 id="13-负载平衡-费用流，循环建图-双向边"><a href="#13-负载平衡-费用流，循环建图-双向边" class="headerlink" title="13.负载平衡(费用流，循环建图-双向边)"></a>13.负载平衡(费用流，循环建图-双向边)</h5><pre><code>题意：公司有 n 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 n 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。

分析：由于总量是固定的，我们可以得出每个仓库的最终储货量，令 ai 表示原有储货量-最终储货量。对于每一个仓库，拆成两个点 xi 和 yi ，一个代表供应，一个代表需求。
若 ai&gt;0 ，从 S 向 xi 连一条容量为 ai 费用为 0 的边；若 ai&lt;0 ，从 yi 向 T 连一条容量为 −ai 费用为 0 的边；
对于两个相邻的顶点 j ，从 xi 分别向 xj 和 yj 连一条容量为 inf 费用为 1 的边。跑最小费用最大流即可。

注意：由于相邻的可以相互运输，于是仓库之间需要建双向边，如：1右→2左 且 1左←2右，注意费用是单位长度的费用！！！

int a[maxn];
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);
    int n,m;cin&gt;&gt;n;int S=0,T=2*n+1;Mc.init(2*n+2);
    int sum=0;
    for(int i=1;i&lt;=n;i++) {cin&gt;&gt;a[i];sum+=a[i];}
    sum/=n;
    for(int i=1;i&lt;=n;i++){
        Mc.AddEdge(S,i,a[i],0);Mc.AddEdge(i+n,T,sum,0);
        Mc.AddEdge(i,i+n,INF,0);
    }
    for(int i=2;i&lt;=n;i++) Mc.AddEdge(i-1+n,i,INF,1);Mc.AddEdge(n+n,1,INF,1);//1右→2左
    for(int i=1;i&lt;n;i++) Mc.AddEdge(i+1+n,i,INF,1);Mc.AddEdge(n+1,n,INF,1);//1左←2右
    ll cost=0;Mc.MincostMAXflow(S,T,cost);
    cout&lt;&lt;cost&lt;&lt;endl;
}
</code></pre><hr>
<h5 id="14-深海机器人问题"><a href="#14-深海机器人问题" class="headerlink" title="14.深海机器人问题()"></a>14.深海机器人问题()</h5><hr>
<h5 id="POJ-2125-最小割输出方案"><a href="#POJ-2125-最小割输出方案" class="headerlink" title="POJ-2125 最小割输出方案"></a>POJ-2125 最小割输出方案</h5><pre><code>题意：最小割问题不是很复杂，主要是第一次做最小割输出方案
思路：对于输出方案，跑完最大流之后，图会被分为两个点集，一个连源点一个连汇点
    从起点开始做一遍dfs，向下扩展的条件是边的容量大于它的流量(有残余流量)

    和源点相连的 -能被访问- 到的点是左边的最小割，和汇点相连的 -不能被访问- 到的点是右边的最小割
    为什么呢？因为割边都是满流边。
        与源点相连的点,如果不能被访问到说明连边达到满流，显然是割边。
        与汇点相连的点，我也不知道为啥，那就记住吧，能被访问到的就是割边

这是网友的解释：https://www.bbsmax.com/A/A2dmnO27ze/

bool vis[maxn];
vector&lt;int&gt; ANS;
void dfs(int u){
    vis[u]=1;
    for(int i=0;i&lt;Dic.G[u].size();i++){
        int v=Dic.G[u][i];
        if(Dic.edges[v].cap&gt;Dic.edges[v].flow&amp;&amp;!vis[Dic.edges[v].to])
            dfs(Dic.edges[v].to);
    }
}
void solve(int S,int T){
    int ans=Dic.Maxflow(S,T);
    cout&lt;&lt;ans&lt;&lt;endl;
    dfs(S);
    for(int i=1;i&lt;=2*n;i++){
        if(i&gt;n){if(vis[i]) ANS.push_back(i);}
        else{if(!vis[i]) ANS.push_back(i);}
    }
    cout&lt;&lt;ANS.size()&lt;&lt;endl;
    for(int i=0;i&lt;ANS.size();i++){
        if(ANS[i]&gt;n) cout&lt;&lt;ANS[i]-n&lt;&lt;&quot; +&quot;&lt;&lt;endl;
        else cout&lt;&lt;ANS[i]&lt;&lt;&quot; -&quot;&lt;&lt;endl;
    }
}
int main()
{
    fastinout;cin&gt;&gt;n&gt;&gt;m;
    int S=0,T=2*n+1;Dic.init(2*n+2);
    for(int i=1;i&lt;=n;i++) {cin&gt;&gt;t;Dic.AddEdge(i+n,T,t);}
    for(int i=1;i&lt;=n;i++) {cin&gt;&gt;t;Dic.AddEdge(S,i,t);}
    for(int i=0;i&lt;m;i++){
        int u,v;cin&gt;&gt;u&gt;&gt;v;
        Dic.AddEdge(u,v+n,inf);
    }
    solve(S,T);
}
</code></pre>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/图论/" rel="tag"># 图论</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/25/线段树/" rel="next" title="线段树">
                <i class="fa fa-chevron-left"></i> 线段树
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/25/网络流-有上下界限制/" rel="prev" title="网络流-有上下界限制">
                网络流-有上下界限制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="XXF">
            
              <p class="site-author-name" itemprop="name">XXF</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/xxf0512" title="GitHub &rarr; https://github.com/xxf0512" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:1258003050@qq.com" title="E-Mail &rarr; mailto:1258003050@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#网络流"><span class="nav-text">网络流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模版"><span class="nav-text">模版</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#模版1-Dinic-SPFA-from-CSL-O-nnm"><span class="nav-text">模版1(Dinic-SPFA from CSL  O(nnm))</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模版2-Dijkstr-MCMF-from-NBWY"><span class="nav-text">模版2(Dijkstr-MCMF from NBWY)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模版3-Dijkstr-Bellman-from-CSL"><span class="nav-text">模版3(Dijkstr-Bellman from CSL)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模版4-最大匹配"><span class="nav-text">模版4(最大匹配)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#题目"><span class="nav-text">题目</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-飞行员配对方案问题-最大匹配"><span class="nav-text">1.飞行员配对方案问题(最大匹配)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-太空飞行计划（最大点权闭合子图）"><span class="nav-text">2.太空飞行计划（最大点权闭合子图）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-最小路径覆盖-二分图匹配"><span class="nav-text">3.最小路径覆盖(二分图匹配)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-魔术球-待补"><span class="nav-text">4.魔术球(待补)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-圆桌聚餐-最大流"><span class="nav-text">5.圆桌聚餐(最大流)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#6-最长递增子序列问题-最大流"><span class="nav-text">6.最长递增子序列问题(最大流)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-试题库问题-最大流"><span class="nav-text">7.试题库问题(最大流)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-机器人路径规划问题"><span class="nav-text">8.机器人路径规划问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-方格取数问题-最大点权独立集"><span class="nav-text">9.方格取数问题(最大点权独立集)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-餐巾计划问题-最小费用最大流-好难啊"><span class="nav-text">10.餐巾计划问题(最小费用最大流)(好难啊!!!)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-航空路线问题-最小费用最大流-输出路径"><span class="nav-text">11.航空路线问题(最小费用最大流-输出路径)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-软件补丁问题-待补-太难了"><span class="nav-text">12.软件补丁问题(待补-太难了!!!)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-星际转移问题-分层图动态加边-最大流"><span class="nav-text">13.星际转移问题(分层图动态加边-最大流)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-负载平衡-费用流，循环建图-双向边"><span class="nav-text">13.负载平衡(费用流，循环建图-双向边)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14-深海机器人问题"><span class="nav-text">14.深海机器人问题()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#POJ-2125-最小割输出方案"><span class="nav-text">POJ-2125 最小割输出方案</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XXF</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">250k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">3:47</span>
  
</div>




  <span class="post-meta-divider">|</span>






<!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
        总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style="display:none">
        访客数<span id="busuanzi_value_site_uv"></span>人
</span>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>

<script type="text/javascript" src="/custom/fold_action.js?v=7.1.0"></script>


  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>

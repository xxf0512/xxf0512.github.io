<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="背包问题参考背包九讲的内容，首先给定一个有容量的背包(限定条件)，再给出每件(种)物品的价值和体积，背包问题大致可分为以下几种： 1.01背包(n个物品，对每个物品选或不选) 2.完全背包(n种物品，每种可取无数件，每件物品选或不选) 3.多重背包(n种物品，每种可取k[i]件,不选/选/选几件) 4.分组背包(n组物品，每组最多选一件，选/不选) 5.二维费用背包(两个维度的限制条件) 6.混合">
<meta name="keywords" content="动态规划">
<meta property="og:type" content="article">
<meta property="og:title" content="背包问题">
<meta property="og:url" content="http://xxf0512.github.io/2019/07/23/背包九讲/index.html">
<meta property="og:site_name" content="XXF">
<meta property="og:description" content="背包问题参考背包九讲的内容，首先给定一个有容量的背包(限定条件)，再给出每件(种)物品的价值和体积，背包问题大致可分为以下几种： 1.01背包(n个物品，对每个物品选或不选) 2.完全背包(n种物品，每种可取无数件，每件物品选或不选) 3.多重背包(n种物品，每种可取k[i]件,不选/选/选几件) 4.分组背包(n组物品，每组最多选一件，选/不选) 5.二维费用背包(两个维度的限制条件) 6.混合">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png">
<meta property="og:updated_time" content="2019-08-17T02:40:09.421Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="背包问题">
<meta name="twitter:description" content="背包问题参考背包九讲的内容，首先给定一个有容量的背包(限定条件)，再给出每件(种)物品的价值和体积，背包问题大致可分为以下几种： 1.01背包(n个物品，对每个物品选或不选) 2.完全背包(n种物品，每种可取无数件，每件物品选或不选) 3.多重背包(n种物品，每种可取k[i]件,不选/选/选几件) 4.分组背包(n组物品，每组最多选一件，选/不选) 5.二维费用背包(两个维度的限制条件) 6.混合">
<meta name="twitter:image" content="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png">





  
  
  <link rel="canonical" href="http://xxf0512.github.io/2019/07/23/背包九讲/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>背包问题 | XXF</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/xxf0512" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XXF</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">少说废话</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xxf0512.github.io/2019/07/23/背包九讲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XXF">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XXF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">背包问题

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-23 14:03:07" itemprop="dateCreated datePublished" datetime="2019-07-23T14:03:07+08:00">2019-07-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-17 10:40:09" itemprop="dateModified" datetime="2019-08-17T10:40:09+08:00">2019-08-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/动态规划/" itemprop="url" rel="index"><span itemprop="name">动态规划</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">18k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">17 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><pre><code>参考背包九讲的内容，首先给定一个有容量的背包(限定条件)，再给出每件(种)物品的价值和体积，背包问题大致可分为以下几种：
1.01背包(n个物品，对每个物品选或不选)
2.完全背包(n种物品，每种可取无数件，每件物品选或不选)
3.多重背包(n种物品，每种可取k[i]件,不选/选/选几件)
4.分组背包(n组物品，每组最多选一件，选/不选)
5.二维费用背包(两个维度的限制条件)
6.混合背包(1.2.3三种情况的混合)
7.其他(问法不同(最值与可行性)、泛化物品)
</code></pre><hr>
<h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><pre><code>最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放
F[i,v] 表示前 i 件物品恰放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程便是：
F[i,v]=max{F[i−1,v],F[i−1,v−C[i]]+W[i]}
伪代码(时间和空间复杂度均为O(VN))：
    F[0,0..V ] ← 0
    for i ← 1 to N
    for v ← C i to V
    F[i,v]=max{F[i−1,v],F[i−1,v−C[i]]+W[i]}

滚动数组优化空间复杂度：F[v]=max{F[v],F[v−C[i]]+W[i]}
伪代码(时间复杂度O(VN)、空间复杂度为O(N))：
    F[0..V ]←0
    for i ← 1 to N
    for v ← V to C i //注意递推是从上一次的正上方和左边过来的，这里就不难理解了
    F[v]=max{F[v],F[v−C[i]]+W[i]}


不同的问法：恰好装满 与 不必装满
    若是恰好装满，那么在初始化时除了F[0]为0，其它F[1..V]均设为 −∞ ，这样就可以保证最终得到的F[V]是一种恰好装满背包的最优解。
    可以理解为：初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，
    那么此时只有容量为 0 的背包可以在什么也不装且价值为0的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 -∞ 了。
    如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为0了。

    如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 F[0..V ]全部设为 0 。
</code></pre><h5 id="01背包题目"><a href="#01背包题目" class="headerlink" title="01背包题目"></a>01背包题目</h5><h6 id="HDU-2995-小数-概率-背包"><a href="#HDU-2995-小数-概率-背包" class="headerlink" title="HDU-2995 小数/概率 背包"></a>HDU-2995 小数/概率 背包</h6><pre><code>题意：抢劫银行，给定被抓最大概率P，给出n个银行(其价值和被抓概率)，求被抓概率小于P的情况下，可抢到的最大价值。
注意：概率不是累加而是累乘，同时应把最抓概率转换成不被抓概率，因为被抓概率累乘会变得更小，显然错误，应该是不被抓概率累乘变得更小。
思路：开始直接想到背包容量定为最大概率P，但是它是小数，想到P*100(or 1ek)转化为整数 结果WA；
    于是转变思路，让背包容量等于所有银行价值之和，dp[i]-&gt;不被抓概率
//HDU-2995 小数/概率 背包
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=105;
int w[maxn];
double v[maxn],dp[maxn*100];
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);
    int T;cin&gt;&gt;T; //int V=0 开始在这里定义 结果TLE 怎么又犯这种错误.
    while(T--){
        int V=0;
        double P;int n;cin&gt;&gt;P&gt;&gt;n;P=1.0-P;//转为不被抓概率
        for(int i=0;i&lt;n;i++){
            cin&gt;&gt;w[i]&gt;&gt;v[i];v[i]=1.0-v[i];V+=w[i];
        }
        for(int i=0;i&lt;n*100;i++) dp[i]=0;dp[0]=1;
        for(int i=0;i&lt;n;i++){
            for(int j=V;j&gt;=w[i];j--){
                dp[j]=max(dp[j],dp[j-w[i]]*v[i]);
            }
        }
        int ans=0;
        for(int i=V;i&gt;=0;i--){
            if(dp[i]&gt;=P){
                ans=i;break;
            }
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
}
</code></pre><h6 id="CF-366C-转化为01背包"><a href="#CF-366C-转化为01背包" class="headerlink" title="CF-366C 转化为01背包"></a>CF-366C 转化为01背包</h6><pre><code>题意:有n个水果, 每个水果都有两个属性值ai表示美味程度, bi表示能量值, 现在要求选出一个或多个水果, 使得选出的水果的ai和与bi和的比例是k 问在这种情形可能出现的情况下ai的和最多是多少, 如果这样的情形不存在输出 -1
思路：每个物品的耗费是a[i]-k*b[i]的物品，这样就可以转化为01背包，求dp[i][0]，但是这样算耗值可能是负值，所以我们数组平移n*100个单位，就可以求出dp[n][m]
注意：此题不能用一个dp数组完成滚动，因为a[i]-k*b[i]可能为负值，转移可能来自上一层的左上方或右上方，若滚动会覆盖冲突。
//CF-366C 转化为01背包
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=105;
const int INF=0x3f3f3f3f;
int n,k;
int a[maxn],b[maxn],dp[maxn][maxn*300];
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);
    cin&gt;&gt;n&gt;&gt;k;
    memset(dp,-INF,sizeof(dp));//无意义状态
    dp[0][100*n]=0;//不选时合法
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;b[i];b[i]=a[i]-k*b[i];
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=b[i];j&lt;=200*n;j++){
            dp[i][j]=max(dp[i-1][j],dp[i-1][j-b[i]]+a[i]);
        }
    }
    int ans=dp[n][100*n];
    cout&lt;&lt;(ans?ans:-1)&lt;&lt;endl;
}
</code></pre><hr>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><pre><code>完全背包与01背包唯一不同的是完全背包的每件物品可重复使用无数次。
状态转移： F[i,v] = max{F[i−1,v−kC[i]]+kW[i] | 0 ≤ kC[i]≤ v}
伪代码：
    F[0..V]←0
    for i ← 1 to N
        for v ← C i to V
            F[v] ← max(F[v],F[v − C[i]] + W[i])

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。
第 i 种物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

输入格式
    第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。
    接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。
输出格式
    输出一个整数，表示最大价值。
数据范围
    0&lt;N,V≤1000
    0&lt;vi,wi≤1000
样例 
   输入:4 5    输出：10
        1 2
        2 4
        3 4
        4 5
代码：
    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    typedef long long ll;
    const int maxn=1e3+5;
    int v[maxn],w[maxn],dp[maxn];
    int main()
    {
        ios::sync_with_stdio(0);cin.tie(0);
        int N,V;cin&gt;&gt;N&gt;&gt;V;
        for(int i=0;i&lt;N;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];
        for(int i=0;i&lt;N;i++) dp[i]=0;
        for(int i=0;i&lt;N;i++)
            for(int j=v[i];j&lt;=V;j++)//注意循环方向
                dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
        cout&lt;&lt;dp[V]&lt;&lt;endl;
    }
</code></pre><hr>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><pre><code>多重背包中每个物品可使用的次数是有限制条件的，因此要假如第三重循环，限制选的次数。
注意：背包问题中第一重循环是物品种类 ，第二重是背包体积 ，第三重是限制条件
多重背包的优化： 二进制优化、单调队列优化

模版题：
    有 N 种物品和一个容量是 V 的背包。
    第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。
    求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。

无优化 O(n*V*S)：
    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    typedef long long ll;
    const int maxn=1e3+5;
    int dp[maxn];
    int main()
    {
        ios::sync_with_stdio(0);cin.tie(0);
        int N,V;cin&gt;&gt;N&gt;&gt;V;
        for(int i=0;i&lt;N;i++) dp[i]=0;
        for(int i=0;i&lt;N;i++){
            int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;
            for(int j=V;j&gt;=v;j--)
                for(int k=0;k&lt;=s&amp;&amp;k*v&lt;=j;k++)
                    dp[j]=max(dp[j],dp[j-k*v]+k*w);
        }
        cout&lt;&lt;dp[V]&lt;&lt;endl;
    }



二进制优化 O(n*V*ΣS)：
    数据范围：0&lt;N≤1000  0&lt;V≤2000  0&lt;vi,wi,si≤2000
    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    typedef long long ll;
    const int maxn=2e3+5;
    int dp[maxn];
    struct node{
        int v,w;
    };
    vector&lt;node&gt; goods;
    int main()
    {
        ios::sync_with_stdio(0);cin.tie(0);
        int n,m;cin&gt;&gt;n&gt;&gt;m;
        for(int i=0;i&lt;n;i++){
            int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;
            for(int k=1;k&lt;=s;k*=2){
                s-=k;goods.push_back({v*k,w*k});
            }
            if(s) goods.push_back({v*s,w*s});
        }
        for(auto good:goods)
            for(int j=m;j&gt;=good.v;j--)
                dp[j]=max(dp[j],dp[j-good.v]+good.w);
        cout&lt;&lt;dp[m]&lt;&lt;endl;
    }     



单调队列优化 0(N*V):

    //未懂，待补+双端队列(滑动窗口)

    数据范围：0&lt;N≤1000  0&lt;V≤20000  0&lt;vi,wi,si≤20000
    双端队列思想优化背包问题-&gt; https://blog.csdn.net/hebtu666/article/details/83018230
    首先优化思路来自最最原始的无优化的方程。
    仔细观察，对于任意的j，都是从v[i]的倍数转移过来的。它们本来应该是连续的，可以用滑动窗口（不熟悉此问题的同学可以先行百度）解决。但在无优化的时候却每次把所有的倍数都遍历了一遍。
    所以可以把m根据模v[i]的余数分为v[i]类。

    for(int j=0;j&lt;v;j++)
    此时对于任意的j，只需要向v[i]的倍数去转移。所以我们在下一层循环的时候把k定义为j+k*v[i]

    for(int k=j;k&lt;=m;k+=v)
    此时的k相当于原来的j，但是我们可以利用k和v之间存在的倍数关系去做滑动窗口。
    由于滑动窗口记录的是下标，但每一个k所对应的下标都是在变化的。所以要根据当前的k判断窗口里存在的k对应的值包含了多少个v，以便于计算新的价值

    v的个数=(下标-余数)/v   价值=(下标-余数)/v*w
        =(q[h]-j)/v          =(k-j)/v*w
    然后每次只用了前i-1的值，所以可以滚动数组优化一下空间

    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    const int maxn=2e4+5;
    int n,m,dp[maxn],q[maxn],g[maxn];
    int main()
    {
        ios::sync_with_stdio(0);cin.tie(0);
        cin&gt;&gt;n&gt;&gt;m;
        for(int i=1;i&lt;=n;i++){
            int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;
            memcpy(g,dp,sizeof(dp));//滚动数组优化空间，g[]即dp[i-1][];
            for(int j=0;j&lt;v;j++){
                int h=0,t=-1;
                for(int k=j;k&lt;=m;k+=v){
                    dp[k]=g[k];
                    if(h&lt;t&amp;&amp;k-s*v&gt;q[h]) h++;//如果当前窗口的内容超过了s个;
                    if(h&lt;=t) dp[k]=max(dp[k],g[q[h]]+(k-q[h])/v*w);//max(f[i-1][k],f[i-1][能转移里最大]+个数*v[i]);
                    while(h&lt;=t&amp;&amp;g[q[t]]-(q[t]-j)/v*w&lt;=g[k]-(k-j)/v*w) t--;
                    q[++t]=k;
                }
            }
        }
        cout&lt;&lt;dp[m]&lt;&lt;endl;
    }
</code></pre><hr>
<h4 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h4><pre><code>混合背包就是把以上三种背包问题混合在一起，什么物品可以选几次有响应的限制条件，根据条件选择不同的dp方程即可

模版题：
    有 N 种物品和一个容量是 V 的背包。物品一共有三类：
    * 第一类物品只能用1次（01背包）；
    * 第二类物品可以用无限次（完全背包）；
    * 第三类物品最多只能用 si 次（多重背包）；
    每种体积是 vi，价值是 wi。
    求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。

    输入格式：
        第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。
        接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。
        si=−1 表示第 i 种物品只能用1次；
        si=0 表示第 i 种物品可以用无限次；
        si&gt;0 表示第 i 种物品可以使用 si 次；
    输出格式：
        输出一个整数，表示最大价值。
    数据范围：0&lt;N,V≤1000 ，0&lt;vi,wi≤1000 ，−1≤si≤1000
    输入样例：             输出样例：
            4 5                    8
            1 2 -1
            2 4 1
            3 4 0
            4 5 2

代码：
    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    const int maxn=1e3+5;
    int dp[maxn];
    struct node{
        int v,w,s;
    };
    int n,V;
    vector&lt;node&gt; G;
    int main()
    {
        ios::sync_with_stdio(0);cin.tie(0);
        cin&gt;&gt;n&gt;&gt;V;
        for(int i=0;i&lt;n;i++){
            int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;
            if(s==-1) G.push_back({v,w,-1});
            else if(s==0) G.push_back({v,w,0});
            else{
                for(int k=1;k&lt;=s;k*=2){
                    G.push_back({v*k,w*k,-1});s-=k;
                }
                if(s) G.push_back({v*s,w*s,-1});
            }
        }
        for(auto g:G){
            if(g.s==-1)
                for(int j=V;j&gt;=g.v;j--) dp[j]=max(dp[j],dp[j-g.v]+g.w);
            else if(g.s==0)
                for(int j=g.v;j&lt;=V;j++) dp[j]=max(dp[j],dp[j-g.v]+g.w);
        }
        cout&lt;&lt;dp[V]&lt;&lt;endl;
    }
</code></pre><hr>
<h4 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h4><pre><code>二维费用背包就是加了重限制条件，物品的总体积与物品的总重量都不能超过背包可承受范围。

有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。
每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。
求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。
输出最大价值。
输入格式：
    第一行两个整数，N，V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。
    接下来有 N 行，每行三个整数 vi,mi,wi，用空格隔开，分别表示第 i 件物品的体积、重量和价值。

输出格式：
    输出一个整数，表示最大价值。

数据范围：
        0&lt;N≤1000 ，0&lt;V,M≤100 ，0&lt;vi,mi≤100 ，0&lt;wi≤1000
输入样例：          输出样例：
        4 5 6               8
        1 2 3
        2 4 4
        3 4 5
        4 5 6 
代码：
    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    const int maxn=1e3+5;
    int n,V,M;
    int v[maxn],m[maxn],w[maxn];
    int dp[maxn][maxn];
    int main()
    {
        ios::sync_with_stdio(0);cin.tie(0);
        cin&gt;&gt;n&gt;&gt;V&gt;&gt;M;
        for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i]&gt;&gt;m[i]&gt;&gt;w[i];
        for(int i=0;i&lt;n;i++)
            for(int j=V;j&gt;=v[i];j--)
                for(int k=M;k&gt;=m[i];k--)
                    dp[j][k]=max(dp[j][k],dp[j-v[i]][k-m[i]]+w[i]);
        cout&lt;&lt;dp[V][M]&lt;&lt;endl;
    }
</code></pre><hr>
<h4 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h4><pre><code>分组背包就是把物品分为很多组，限定每组最多可选的个数

有 N 组物品和一个容量是 V 的背包。
每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。
求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。

输入格式
    第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。
    接下来有 N 组数据：
        每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
        每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；

输出格式
    输出一个整数，表示最大价值。

数据范围：0&lt;N,V≤100，0&lt;Si≤100，0&lt;vij,wij≤100
输入样例：      输出样例：
        3 5             8
        2
        1 2
        2 4
        1
        3 4
        1
        4 5

代码：
    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    const int maxn=1e2+5;
    int n,V;
    int v[maxn],w[maxn];//体积和价值
    int dp[maxn];
    int main()
    {
        ios::sync_with_stdio(0);cin.tie(0);
        cin&gt;&gt;n&gt;&gt;V;
        for(int i=0;i&lt;n;i++){
            int s;cin&gt;&gt;s;
            for(int j=1;j&lt;=s;j++) cin&gt;&gt;v[j]&gt;&gt;w[j];
            for(int j=V;j&gt;=0;j--)
                for(int k=1;k&lt;=s;k++)每组选一个使价值最大化
                    if(j&gt;=v[k]) dp[j]=max(dp[j],dp[j-v[k]]+w[k]);
        }
        cout&lt;&lt;dp[V]&lt;&lt;endl;
    }
</code></pre><hr>
<h4 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h4><pre><code>待补
</code></pre><p><img src="https://www.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ%E5%9B%BE%E7%89%8720181018170337.png" alt="有依赖背包"></p>
<pre><code>有 N 个物品和一个容量是 V 的背包。
物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。

如上图所示：
    如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。
    每件物品的编号是 i，体积是 vi，价值是 wi，依赖的父节点编号是 pi。物品的下标范围是 1…N。
    求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。

输入格式：
    第一行有两个整数 N，V，用空格隔开，分别表示物品个数和背包容量。
    接下来有 N 行数据，每行数据表示一个物品。
    第 i 行有三个整数 vi,wi,pi，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。
    如果 pi=−1，表示根节点。 数据保证所有物品构成一棵树。

输出格式：
    输出一个整数，表示最大价值。

数据范围：1≤N,V≤100，1≤vi,wi≤100
父节点编号范围：
    内部结点：1≤pi≤N;
    根节点 pi=−1;
输入样例    输出样例：
5 7                 11
2 3 -1
2 2 1
3 5 1
4 7 2
3 6 2

#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

const int N = 110;

int n, m;
int h[N], e[N], ne[N], idx;
int v[N], w[N];
int f[N][N];

void add(int x, int y) {
    e[idx] = y, ne[idx] = h[x], h[x] = idx++;
}

void dfs(int x) {
    for (int i = h[x]; i != -1; i = ne[i]) {
        int y = e[i];
        dfs(y);
        for (int j = m - v[x]; j &gt;= 0; j--) {
            for (int k = 0; k &lt;= j; k++) {
                f[x][j] = max(f[x][j], f[x][j - k] + f[y][k]);
            }
        }
    }
    for (int i = m; i &gt;= v[x]; i--) {
        f[x][i] = f[x][i - v[x]] + w[x];
    }
    for (int i = 0; i &lt; v[x]; i++) {
        f[x][i] = 0;
    }
}

int main() {
    memset(h, -1, sizeof h);
    cin &gt;&gt; n &gt;&gt; m;
    int root;
    for (int i = 1; i &lt;= n; i++) {
        int p;
        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p;
        if (p == -1) {
            root = i;
        } else {
            add(p, i);
        }
    }
    dfs(root);
    cout &lt;&lt; f[root][m] &lt;&lt; endl;
    return 0;
}
</code></pre><hr>
<h4 id="背包问题求方案数"><a href="#背包问题求方案数" class="headerlink" title="背包问题求方案数"></a>背包问题求方案数</h4><pre><code>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
第 i 件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出 最优选法的方案数。注意答案可能很大，请输出答案模 1e9+7 的结果。

输入格式:
    第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
    接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

输出格式:
    输出一个整数，表示 方案数 模 109+7 的结果。

数据范围: 0&lt;N,V≤1000, 0&lt;vi,wi≤1000
输入样例:       输出样例:
        4 5             2
        1 2
        2 4
        3 4
        4 6
代码：
    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    typedef long long ll;
    const int maxn=1e3+5;
    const ll mod=1e9+7;
    int n,V;
    int v[maxn],w[maxn];
    int dp[maxn];
    ll num[maxn];
    int main()
    {
        ios::sync_with_stdio(0);cin.tie(0);
        cin&gt;&gt;n&gt;&gt;V;
        for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];
        for(int i=0;i&lt;=V;i++) num[i]=1;
        for(int i=1;i&lt;=n;i++){
            for(int j=V;j&gt;=v[i];j--){
                if(dp[j]&lt;dp[j-v[i]]+w[i]){
                    dp[j]=dp[j-v[i]]+w[i];
                    num[j]=num[j-v[i]]%mod;
                }
                else if(dp[j]==dp[j-v[i]]+w[i]){
                    num[j]=(num[j-v[i]]+num[j])%mod;
                }
            }
        }
        cout&lt;&lt;num[V]&lt;&lt;endl;
    }
</code></pre><hr>
<h4 id="背包问题求具有方案"><a href="#背包问题求具有方案" class="headerlink" title="背包问题求具有方案"></a>背包问题求具有方案</h4><pre><code>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
第 i 件物品的体积是 vi，价值是 wi。
输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N。
输出 最优选法的方案数。注意答案可能很大，请输出答案模 1e9+7 的结果。

输入格式:
    第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
    接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

输出格式:
    输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。
    物品编号范围是 1…N

数据范围: 0&lt;N,V≤1000, 0&lt;vi,wi≤1000
输入样例:       输出样例:
        4 5              1 4
        1 2
        2 4
        3 4
        4 6

代码：
    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    typedef long long ll;
    const int maxn=1e3+5;
    const ll mod=1e9+7;
    int n,V;
    int v[maxn],w[maxn];
    int dp[maxn][maxn];
    int main()
    {
        ios::sync_with_stdio(0);cin.tie(0);
        cin&gt;&gt;n&gt;&gt;V;
        for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];
        for(int i=n;i&gt;=1;i--)
            for(int j=0;j&lt;=V;j++){//这样写dp方程是因为dp[i][j]的意义与之前的不同
                                //dp[i][j] -&gt;从前i件物品中选，使得背包容量大于j的 方案的价值
                if(j&gt;=v[i]) dp[i][j]=max(dp[i+1][j],dp[i+1][j-v[i]]+w[i]);
                else dp[i][j]=dp[i+1][j];
            }
        for(int i=1;i&lt;=n;i++){
            if(i==n&amp;&amp;V&gt;=v[i]){
                cout&lt;&lt;i&lt;&lt;&quot; &quot;;break;
            }
            if(V-v[i]&gt;=0&amp;&amp;dp[i][V]==dp[i+1][V-v[i]]+w[i]){
                cout&lt;&lt;i&lt;&lt;&quot; &quot;;V-=v[i];
            }
            if(V&lt;0) break;
        }
    }
</code></pre><hr>
<h4 id="超大背包"><a href="#超大背包" class="headerlink" title="超大背包"></a>超大背包</h4><h5 id="体积超大、价值适合"><a href="#体积超大、价值适合" class="headerlink" title="体积超大、价值适合"></a>体积超大、价值适合</h5><pre><code>给出N个物品，所有物品的的价值总和V不会超过5000，但是背包的体积B和物品的体积超大(1e10)，求背包能装出来的最大价值

这种背包问题显然要以价值为突破口，转化一下dp的含义，令dp[i][j]-&gt;从前i个物品中选出价值总和为j的物品的最小的体积，
那么求最大价值时按照V从大到小遍历dp即可，当dp[i][j]&lt;=B时输出j即可

FZU-2214
#include&lt;iostream&gt;
using namespace std;
typedef long long ll;
const ll INF=1e12;
int v[505];
ll w[505],dp[5005];
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int T;cin&gt;&gt;T;
    while(T--){
        int n,V=0;ll B;cin&gt;&gt;n&gt;&gt;B;
        for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i],V+=v[i];
        for(int i=1;i&lt;=V;i++) dp[i]=INF;dp[0]=0;//注意初始化
        for(int i=1;i&lt;=n;i++)
            for(int j=V;j&gt;=v[i];j--)
                dp[j]=min(dp[j],dp[j-v[i]]+w[i]);
        for(int i=V;i&gt;=0;i--){
            if(dp[i]&lt;=B){
                cout&lt;&lt;i&lt;&lt;endl;break;
            }
        }

    }
}
</code></pre><h5 id="体积超大、价值超大"><a href="#体积超大、价值超大" class="headerlink" title="体积超大、价值超大"></a>体积超大、价值超大</h5><pre><code>这种题目显然不能dp了，因为数组开不下，记录不了状态，那怎么做呢。往往会设置一个比较小的物品数量，使得可以折半枚举。
给你N(N≤40)个物品，物品的单个价值和重量都达到10^15问你在背包容量为W下背包所能装出来的最大价值

采用折半枚举法，先把前2^20个物品的组合先枚举预处理出来2^20个w、v。
然后如果我们能对于这枚举出来的前 2^20 个和后面 2^20 个物品的某个组合结合然后找出最优的结果，最后从这 2^20 个最优结果中再取最优就是答案，问题就是如何对于预处理出来的前 2^20 个组合与后面结合产生最优。
假设现在背包容量为 C ，在前 2^20 个物品组合中取出一个，价值为 vi 重量为 wi ，那么如果我们能从后 2^20 个中找出一个组合使得其在满足重量 w&apos; ≤ C - wi 的情况下价值最大

只要对于后 2^20 个的所有组合处理出其重量和价值，然后根据重量排序且根据价值去重
这样就能用二分查找来加快查找速度！

#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int maxn=40;
const ll INF=0x3f3f3f3f3f3f3f3f;
pair&lt;ll,ll&gt; pi[1&lt;&lt;(maxn/2)];//(重量，价值)
ll w[maxn],v[maxn],N,W;
int main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin&gt;&gt;N&gt;&gt;W;
    for(int i=0;i&lt;N;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];

    //枚举前半部分 O(2^N/2)
    int N2=N/2;
    for(int i=0;i&lt;(1&lt;&lt;N2);i++){
        ll sw=0,sv=0;
        for(int j=0;j&lt;N2;j++){
            if(i&gt;&gt;j&amp;1){//按二进制枚举
                sw+=w[j];sv+=v[j];
            }
        }
        pi[i]=make_pair(sw,sv);
    }

    //去除多余的元素：使得对i&lt;j有 sw[i]&lt;=sw[j]并且sv[i]&gt;=sv[j]
    sort(pi,pi+(1&lt;&lt;N2));//按照第一键值（重量）排序

    int num=1;
    for(int i=1;i&lt;(1&lt;&lt;N2);i++)
        if(pi[num-1].second&lt;pi[i].second)//当i的重量大于num-1的重量且价值小于num-1的价值时，i被放弃
            pi[num++]=pi[i];

    ll ans=0;
    for(int i=0;i&lt;(1&lt;&lt;(N-N2));i++){//枚举后半段的组合
        ll sw=0,sv=0;
        for(int j=0;j&lt;(N-N2);j++){
            if(i&gt;&gt;j&amp;1){
                sw+=w[N2+j];sv+=v[N2+j];
            }
        }
        if(sw&lt;=W){//在前半段的组合中找到体积小于等于W-sw的第一个即价值最大的那个
            int idx=(lower_bound(pi,pi+num,make_pair(W-sw,INF))-pi)-1;
            pair&lt;ll,ll&gt;tmp=pi[idx];
            ans=max(ans,sv+tmp.second);
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
/*

体积 价值
4 5
4 2
5 2
2 1
8 3

13

*/
</code></pre>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/动态规划/" rel="tag"># 动态规划</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/17/LCA/" rel="next" title="LCA">
                <i class="fa fa-chevron-left"></i> LCA
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/26/SG函数/" rel="prev" title="SG函数与SG定理">
                SG函数与SG定理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="XXF">
            
              <p class="site-author-name" itemprop="name">XXF</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/xxf0512" title="GitHub &rarr; https://github.com/xxf0512" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:1258003050@qq.com" title="E-Mail &rarr; mailto:1258003050@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#背包问题"><span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01背包"><span class="nav-text">01背包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#01背包题目"><span class="nav-text">01背包题目</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#HDU-2995-小数-概率-背包"><span class="nav-text">HDU-2995 小数/概率 背包</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CF-366C-转化为01背包"><span class="nav-text">CF-366C 转化为01背包</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完全背包"><span class="nav-text">完全背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多重背包"><span class="nav-text">多重背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#混合背包"><span class="nav-text">混合背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二维费用背包"><span class="nav-text">二维费用背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分组背包"><span class="nav-text">分组背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有依赖的背包问题"><span class="nav-text">有依赖的背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#背包问题求方案数"><span class="nav-text">背包问题求方案数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#背包问题求具有方案"><span class="nav-text">背包问题求具有方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#超大背包"><span class="nav-text">超大背包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#体积超大、价值适合"><span class="nav-text">体积超大、价值适合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#体积超大、价值超大"><span class="nav-text">体积超大、价值超大</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XXF</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">195k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">2:58</span>
  
</div>




  <span class="post-meta-divider">|</span>






<!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
        总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style="display:none">
        访客数<span id="busuanzi_value_site_uv"></span>人
</span>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>

<script type="text/javascript" src="/custom/fold_action.js?v=7.1.0"></script>


  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SG函数与SG定理]]></title>
    <url>%2F2019%2F07%2F26%2FSG%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[SG函数-引入SG函数用来判断博弈问题的输赢，当SG函数值为0时表示输，不为0表示赢。 定义mex(s)表示不属于s集合的最小非负整数，例如:mex{0,1,2}=3、mex{1,2,3}=0、mex{0,1,3}=2 定义SG函数:SG(x)=mex{SG(y)|y是x的后继,也就是经过操作可以取得的剩下值} S是x后继状态的SG函数值的集合。如x有三个后继状态分别为SG(a),SG(b),SG(c)那么SG(x)=mex{SG(x)}=mex{SG(a,SG(b),SG(c))}。这样集合S的终态必然是空集，所以SG函数的终态为SG(x)=0,当且仅当x为必败点P时。 例如：一堆石子，我们可以取任意个，那么x个石子的石子的sg值是多少呢？ 可以知道，0个石子sg为0，1的时候我们可以取1个，剩下0，而0的sg是0，那么mex{0}就是1，所以1的sg为1。即SG(1)=mex{SG(0)}=mex{0}=1; SG(2)=mex{SG(0),SG(1)}=mex{0,1}=2;SG(3)=mex(SG(0),SG(1),SG(2))=mex{0,1,2}=3 继续往下，当为x的时候我们可以取1~x个，那么剩下的值石子个数就是x-1到0个，他的mex（...）就是x，所以这个例子的x值得sg值就是x，即SG(x)=mex{SG(0),SG(1),SG(2),SG(3),...,SG(x-1)=x; SG函数的作用： Nimm博弈中，对于多堆，只需将每堆的SG值异或一下(每堆的数量)，如果是0则为输，否则为赢 组合游戏在竞赛中，组合游戏的题目一般有以下特点 1.题目描述一般为A,B 2人做游戏 2.A,B交替进行某种游戏规定的操作，每操作一次，选手可以在有限的操作（操作必须合法）集合中任选一种。 3.对于游戏的任何一种可能的局面，合法的操作集合只取决于这个局面本身，不取决于其它因素（跟选手，以前的所有操作无关） 4.如果当前选手无法进行合法的操作，则为负 必胜点与必败点必败点(P点) 前一个(previous player)选手将取胜的点称为必败点 必胜点(N点) 下一个(next player)选手将取胜的点称为必胜点 必胜点和必败点的性质： - 所有的终结点都是必败点 - 从任何必胜点操作，至少有一种方式进入必败点 - 无论如何操作， 从必败点都只能进入必胜点. SG定理游戏和的SG函数等于各个游戏SG函数的Nim和。这样就可以将每一个子游戏分而治之，从而简化了问题。而Bouton定理就是Sprague-Grundy定理在Nim游戏中的直接应用，因为单堆的Nim游戏SG函数满足SG(x)=x。 举栗-取石子游戏有1堆n个的石子，每次只能取{1,3,4}个石子，先取完石子者胜利，那么各个数的SG值为多少？ SG(0)=0,f[]={1,3,4}. x=1时，可以取走1-f[1]个石子,剩余{0}个，所以SG(1)=mex{SG(0)}=mex{0}=1; x=2时，可以取走2-f[1]个石子,剩余{1}个，所以SG(2)=mex{SG(1)}=mex{1}=0; x=3时，可以取走3-f[1,3]个石子,剩余{2,0}个，所以SG(3)=mex{SG(0),SG(2)}=mex{0,0}=0; x=4时，可以取走4-f[1,2,3]个石子,剩余{3,1,0}个，所以SG(4)=mex{SG(3),SG(1),SG(0)}=mex{0,1}=2; x=5时，可以取走5-f[1,2,3]个石子,剩余{4,2,1}个，所以SG(5)=mex{SG(4),SG(2),SG(1)}=mex{2,1,0}=3; 继续推：SG(6)=2、SG(7)=0、SG(8)=1 ..... 编程时只需模拟上述过程计算1~n的SG函数值： 1.使用数组f将 可改变当前状态 的方式记录下来。 2.然后我们使用 另一个数组 将当前状态x的后继状态标记。 3.最后模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x)。 4.我们不断的重复2-3的步骤，就完成了计算1~n的函数值。 //f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理 //SG[]:0~n的SG函数值 //S[]:为x后继状态的集合 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+5; int f[3]={1,2,4},SG[maxn],S[maxn];//S为状态集合 int N=3;//f的个数 void getSG(int n){ memset(SG,0,sizeof(SG)); for(int i=1;i&lt;=n;i++){//因为SG[0]始终等于0，所以i从1开始 memset(S,0,sizeof(S));//每一次都要将上一状态 的 后继集合 重置 for(int j=0;f[j]&lt;=i&amp;&amp;j&lt;=N;j++) S[SG[i-f[j]]]=1;//将后继状态的SG函数值进行标记 for(int j=0;;j++) //查询当前后继状态SG值中最小的非零值 if(!S[j]){SG[i]=j;break;} } } int main() { ios::sync_with_stdio(0);cin.tie(0); int n,x;cin&gt;&gt;n;getSG(n); while(cin&gt;&gt;x){ cout&lt;&lt;SG[x]&lt;&lt;endl; } } 题目HDU-4388(找1个数的奇偶性)(博弈+找规律)//HDU-4388 Stone Game II 题意：给出n堆物品，每堆物品都有若干件，现在A和B进行游戏，每人每轮操作一次，按照如下规则： 1. 任意选择一个堆，假设该堆有x个物品，从中选择k个，要保证0&lt;k&lt;x且0&lt;(x^k)&lt;k。 2. 再增加一个大小为x^k的堆，另外有一个技能，可以将这个大小为x^k的堆变成(2*k)^x的堆，但是这个技能每个人只有一次机会可以使用。 现在问两人轮流操作，都采取最优策略，最后不能操作的人输，问谁会赢。 思路：不考虑技能的话，一堆x分为k和k^x，实际上在二进制下x中1的个数与k和k^x中1的个数的奇偶性保持一致。 考虑技能，一堆x分为k和(k&lt;&lt;1)^x,其中二者之间的奇偶性也没变，可以写一个试一下。 游戏终止的条件是一堆不能再分了，即分到最后每堆中1的个数都为1，于是原来的n堆可以分为n个数中1(二进制下)的个数之和堆(设为cnt)， 需要分(cnt-n)次才行，于是变成了判断(cnt-n)的奇偶性，为奇数时先手赢否则先手输。 ^.^貌似和SG没啥关系。。。但是大佬的博客把这一题归在SG #include&lt;bits/stdc++.h&gt; using namespace std; int cal(int x){ int ans=0; while(x){ ans+=(x&amp;1); x&gt;&gt;=1; } return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); int T;cin&gt;&gt;T;int ca=1; while(T--){ int n,ans=0;cin&gt;&gt;n; while(n--){ int t;cin&gt;&gt;t;ans+=cal(t)-1; } cout&lt;&lt;&quot;Case &quot;&lt;&lt;ca++&lt;&lt;&quot;: &quot;; if(ans&amp;1) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } }]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2019%2F07%2F23%2F%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[背包问题参考背包九讲的内容，首先给定一个有容量的背包(限定条件)，再给出每件(种)物品的价值和体积，背包问题大致可分为以下几种： 1.01背包(n个物品，对每个物品选或不选) 2.完全背包(n种物品，每种可取无数件，每件物品选或不选) 3.多重背包(n种物品，每种可取k[i]件,不选/选/选几件) 4.分组背包(n组物品，每组最多选一件，选/不选) 5.二维费用背包(两个维度的限制条件) 6.混合背包(1.2.3三种情况的混合) 7.其他(问法不同(最值与可行性)、泛化物品) 01背包最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放 F[i,v] 表示前 i 件物品恰放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程便是： F[i,v]=max{F[i−1,v],F[i−1,v−C[i]]+W[i]} 伪代码(时间和空间复杂度均为O(VN))： F[0,0..V ] ← 0 for i ← 1 to N for v ← C i to V F[i,v]=max{F[i−1,v],F[i−1,v−C[i]]+W[i]} 滚动数组优化空间复杂度：F[v]=max{F[v],F[v−C[i]]+W[i]} 伪代码(时间复杂度O(VN)、空间复杂度为O(N))： F[0..V ]←0 for i ← 1 to N for v ← V to C i //注意递推是从上一次的正上方和左边过来的，这里就不难理解了 F[v]=max{F[v],F[v−C[i]]+W[i]} 不同的问法：恰好装满 与 不必装满 若是恰好装满，那么在初始化时除了F[0]为0，其它F[1..V]均设为 −∞ ，这样就可以保证最终得到的F[V]是一种恰好装满背包的最优解。 可以理解为：初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满， 那么此时只有容量为 0 的背包可以在什么也不装且价值为0的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 -∞ 了。 如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为0了。 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 F[0..V ]全部设为 0 。 01背包题目HDU-2995 小数/概率 背包题意：抢劫银行，给定被抓最大概率P，给出n个银行(其价值和被抓概率)，求被抓概率小于P的情况下，可抢到的最大价值。 注意：概率不是累加而是累乘，同时应把最抓概率转换成不被抓概率，因为被抓概率累乘会变得更小，显然错误，应该是不被抓概率累乘变得更小。 思路：开始直接想到背包容量定为最大概率P，但是它是小数，想到P*100(or 1ek)转化为整数 结果WA； 于是转变思路，让背包容量等于所有银行价值之和，dp[i]-&gt;不被抓概率 //HDU-2995 小数/概率 背包 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=105; int w[maxn]; double v[maxn],dp[maxn*100]; int main() { ios::sync_with_stdio(0);cin.tie(0); int T;cin&gt;&gt;T; //int V=0 开始在这里定义 结果TLE 怎么又犯这种错误. while(T--){ int V=0; double P;int n;cin&gt;&gt;P&gt;&gt;n;P=1.0-P;//转为不被抓概率 for(int i=0;i&lt;n;i++){ cin&gt;&gt;w[i]&gt;&gt;v[i];v[i]=1.0-v[i];V+=w[i]; } for(int i=0;i&lt;n*100;i++) dp[i]=0;dp[0]=1; for(int i=0;i&lt;n;i++){ for(int j=V;j&gt;=w[i];j--){ dp[j]=max(dp[j],dp[j-w[i]]*v[i]); } } int ans=0; for(int i=V;i&gt;=0;i--){ if(dp[i]&gt;=P){ ans=i;break; } } cout&lt;&lt;ans&lt;&lt;endl; } } CF-366C 转化为01背包题意:有n个水果, 每个水果都有两个属性值ai表示美味程度, bi表示能量值, 现在要求选出一个或多个水果, 使得选出的水果的ai和与bi和的比例是k 问在这种情形可能出现的情况下ai的和最多是多少, 如果这样的情形不存在输出 -1 思路：每个物品的耗费是a[i]-k*b[i]的物品，这样就可以转化为01背包，求dp[i][0]，但是这样算耗值可能是负值，所以我们数组平移n*100个单位，就可以求出dp[n][m] 注意：此题不能用一个dp数组完成滚动，因为a[i]-k*b[i]可能为负值，转移可能来自上一层的左上方或右上方，若滚动会覆盖冲突。 //CF-366C 转化为01背包 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=105; const int INF=0x3f3f3f3f; int n,k; int a[maxn],b[maxn],dp[maxn][maxn*300]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;k; memset(dp,-INF,sizeof(dp));//无意义状态 dp[0][100*n]=0;//不选时合法 for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;b[i];b[i]=a[i]-k*b[i]; } for(int i=1;i&lt;=n;i++){ for(int j=b[i];j&lt;=200*n;j++){ dp[i][j]=max(dp[i-1][j],dp[i-1][j-b[i]]+a[i]); } } int ans=dp[n][100*n]; cout&lt;&lt;(ans?ans:-1)&lt;&lt;endl; } 完全背包完全背包与01背包唯一不同的是完全背包的每件物品可重复使用无数次。 状态转移： F[i,v] = max{F[i−1,v−kC[i]]+kW[i] | 0 ≤ kC[i]≤ v} 伪代码： F[0..V]←0 for i ← 1 to N for v ← C i to V F[v] ← max(F[v],F[v − C[i]] + W[i]) 有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。 第 i 种物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤1000 0&lt;vi,wi≤1000 样例 输入:4 5 输出：10 1 2 2 4 3 4 4 5 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; int v[maxn],w[maxn],dp[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int N,V;cin&gt;&gt;N&gt;&gt;V; for(int i=0;i&lt;N;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=0;i&lt;N;i++) dp[i]=0; for(int i=0;i&lt;N;i++) for(int j=v[i];j&lt;=V;j++)//注意循环方向 dp[j]=max(dp[j],dp[j-v[i]]+w[i]); cout&lt;&lt;dp[V]&lt;&lt;endl; } 多重背包(待补单调队列优化)多重背包中每个物品可使用的次数是有限制条件的，因此要假如第三重循环，限制选的次数。 注意：背包问题中第一重循环是物品种类 ，第二重是背包体积 ，第三重是限制条件 多重背包的优化： 二进制优化、单调队列优化 模版题： 有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 无优化 O(n*V*S)： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; int dp[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int N,V;cin&gt;&gt;N&gt;&gt;V; for(int i=0;i&lt;N;i++) dp[i]=0; for(int i=0;i&lt;N;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; for(int j=V;j&gt;=v;j--) for(int k=0;k&lt;=s&amp;&amp;k*v&lt;=j;k++) dp[j]=max(dp[j],dp[j-k*v]+k*w); } cout&lt;&lt;dp[V]&lt;&lt;endl; } 二进制优化 O(n*V*ΣS)： 数据范围：0&lt;N≤1000 0&lt;V≤2000 0&lt;vi,wi,si≤2000 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e3+5; int dp[maxn]; struct node{ int v,w; }; vector&lt;node&gt; goods; int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m;cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; for(int k=1;k&lt;=s;k*=2){ s-=k;goods.push_back({v*k,w*k}); } if(s) goods.push_back({v*s,w*s}); } for(auto good:goods) for(int j=m;j&gt;=good.v;j--) dp[j]=max(dp[j],dp[j-good.v]+good.w); cout&lt;&lt;dp[m]&lt;&lt;endl; } 单调队列优化 0(N*V): //未懂，待补+双端队列(滑动窗口) 数据范围：0&lt;N≤1000 0&lt;V≤20000 0&lt;vi,wi,si≤20000 双端队列思想优化背包问题-&gt; https://blog.csdn.net/hebtu666/article/details/83018230 首先优化思路来自最最原始的无优化的方程。 仔细观察，对于任意的j，都是从v[i]的倍数转移过来的。它们本来应该是连续的，可以用滑动窗口（不熟悉此问题的同学可以先行百度）解决。但在无优化的时候却每次把所有的倍数都遍历了一遍。 所以可以把m根据模v[i]的余数分为v[i]类。 for(int j=0;j&lt;v;j++) 此时对于任意的j，只需要向v[i]的倍数去转移。所以我们在下一层循环的时候把k定义为j+k*v[i] for(int k=j;k&lt;=m;k+=v) 此时的k相当于原来的j，但是我们可以利用k和v之间存在的倍数关系去做滑动窗口。 由于滑动窗口记录的是下标，但每一个k所对应的下标都是在变化的。所以要根据当前的k判断窗口里存在的k对应的值包含了多少个v，以便于计算新的价值 v的个数=(下标-余数)/v 价值=(下标-余数)/v*w =(q[h]-j)/v =(k-j)/v*w 然后每次只用了前i-1的值，所以可以滚动数组优化一下空间 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e4+5; int n,m,dp[maxn],q[maxn],g[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; memcpy(g,dp,sizeof(dp));//滚动数组优化空间，g[]即dp[i-1][]; for(int j=0;j&lt;v;j++){ int h=0,t=-1; for(int k=j;k&lt;=m;k+=v){ dp[k]=g[k]; if(h&lt;t&amp;&amp;k-s*v&gt;q[h]) h++;//如果当前窗口的内容超过了s个; if(h&lt;=t) dp[k]=max(dp[k],g[q[h]]+(k-q[h])/v*w);//max(f[i-1][k],f[i-1][能转移里最大]+个数*v[i]); while(h&lt;=t&amp;&amp;g[q[t]]-(q[t]-j)/v*w&lt;=g[k]-(k-j)/v*w) t--; q[++t]=k; } } } cout&lt;&lt;dp[m]&lt;&lt;endl; } 混合背包混合背包就是把以上三种背包问题混合在一起，什么物品可以选几次有响应的限制条件，根据条件选择不同的dp方程即可 模版题： 有 N 种物品和一个容量是 V 的背包。物品一共有三类： * 第一类物品只能用1次（01背包）； * 第二类物品可以用无限次（完全背包）； * 第三类物品最多只能用 si 次（多重背包）； 每种体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式： 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 si=−1 表示第 i 种物品只能用1次； si=0 表示第 i 种物品可以用无限次； si&gt;0 表示第 i 种物品可以使用 si 次； 输出格式： 输出一个整数，表示最大价值。 数据范围：0&lt;N,V≤1000 ，0&lt;vi,wi≤1000 ，−1≤si≤1000 输入样例： 输出样例： 4 5 8 1 2 -1 2 4 1 3 4 0 4 5 2 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e3+5; int dp[maxn]; struct node{ int v,w,s; }; int n,V; vector&lt;node&gt; G; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=0;i&lt;n;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; if(s==-1) G.push_back({v,w,-1}); else if(s==0) G.push_back({v,w,0}); else{ for(int k=1;k&lt;=s;k*=2){ G.push_back({v*k,w*k,-1});s-=k; } if(s) G.push_back({v*s,w*s,-1}); } } for(auto g:G){ if(g.s==-1) for(int j=V;j&gt;=g.v;j--) dp[j]=max(dp[j],dp[j-g.v]+g.w); else if(g.s==0) for(int j=g.v;j&lt;=V;j++) dp[j]=max(dp[j],dp[j-g.v]+g.w); } cout&lt;&lt;dp[V]&lt;&lt;endl; } 二维费用背包二维费用背包就是加了重限制条件，物品的总体积与物品的总重量都不能超过背包可承受范围。 有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。 每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。 输出最大价值。 输入格式： 第一行两个整数，N，V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。 接下来有 N 行，每行三个整数 vi,mi,wi，用空格隔开，分别表示第 i 件物品的体积、重量和价值。 输出格式： 输出一个整数，表示最大价值。 数据范围： 0&lt;N≤1000 ，0&lt;V,M≤100 ，0&lt;vi,mi≤100 ，0&lt;wi≤1000 输入样例： 输出样例： 4 5 6 8 1 2 3 2 4 4 3 4 5 4 5 6 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e3+5; int n,V,M; int v[maxn],m[maxn],w[maxn]; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V&gt;&gt;M; for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i]&gt;&gt;m[i]&gt;&gt;w[i]; for(int i=0;i&lt;n;i++) for(int j=V;j&gt;=v[i];j--) for(int k=M;k&gt;=m[i];k--) dp[j][k]=max(dp[j][k],dp[j-v[i]][k-m[i]]+w[i]); cout&lt;&lt;dp[V][M]&lt;&lt;endl; } 分组背包分组背包就是把物品分为很多组，限定每组最多可选的个数 有 N 组物品和一个容量是 V 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。 每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。 接下来有 N 组数据： 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量； 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值； 输出格式 输出一个整数，表示最大价值。 数据范围：0&lt;N,V≤100，0&lt;Si≤100，0&lt;vij,wij≤100 输入样例： 输出样例： 3 5 8 2 1 2 2 4 1 3 4 1 4 5 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e2+5; int n,V; int v[maxn],w[maxn];//体积和价值 int dp[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=0;i&lt;n;i++){ int s;cin&gt;&gt;s; for(int j=1;j&lt;=s;j++) cin&gt;&gt;v[j]&gt;&gt;w[j]; for(int j=V;j&gt;=0;j--) for(int k=1;k&lt;=s;k++)每组选一个使价值最大化 if(j&gt;=v[k]) dp[j]=max(dp[j],dp[j-v[k]]+w[k]); } cout&lt;&lt;dp[V]&lt;&lt;endl; } 有依赖的背包问题(待补) 有 N 个物品和一个容量是 V 的背包。 物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。 如上图所示： 如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。 每件物品的编号是 i，体积是 vi，价值是 wi，依赖的父节点编号是 pi。物品的下标范围是 1…N。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式： 第一行有两个整数 N，V，用空格隔开，分别表示物品个数和背包容量。 接下来有 N 行数据，每行数据表示一个物品。 第 i 行有三个整数 vi,wi,pi，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。 如果 pi=−1，表示根节点。 数据保证所有物品构成一棵树。 输出格式： 输出一个整数，表示最大价值。 数据范围：1≤N,V≤100，1≤vi,wi≤100 父节点编号范围： 内部结点：1≤pi≤N; 根节点 pi=−1; 输入样例 输出样例： 5 7 11 2 3 -1 2 2 1 3 5 1 4 7 2 3 6 2 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int h[N], e[N], ne[N], idx; int v[N], w[N]; int f[N][N]; void add(int x, int y) { e[idx] = y, ne[idx] = h[x], h[x] = idx++; } void dfs(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int y = e[i]; dfs(y); for (int j = m - v[x]; j &gt;= 0; j--) { for (int k = 0; k &lt;= j; k++) { f[x][j] = max(f[x][j], f[x][j - k] + f[y][k]); } } } for (int i = m; i &gt;= v[x]; i--) { f[x][i] = f[x][i - v[x]] + w[x]; } for (int i = 0; i &lt; v[x]; i++) { f[x][i] = 0; } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int root; for (int i = 1; i &lt;= n; i++) { int p; cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p; if (p == -1) { root = i; } else { add(p, i); } } dfs(root); cout &lt;&lt; f[root][m] &lt;&lt; endl; return 0; } 背包问题求方案数有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 1e9+7 的结果。 输入格式: 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式: 输出一个整数，表示 方案数 模 109+7 的结果。 数据范围: 0&lt;N,V≤1000, 0&lt;vi,wi≤1000 输入样例: 输出样例: 4 5 2 1 2 2 4 3 4 4 6 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; const ll mod=1e9+7; int n,V; int v[maxn],w[maxn]; int dp[maxn]; ll num[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=0;i&lt;=V;i++) num[i]=1; for(int i=1;i&lt;=n;i++){ for(int j=V;j&gt;=v[i];j--){ if(dp[j]&lt;dp[j-v[i]]+w[i]){ dp[j]=dp[j-v[i]]+w[i]; num[j]=num[j-v[i]]%mod; } else if(dp[j]==dp[j-v[i]]+w[i]){ num[j]=(num[j-v[i]]+num[j])%mod; } } } cout&lt;&lt;num[V]&lt;&lt;endl; } 背包问题求具有方案有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 1e9+7 的结果。 输入格式: 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式: 输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。 物品编号范围是 1…N 数据范围: 0&lt;N,V≤1000, 0&lt;vi,wi≤1000 输入样例: 输出样例: 4 5 1 4 1 2 2 4 3 4 4 6 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; const ll mod=1e9+7; int n,V; int v[maxn],w[maxn]; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=n;i&gt;=1;i--) for(int j=0;j&lt;=V;j++){//这样写dp方程是因为dp[i][j]的意义与之前的不同 //dp[i][j] -&gt;从前i件物品中选，使得背包容量大于j的 方案的价值 if(j&gt;=v[i]) dp[i][j]=max(dp[i+1][j],dp[i+1][j-v[i]]+w[i]); else dp[i][j]=dp[i+1][j]; } for(int i=1;i&lt;=n;i++){ if(i==n&amp;&amp;V&gt;=v[i]){ cout&lt;&lt;i&lt;&lt;&quot; &quot;;break; } if(V-v[i]&gt;=0&amp;&amp;dp[i][V]==dp[i+1][V-v[i]]+w[i]){ cout&lt;&lt;i&lt;&lt;&quot; &quot;;V-=v[i]; } if(V&lt;0) break; } }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCA]]></title>
    <url>%2F2019%2F07%2F17%2FLCA%2F</url>
    <content type="text"><![CDATA[LCA解决树上两点间的最近公共祖先，三种方式： 1.Tarjan 离线算法 O(n+q) 2.倍增 在线算法 O((n+q)*logn) 3.RMQ(ST表) 优秀的在线算法 O(nlogn+q) TarjanTarjan 算法求 LCA 的时间复杂度为 O(n+q) ，是一种离线算法，要用到并查集。（注：这里的复杂度其实应该不是 O(n+q) ，还需要考虑并查集操作的复杂度 ，但是由于在多数情况下，路径压缩并查集的单次操作复杂度可以看做 O(1)，所以写成了 O(n+q) 。） Tarjan 算法基于 dfs ，在 dfs 的过程中，对于每个节点位置的询问做出相应的回答。 dfs 的过程中，当一棵子树被搜索完成之后，就把他和他的父亲合并成同一集合；在搜索当前子树节点的询问时，如果该询问的另一个节点已经被访问过， 那么该编号的询问是被标记了的，于是直接输出当前状态下，另一个节点所在的并查集的祖先；如果另一个节点还没有被访问过，那么就做下标记，继续 dfs 。 板子1(NBWY)//离线Tarjan O(n+q) from NBWY //POJ-1470 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; const int maxn=905; vector&lt;int&gt; G[maxn],query[maxn]; int ans[maxn],fa[maxn]; bool vis[maxn],in[maxn]; int n,m; void init(){ for(int i=1;i&lt;=n;i++){ G[i].clear();query[i].clear(); fa[i]=i;in[i]=0;ans[i]=0;vis[i]=0; } } int find(int x){return fa[x]==x?x:find(fa[x]);} void add_edge(int u,int v){G[u].push_back(v);} void add_query(int u,int v){query[u].push_back(v);} void Tarjan(int u){ vis[u]=1; int size=query[u].size(); for(int i=0;i&lt;size;i++){ int v=query[u][i]; if(vis[v]) ans[find(v)]++; } size=G[u].size(); for(int i=0;i&lt;size;i++){ int v=G[u][i]; if(!vis[v]){ Tarjan(v);fa[v]=u; } } } int main() { while(~scanf(&quot;%d&quot;,&amp;n)){ init(); int u,v; for(int i=0;i&lt;n;i++){ scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;m); while(m--){ scanf(&quot;%d&quot;,&amp;v);in[v]=1; add_edge(u,v);add_edge(v,u); } } scanf(&quot;%d&quot;,&amp;m); while(m--){ scanf(&quot; (%d %d)&quot;,&amp;u,&amp;v); add_query(u,v);add_query(v,u); } for(int i=1;i&lt;=n;i++) if(!in[i]){ Tarjan(i);break; } for(int i=1;i&lt;=n;i++) if(ans[i]) printf(&quot;%d:%d\n&quot;,i,ans[i]); } } 板子2(Kuangbin)/* POJ 1470 离线处理 G++ 1204ms 8788K C++ 954ms 8304K */ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;math.h&gt; #include&lt;vector&gt; using namespace std; const int MAXN=1000; const int MAXM=500000;//最大查询数 int F[MAXN];//并查集 int r[MAXN];//并查集中集合的个数 bool vis[MAXN];//访问标记 int ancestor[MAXN];//祖先 struct Node { int to,next; }edge[MAXN*2]; int head[MAXN]; int tol; void addedge(int a,int b) { edge[tol].to=b; edge[tol].next=head[a]; head[a]=tol++; edge[tol].to=a; edge[tol].next=head[b]; head[b]=tol++; } struct Query { int q,next; int index;//查询编号 }query[MAXM*2];//查询数 int answer[MAXM];//查询结果 int cnt; int h[MAXM]; int tt; int Q;//查询个数 void add_query(int a,int b,int i) { query[tt].q=b; query[tt].next=h[a]; query[tt].index=i; h[a]=tt++; query[tt].q=a; query[tt].next=h[b]; query[tt].index=i; h[b]=tt++; } void init(int n) { for(int i=1;i&lt;=n;i++) { F[i]=-1; r[i]=1; vis[i]=false; ancestor[i]=0; tol=0; tt=0; cnt=0;//已经查询到的个数 } memset(head,-1,sizeof(head)); memset(h,-1,sizeof(h)); } int find(int x) { if(F[x]==-1)return x; return F[x]=find(F[x]); } void Union(int x,int y)//合并 { int t1=find(x); int t2=find(y); if(t1!=t2) { if(r[t1]&lt;=r[t2]) { F[t1]=t2; r[t2]+=r[t1]; } else { F[t2]=t1; r[t1]+=r[t2]; } } } void LCA(int u) { // if(cnt&gt;=Q)return;//这个不能加，加了就WR了 ancestor[u]=u; vis[u]=true;//这个一定要放在前面 for(int i=head[u];i!=-1;i=edge[i].next) { int v=edge[i].to; if(vis[v])continue; LCA(v); Union(u,v); ancestor[find(u)]=u; } for(int i=h[u];i!=-1;i=query[i].next) { int v=query[i].q; if(vis[v]) { answer[query[i].index]=ancestor[find(v)]; cnt++;//已经找到的答案数 } } } int Count_num[MAXN]; bool flag[MAXN]; int main() { // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int N; int u,v,m; char ch; while(scanf(&quot;%d&quot;,&amp;N)!=EOF) { init(N); memset(flag,false,sizeof(flag)); for(int i=1;i&lt;=N;i++) { scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;m); while(m--) { scanf(&quot;%d&quot;,&amp;v); flag[v]=true; addedge(u,v); } } scanf(&quot;%d&quot;,&amp;Q); for(int i=0;i&lt;Q;i++) { cin&gt;&gt;ch; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); cin&gt;&gt;ch; add_query(u,v,i); } int root; for(int i=1;i&lt;=N;i++) if(!flag[i]) { root=i; break; } LCA(root); memset(Count_num,0,sizeof(Count_num)); for(int i=0;i&lt;Q;i++) Count_num[answer[i]]++; for(int i=1;i&lt;=N;i++) if(Count_num[i]&gt;0) printf(&quot;%d:%d\n&quot;,i,Count_num[i]); } return 0; } 倍增我们可以用倍增来在线求 LCA ，时间和空间复杂度分别是 O((n+q)logn) 和 O(nlogn) 。 对于这个算法，我们从最暴力的算法开始： 1.如果 a 和 b 深度不同，先把深度调浅，使他变得和浅的那个一样 2.现在已经保证了 a 和 b 的深度一样，所以我们只要把两个一起一步一步往上移动，直到他们到达同一个节点，也就是他们的最近公共祖先了。 板子1(zhouzhendong)//在线倍增 O((n+q)logn) #include&lt;bits/stdc++.h&gt; using namespace std; const int N=10000+5; vector &lt;int&gt; son[N]; int T,n,depth[N],fa[N][20],in[N],a,b; void dfs(int prev,int rt){ depth[rt]=depth[prev]+1; fa[rt][0]=prev; for (int i=1;i&lt;20;i++) fa[rt][i]=fa[fa[rt][i-1]][i-1]; for (int i=0;i&lt;son[rt].size();i++) dfs(rt,son[rt][i]); } int LCA(int x,int y){ if (depth[x]&lt;depth[y]) swap(x,y); for (int i=19;i&gt;=0;i--) if (depth[x]-(1&lt;&lt;i)&gt;=depth[y]) x=fa[x][i]; if (x==y) return x; for (int i=19;i&gt;=0;i--) if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; } int main(){ scanf(&quot;%d&quot;,&amp;T); while (T--){ scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) son[i].clear(); memset(in,0,sizeof in); for (int i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;a,&amp;b); son[a].push_back(b); in[b]++; } depth[0]=-1; int rt=0; for (int i=1;i&lt;=n&amp;&amp;rt==0;i++) if (in[i]==0) rt=i; dfs(0,rt); scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\n&quot;,LCA(a,b)); } return 0; } 板子2(Kuangbin)//倍增(Kuangbin) POJ1330 #include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1e4+5; const int h=20; struct Edge{int to,nxt;}edge[maxn*2]; int head[maxn],tot; void add_edge(int u,int v){edge[tot].to=v;edge[tot].nxt=head[u];head[u]=tot++;} void init(){tot=0;mem(head,-1);} int fa[maxn][h];//fa[i][j]表示结点i的第2^j个祖先 int depth[maxn];//深度数组 void bfs(int r){ queue&lt;int&gt; que;depth[r]=0; fa[r][0]=r;que.push(r); while(!que.empty()){ int tmp=que.front();que.pop(); for(int i=1;i&lt;h;i++) fa[tmp][i]=fa[fa[tmp][i-1]][i-1]; for(int i=head[tmp];i!=-1;i=edge[i].nxt){ int v=edge[i].to;if(v==fa[tmp][0]) continue; depth[v]=depth[tmp]+1;fa[v][0]=tmp; que.push(v); } } } int LCA(int u,int v){ if(depth[u]&gt;depth[v]) swap(u,v); int hu=depth[u],hv=depth[v]; int tu=u,tv=v; for(int det=hv-hu,i=0;det;det&gt;&gt;=1,i++) if(det&amp;1) tv=fa[tv][i]; if(tu==tv) return tu; for(int i=h-1;i&gt;=0;i--){ if(fa[tu][i]==fa[tv][i]) continue; tu=fa[tu][i];tv=fa[tv][i]; } return fa[tu][0]; } bool flag[maxn]; int main() { int T,n,u,v;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;n);init();mem(flag,0); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v);add_edge(u,v);add_edge(v,u);flag[v]=1; } int root; for(int i=1;i&lt;=n;i++) if(!flag[i]){root=i;break;} bfs(root); scanf(&quot;%d%d&quot;,&amp;u,&amp;v); printf(&quot;%d\n&quot;,LCA(u,v)); } } RMQ(ST)一种O(nlogn)预处理+O(1)查询的在线算法(优秀) 一个子树中深度最浅的节点必定是该子树的树根。两个节点的 LCA 不仅是两个节点的最近公共祖先， 而且是囊括这两个节点的最小子树的根，即囊括这两个节点的最小子树中的深度最小的节点 如何得到这个子树根节点呢？ 现在，我们稍微修改一下 dfs 序，搞一个欧拉序。 欧拉序，就是每次从 father(x) 进入节点 x 或者从子节点回溯到 x 都要把 x 这个编号扔到一个数组的最后。 这样最终会得到一个长度约为 2n 的数列。（考虑每一个节点贡献为 2 ，分别是从其父亲进入该节点，和从该节点回到其父亲） 下图这棵树的一个欧拉序为 8,5,9,5,8,4,6,15,6,7,6,4,10,11,10,16,3,16,12,16,10,2,10,4,8,1,14,1,13,1,8 再注意到，一对点的 LCA 不仅是囊括这两个节点的最小子树中的深度最小的节点，还是连接这对点的简单路径上深度最小的点。 而且从离开 a 到进入 b 的这段欧拉序必然包括所有这对点之间的简单路径上的所有点，所以我们考虑求得这段欧拉序中所包含的节点中的 深度最小的点即其 LCA 。 从 a 到 b 的这段欧拉序会包含这棵子树中的其他节点，但是不会影响这个最浅点的求得，因为“一对点的 LCA 是囊括这两个节点的最小子树中的深度最小的节点”。 显然， a 到 b 这段欧拉序是个连续区间。 你可以用线段树维护，但是线段树太 low 了。 现在我们考虑通过预处理来 O(1) 获得这个最浅点。 于是我们要学习一个叫做 ST表 的东西来搞定这个。（和之前倍增中处理的 fa 数组差不多） 板子1(Vector from CSL)//RMQ O(nlogn+q) CSL #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e4+5; vector&lt;int&gt; edge[maxn],sp; int dep[maxn],dfn[maxn]; pair&lt;int,int&gt; dp[21][maxn&lt;&lt;1]; void init(int n){ for(int i=0;i&lt;=n;i++) edge[i].clear(); sp.clear(); } void dfs(int u,int fa){ dep[u]=dep[fa]+1; dfn[u]=sp.size();//欧拉序列 sp.push_back(u); for(auto&amp; v:edge[u]){ if(v==fa) continue; dfs(v,u);sp.push_back(u); } } void initrmq(){ int n=sp.size(); for(int i=0;i&lt;n;i++) dp[0][i]={dfn[sp[i]],sp[i]}; for(int i=1;(1&lt;&lt;i)&lt;=n;i++)//注意从1开始 ST表维护最小时间戳 for(int j=0;j+(1&lt;&lt;i)-1&lt;n;j++) dp[i][j]=min(dp[i-1][j],dp[i-1][j+(1&lt;&lt;(i-1))]); } int lca(int u,int v){ int l=dfn[u],r=dfn[v]; if(l&gt;r) swap(l,r); int k=31-__builtin_clz(r-l+1); return min(dp[k][l],dp[k][r-(1&lt;&lt;k)+1]).second; } int main() { /* */ } 验板子(HDU - 2586 Vector)//RMQ O(nlogn+q) CSL #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=5e4+5; struct Edge{ int to,w; Edge(int t,int W):to(t),w(W){} }; vector&lt;Edge&gt; edge[maxn]; vector&lt;int&gt; sp; int dep[maxn],dfn[maxn]; pair&lt;int,int&gt; dp[21][maxn&lt;&lt;1]; int dist[maxn]; void init(int n){ for(int i=0;i&lt;=n;i++) {edge[i].clear();dep[i]=dist[i]=0;} sp.clear(); } void dfs(int u,int fa){ dep[u]=dep[fa]+1; dfn[u]=sp.size(); sp.push_back(u); for(auto&amp; v:edge[u]){ if(v.to==fa) continue; dist[v.to]=dist[u]+v.w; dfs(v.to,u);sp.push_back(u); } } void initrmq(){ int n=sp.size(); for(int i=0;i&lt;n;i++) dp[0][i]={dfn[sp[i]],sp[i]}; for(int i=1;(1&lt;&lt;i)&lt;=n;i++) for(int j=0;j+(1&lt;&lt;i)-1&lt;n;j++) dp[i][j]=min(dp[i-1][j],dp[i-1][j+(1&lt;&lt;(i-1))]); } int lca(int u,int v){ int l=dfn[u],r=dfn[v]; if(l&gt;r) swap(l,r); int k=31-__builtin_clz(r-l+1); return min(dp[k][l],dp[k][r-(1&lt;&lt;k)+1]).second; } int main() { int T;scanf(&quot;%d&quot;,&amp;T); int u,v,w; while(T--){ int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(n); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); edge[u].push_back(Edge(v,w)); edge[v].push_back(Edge(u,w)); } dfs(1,0);initrmq(); while(m--){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v); printf(&quot;%d\n&quot;,dist[u]+dist[v]-2*dist[lca(u,v)]); } } } 验板子(HDU - 2586 前向星)#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e4+5; struct Edge{ int to,w,nxt; }edge[maxn&lt;&lt;1]; int tot,head[maxn]; vector&lt;int&gt; sp; int dep[maxn],dfn[maxn]; pair&lt;int,int&gt; dp[21][maxn&lt;&lt;1]; int dist[maxn]; void Addedge(int u,int v,int w){ edge[tot].to=v;edge[tot].w=w;edge[tot].nxt=head[u];head[u]=tot++; } void init(int n){ for(int i=0;i&lt;=n;i++) {head[i]=-1;dep[i]=dist[i]=0;} sp.clear();tot=0; } void dfs(int u,int fa){ dep[u]=dep[fa]+1; dfn[u]=sp.size(); sp.push_back(u); for(int i=head[u];i!=-1;i=edge[i].nxt){ int v=edge[i].to; if(v==fa) continue; dist[v]=dist[u]+edge[i].w; dfs(v,u);sp.push_back(u); } } void initrmq(){ int n=sp.size(); for(int i=0;i&lt;n;i++) dp[0][i]={dfn[sp[i]],sp[i]}; for(int i=1;(1&lt;&lt;i)&lt;=n;i++) for(int j=0;j+(1&lt;&lt;i)-1&lt;n;j++) dp[i][j]=min(dp[i-1][j],dp[i-1][j+(1&lt;&lt;(i-1))]); } int lca(int u,int v){ int l=dfn[u],r=dfn[v]; if(l&gt;r) swap(l,r); int k=31-__builtin_clz(r-l+1); return min(dp[k][l],dp[k][r-(1&lt;&lt;k)+1]).second; } int main() { int T;scanf(&quot;%d&quot;,&amp;T); int u,v,w; while(T--){ int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(n); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); Addedge(u,v,w);Addedge(v,u,w); } dfs(1,0);initrmq(); while(m--){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v); printf(&quot;%d\n&quot;,dist[u]+dist[v]-2*dist[lca(u,v)]); } } } 题目总结LCA题目总结 好像LCA的题目并不多，现在就做了10道左右，但是找不到别的了，在此做个小总结，将来有更好的题目会不断更新 解决LCA问题，一般用3种方法 1.朴素方法：两个点都一直沿路径往上走，直到有某一个节点被经过两次并且是第一次出现这样的点，那么这个就是LCA 此方法最好理解，但是用得不多，但不代表没作用，有些题目还是需要用到的 2.LCA转RMQ（在线算法）：一般是将LCA转为RMQ问题，用ST算法求解，当然求解RMQ问题有很多方法，不过ST比较常用而已，这样做能及时回答每一个询问 3.Tarjan算法（离线算法）：利用Tarjan算法，不过要先读入所有询问再一并回答，建议认真学习Tarjan算法本质 ******具体问题具体分析，但是可以使用Tarjan算法的时候推荐使用Tarjan算法，代码量少速度快，另外Tarjan算法容易产生变形，值得深究************* 待补题poj 1986 Distance Queries 模板题，直接求LCA hdu 2874 Connections between cities 模板题，不过不是树是森林，所以某些点不存在LCA，要做判断 zoj 3195 Design the city 任然算是模板题，上面的题要求两点间的最短距离，这里要求3点间的最短距离，其实就是两两之间求一次LCA并计算出距离，然后相加除以2即可 hdu 3078 Network LCA + 修改点权值 + 排序：每个点有初始的权值，一边查询一边伴随着修改某些点的权值，查询是从a到b路径中第k大的权值是多少。不需要太多的技巧，修改操作就直接修改，查询操作先求LCA，然后从a走到b保存下所有的权值，排序，然后直接输出即可 poj 2763 Housewife Wind LCA + 修改边权：一边查询两点间的距离，一边修改某些边权。对于修改了某些边的边权，就要从此开始遍历下面的子孙后代更改他们的dir值（点到根的距离）。也不需要太多技巧，直接按题意实现即可，不过时间比较糟糕，用线段树或树状数组可以对修改操作进行优化，时间提升很多 poj 3694 Network 连通分量 + LCA ： 先缩点，再求LCA，并且不断更新，这题用了朴素方法来找LCA，并且在路径上做了一些操作 poj 3417 Network LCA + Tree DP : 在运行Tarjan处理完所有的LCA询问后，进行一次树DP，树DP不难，但是要想到用树DP并和这题结合还是有点难度 poj 3728 The merchant LCA + 并查集的变形，优化：好题，难题，思维和代码实现都很有难度，需要很好地理解Tarjan算法中并查集的本质然后灵活变形，需要记录很多信息（有点dp的感觉） hdu 3830 Checkers LCA + 二分：好题，有一定思维难度。先建立出二叉树模型，然后将要查询的两个点调整到深度一致，然后二分LCA所在的深度，然后检验]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)为什么printf()用%f输出double型，而scanf却用%lf]]></title>
    <url>%2F2019%2F07%2F16%2Fprintf%2F</url>
    <content type="text"><![CDATA[问：有人告诉我不能在printf中使用%lf。为什么printf()用%f输出double型，而scanf却用%lf呢？ 答：printf的%f说明符的确既可以输出float型又可以输出double型。 根据”默认参数提升”规则（在printf这样的函数的可变参数列表中 ，不论作用域内有没有原型，都适用这一规则）float型会被提升为double型。因此printf()只会看到双精度数。参见问题15.2。 对于scanf，情况就完全不同了，它接受指针，这里没有类似的类型提升。（通过指针）向float存储和向double存储大不一样，因此，scanf区别%f和%lf。 下表列出了printf和scanf对于各种格式说明符可以接受的参数类型。 （严格地讲，%lf在printf下是未定义的，但是很多系统可能会接受它。要确保可移植性，就要坚持使用%f。）]]></content>
  </entry>
  <entry>
    <title><![CDATA[最小树形图]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最小树形图简单来说，最小树形图就是有向图的最小生成树 给出一个带权有向图，从中指定一个特殊的节点root，求一棵以root为根的有向生成树，且使得T中所有边权之和最小 朱刘算法 O(VE) 网上讲解无证明，了解过程 - 会套模版 - 分清有定根与无定根 - 重在建图 在选出入边集后，若有向图中不存在有向环，则说明该图是最小树形图 1）选入边集，找到除 root 点之外，每一个点的所有入边中权值最小的权值，用数组 in[] 记录这个最小权值，用 pre[] 记录到达该点的前驱。 2）判断图中是否存在独立点，若存在除 root 外的孤立点，则说明 root 无法到达该点，说明最小树形图不存在。 3）在图中寻找环，对环进行缩点并用数组 id[] 记录节点所属环的编号。 4）更新其他点到环上的距离。 5）重复 3、4 直到 图中不存在环 为止，此时图是最小树形图。 模版（NB网友）#include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=4e4+5; const int INF=0x3f3f3f3f; struct Edge{ int x,y,w; }edge[maxm]; int vis[maxn]; int id[maxn];//结点所属环编号 int in[maxn],pre[maxn];//in[]为最小入边权,pre[]为其对应的起点 int zhuLiu(int root,int n,int m){//root结点、点数、边数 int res=0;//最小树形图总权值 while(true){ for(int i=0;i&lt;n;i++)//初始化为无穷大 in[i]=INF; //寻找每个点的最小入边 for(int i=0;i&lt;m;i++){//遍历每条边 int x=edge[i].x; int y=edge[i].y; if(edge[i].w&lt;in[y] &amp;&amp; x!=y){//更新最小入边 pre[y]=x;//记录前驱 in[y]=edge[i].w;//更新 } } //判断是否存在最小树形图 for(int i=0;i&lt;n;i++){ if(i==root) continue; if(in[i]==INF)//除根节点外的点存在孤立点 return -1; } //寻找所有的环 int cnt=0;//记录环数 in[root]=0; memset(id,-1,sizeof(id)); memset(vis,-1,sizeof(vis)); for(int i=0;i&lt;n;i++){//标记每个环 res+=in[i];//记录权值 int y=i; while(vis[y]!=i&amp;&amp;id[y]==-1&amp;&amp;y!=root){//寻找图中有向环 //三种情况会终止：找到出现同样标记的点、结点已属其他环、遍历到根 vis[y]=i;//标记 y=pre[y];//向上找 } if(y!=root&amp;&amp;id[y]==-1){//没有遍历到根或没有找到结点属于其他环,说明找到有向环 for(int x=pre[y];x!=y;x=pre[x])//标记结点x为第几个环 id[x]=cnt;//记录结点所属环号 id[y]=cnt++;//记录结点所属环号并累加 } } if(cnt==0)//无环 break; for(int i=0;i&lt;n;i++)//可能存在独立点 if(id[i]==-1)//环数累加 id[i]=cnt++; //建立新图,缩点重新标记 for(int i=0;i&lt;m;i++){ int x=edge[i].x; int y=edge[i].y; edge[i].x=id[x]; edge[i].y=id[y]; if(id[x]!=id[y])//两点不在同一环内,更新边权值 edge[i].w-=in[y];//x到y的距离为边权-in[y] } V=cnt;//以环数为下次操作的点数,继续上述操作,直到无环 root=id[root]; } return res; } int main(){ int n,m;//n个点m条有向边 scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++){//建图 scanf(&quot;%d%d%d&quot;,&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].w); if(edge[i].x==edge[i].y)//除去自环,即点到自身距离为INF edge[i].w=INF; } int res=zhuLiu(0,n,m); if(res==-1) printf(&quot;No\n&quot;); else printf(&quot;%d\n&quot;,res); return 0; } 模版（邝斌）#include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=4e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; }edge[maxm]; int pre[maxn],id[maxn],vis[maxn],in[maxn]; int zhuliu(int root,int n,int m,Edge edge[]){ int res=0,u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++) if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u; in[edge[i].v]=edge[i].cost; } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int tn=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=tn; id[v]=tn++; } } if(tn==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=tn++; for(int i=0;i&lt;m;){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i++].cost-=in[v]; else swap(edge[i],edge[--m]); } n=tn;root=id[root]; } return res; } int g[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m,ca=0,T;cin&gt;&gt;T; while(T--){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) g[i][j]=INF; int u,v,cost; while(m--){ int u,v,cost;cin&gt;&gt;u&gt;&gt;v&gt;&gt;cost; if(u==v) continue; g[u][v]=min(g[u][v],cost); } int L=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(g[i][j]&lt;INF){ edge[L].u=i;edge[L].v=j;edge[L++].cost=g[i][j]; } int ans=zhuliu(0,n,L,edge); cout&lt;&lt;&quot;Case #&quot;&lt;&lt;ca++&lt;&lt;&quot;: &quot;; if(ans==-1) cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; } } 题目有定根//POJ-3164 有定根的最小树形图 题意：给出 n 个点 m 条有向边，首先给出从 1 号点到 n 号点的笛卡尔坐标，然后再给出 m 条边，1 号点始终为根节点，求最小树形图 思路：朱刘算法第一题。。。边的权值用 double 型，求一下距离直接建图后，然后套模版。。。注意模版需要改为 double 型 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=105; const int maxm=1e4+5; const double INF=0x3f3f3f3f; struct Node{ double x,y; }node[maxn]; struct Edge{ int u,v;double cost; }edge[maxm]; double cal(Node a,Node b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } int pre[maxn],id[maxn],vis[maxn]; double in[maxn]; double zhuliu(int root,int n,int m){ double res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ u=edge[i].u;v=edge[i].v; if(u!=v&amp;&amp;edge[i].cost&lt;in[v]){ pre[v]=u;in[v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int main() { int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;(n+m)){ for(int i=0;i&lt;n;i++) scanf(&quot;%lf%lf&quot;,&amp;node[i].x,&amp;node[i].y); for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v); edge[i].u--;edge[i].v--; if(edge[i].u!=edge[i].v) edge[i].cost=cal(node[edge[i].u],node[edge[i].v]); else edge[i].cost=INF; } double ans=zhuliu(0,n,m); if(ans==-1) printf(&quot;poor snoopy\n&quot;); else printf(&quot;%.2f\n&quot;,ans); } } 无定根//HDU-2121 图不需要自己额外建(即题目给好了N个点,M条边),只是没有给定根 题意：n 个点 m 条有向边，现要在 n 个点中选一个点作为首都，要求首都与其他点是可达的， 给出 m 条道路修建要花费的价格，求最小花费并给出首都的序号，点的标号从 0 开始。 无根最小树形图，构造根节点0，从0到各点建立权值大于整张图权值和的边（此处取sum+1）， 这样一来0为根节点求最小树形图，如果不存在最小树形图或者所得最小树形图的权值和不小于2*(sum+1) 说明原图的最小树形图不存在，至于如何求编号最小的根节点，这个可以在求最短弧集合的时候得到， 即如果一条边被加入最短弧集合且这条边的起点是0，那么这条边的终点就是所求最小树形图的根 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; }edge[maxm+maxn]; int pos;//实际起点 int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; if(edge[i].u==root) pos=i; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; //else swap(edge[i],edge[--m]); } n=cnt;root=id[root]; } return res; } int main() { int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ int sum=0; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].cost); edge[i].u++;edge[i].v++;sum+=edge[i].cost; } sum++;//去掉就WA for(int i=0;i&lt;n;i++){ edge[i+m].u=0;edge[i+m].v=i+1;edge[i+m].cost=sum; } int ans=zhuliu(0,n+1,m+n); ////若差值大于sum说明结点0的出度不止为1,即原图不是连通图 if(ans==-1||ans-sum&gt;=sum) printf(&quot;impossible\n&quot;); else printf(&quot;%d %d\n&quot;,ans-sum,pos-m); printf(&quot;\n&quot;); } } 建图+无定根//HDU-4009 图需要自己建,同时也没有给定根 题意：n户人家，每家对应一个三维坐标(x, y, z)，z代表这家的海拔高度。 每家可以通过挖井获得水，也可以通过从别的人家引一条水渠获得水，其花费如下： 1.挖井花费z*X； 2.从不比自己低的人家引水渠花费Y*两家之间的曼哈顿距离； 3.从比自己低的人家引水渠与2中的相同，但需要多花Z来购买一个水泵 此外有的人家不允许一些人家从他们家引水渠，求使得所有人家都能获得水的最少花费 思路：对应这个题,其初始点就可以设为这n个点,然后权值为在这个点建井的花费,而对于它给的其他边,我们直接在对应的两个点上建边即可,然后跑一下朱刘算法,就可得出答案 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Node{ int x,y,z; }node[maxn]; struct Edge{ int u,v,cost; }edge[maxm+maxn*maxn]; int dis(Node a,Node b){ return abs(a.x-b.x)+abs(a.y-b.y)+abs(a.z-b.z); } int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int main() { int n,X,Y,Z; while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;X,&amp;Y,&amp;Z)&amp;&amp;(n+X+Y+Z)){ for(int i=0;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;node[i].x,&amp;node[i].y,&amp;node[i].z); } int cnt=0,a,b; for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a); while(a--){ scanf(&quot;%d&quot;,&amp;b); edge[cnt].cost=dis(node[i],node[--b])*Y; if(node[b].z&gt;node[i].z) edge[cnt].cost+=Z; edge[cnt].u=i;edge[cnt++].v=b; } } for(int i=0;i&lt;n;i++){ edge[cnt].u=n;edge[cnt].v=i;edge[cnt++].cost=node[i].z*X; } printf(&quot;%d\n&quot;,zhuliu(n,n+1,cnt)); } } 建图+无定根//HYSBZ - 4349 无定根 题意：攻打每一个人的堡垒需要一个代价,而且必须攻打若干次,各个堡垒之间会相互提供援助, 小C只要攻打某个堡垒一次之后，某些堡垒就只需要花更小的代价攻击了,求消灭所有堡垒的最小代价。 思路: 如题目，最小树形图裸题，建立一个虚点，连向所有点，然后跑出每个点都打一次的最小代价。 然后再来以每次都是最小代价的打法，对每个点再打times[i]−1次。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const double INF=0x3f3f3f3f; struct Edge{ int u,v; double cost; Edge(int U=0,int V=0,double C=0):u(U),v(V),cost(C){} }edge[maxn*maxn+maxn]; int pre[maxn],id[maxn],vis[maxn]; double in[maxn]; double zhuliu(int root,int n,int m){ double res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int times[maxn];//times[i] 记录 i 点需要打几次 double cost[maxn];//cost[i] 记录打 i 点的花费 int main() { int n,m; while(~scanf(&quot;%d&quot;,&amp;n)){ int cnt=0; for(int i=1;i&lt;=n;i++){ scanf(&quot;%lf%d&quot;,&amp;cost[i],&amp;times[i]); edge[cnt++]=Edge(0,i,cost[i]);//建 0-&gt;i 初始花费的边(设0为虚根) } scanf(&quot;%d&quot;,&amp;m); int u,v;double c; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%lf&quot;,&amp;u,&amp;v,&amp;c); edge[cnt++]=Edge(u,v,c);//建 u-&gt;v 较小花费的边 cost[v]=min(cost[v],c); } double ans=0; for(int i=1;i&lt;=n;i++) ans+=(times[i]-1)*cost[i];//需要打times[i]次，所以需要加上(time[i]-1)次 * 较小花费 printf(&quot;%.2f\n&quot;,zhuliu(0,n+1,cnt)+ans);//0-&gt;根 n+1个点 cnt条边 } } /* 3 10 1 1.8 1 2.5 2 2 1 3 2 3 2 1.5 3 10 1 9 1 8 1 0 */ 建图+无定根+多点(一个课程好多点)题意：给你n门课的最高等级及m条升级方法，开始时你每门课的等级都在等级0，升级方法的5个参数代表，你要上这门课，你的课程c的等级至少要到达L1i， 你才能达到课程d的等级L2i，同时花费金钱moi，现在问你，每门课的等级都要到达最高等级所需要花费的最小费用是多少，如果不能都达到最高级别，输出-1 思路：图论的题，精华都是在构图，这道题很明显是一道有向的最小生成树，也就是最小树形图，那么问题来了，因为条件中是至少到达，这样如果中间断开， 按正常的建边就不能使得这棵树完整，那么精妙的方法就来了，外面把所有的边都往反向建一次，及课程a的等级i+1连向i，这就可以保证， 如果我已经达到了等级i+1，就不用再对i作花费，同时，等级i如果能连向终点，也可以直接在树的结构中体现出来。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; Edge(int U=0,int V=0,int C=0):u(U),v(V),cost(C){} }edge[maxn*maxn+maxn]; int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int a[maxn],sum[maxn]; int main() { int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n+m)){ sum[0]=0; for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);a[i]++;//a[i]表示一个课程的a[i]++(0~a[i])个等级，共a[i]++个点 sum[i+1]=sum[i]+a[i];//sum[i]~sum[i+1]-1记录i课程的a[i]个点的序号 } int cnt=0; for(int i=0;i&lt;n;i++){ for(int j=sum[i+1]-1;j&gt;sum[i];j--){ edge[cnt++]=Edge(j,j-1,0); }//将所有等级作为一个节点，对于等级i,可以建一条对等级i-1的边，边权为0 edge[cnt++]=Edge(sum[n],sum[i],0); }//其中sum[n]为虚拟的跟，指向所有的课程的level0的点 int c,d,l1,l2,mo; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%d%d%d&quot;,&amp;c,&amp;l1,&amp;d,&amp;l2,&amp;mo); edge[cnt++]=Edge(sum[c-1]+l1,sum[d-1]+l2,mo); }//建立c课程的level0+l1 到 d课程的level0+l1 之间的边 权值为价格 printf(&quot;%d\n&quot;,zhuliu(sum[n],sum[n]+1,cnt)); } } 代补题：UVA - 11865 ----&gt;二分加最小树形图 CodeForces - 240E -------&gt;最小树形图+路径输出 (自己独立思考出这个题就应该能完全掌握最小树形图)]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错排公式]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[第一篇博客，写个错排公式 实践一下md语法 dp[i] = (i-1) * (dp[i-1] + dp[i-2]) 问题：把n封信装进n个信封，有多少种方法？ 公式很easy，写在上面了，现在理解一下： 假设现在已经有i-1封已经完成错排，有dp[i-1]种方式，下面处理第i封从前i-1封中取出一封(k位置)换一下，有i-1个选择，取出的信怎么处理呢？(1)放在原来的第i个位置，剩下i-2封错排之后有dp[i-2]种方式，这很容易理解。(2)不放在第i个位置,同时也不能放在k位置，只能再和剩下的i-2封换了，仔细想一下，这不就是原来的问题嘛！只不过数据规模减少了1，所以有dp[i-2]种方式。综上：dp[i] = (i-1) * (dp[i-1] + dp[i-2])&emsp;&emsp;&emsp;dp[1]=0;dp[2]=1;递归搞一搞，得结果。 就酱，第一篇结束。。。排版很low 内容很low 我也很low哎，几个月前就开了博客，一直没写过，感觉还是把接触到的有意义东西记录一下吧！毕竟记性不好，现在会的东西两个月之后也忘得差不多了。应该会写点ACM的东西吧，再传点其他方面的笔记，嗯嗯，希望自己真的能做到,结束自闭，努力学习。]]></content>
      <categories>
        <category>递推</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go性能分析</title>
      <link href="/posts/e7f6264f.html"/>
      <url>/posts/e7f6264f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go性能分析"><a href="#Go性能分析" class="headerlink" title="Go性能分析"></a>Go性能分析</h1><p>日常开发中经常会对程序的性能进行分析，本文介绍几种常用的工具</p><ul><li><code>Benchmark（基准测试）</code>：衡量特定代码片段的执行效率，支持多维度参数调优。</li><li><code>PProf（性能剖析）</code>：深入分析CPU、内存、Goroutine等资源的使用情况，定位性能瓶颈。</li><li><code>Trace（执行追踪）</code>：分析Goroutine调度、系统调用、阻塞事件等并发问题。</li></ul><h2 id="1-Benchmark（基准测试）"><a href="#1-Benchmark（基准测试）" class="headerlink" title="1.Benchmark（基准测试）"></a>1.Benchmark（基准测试）</h2><ol><li><strong>编写基准函数</strong>：与单元测试类似，在<code>_test.go</code>文件中定义以<code>Benchmark</code>开头的函数，例如：</li></ol><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> bench<span class="token keyword">import</span> <span class="token string">"testing"</span><span class="token keyword">func</span> <span class="token function">BenchmarkFib</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token function">Fib</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>运行测试</strong></li></ol><ul><li>执行所有基准测试：<code>go test -bench=.</code></li><li>指定指定基准测试：<code>go test -bench=BenchmarkFib</code></li><li>指定测试次数或时间<ul><li><code>-benchtime=5s</code>：指定测试时间</li><li><code>-count=3</code>：多次运行取平均结果</li><li><code>-cpu=4</code>：指定使用的CPU核心数</li><li><code>-benchmem</code>：获得内存分配的统计数据</li></ul></li></ul><p> <code>go test -bench=. -benchmem</code></p><pre><code>goos: darwingoarch: arm64pkg: github.com/xxf0512/playground/perf/bench函数名称-CPU核心数         执行次数                耗时/次                 分配内存/次       分配次数/次BenchmarkFib-8           4481872               255.4 ns/op             0 B/op          0 allocs/opPASSok      github.com/xxf0512/playground/perf/bench        1.615s</code></pre><ol start="3"><li>结合性能分析：生成CPU和内存分析文件</li></ol><p><code>go test -bench=. -cpuprofile=cpu.prof -memprofile=mem.prof</code></p><p>随后可用<code>go tool pprof</code>分析这些文件</p><hr><h2 id="2-PProf（性能剖析）"><a href="#2-PProf（性能剖析）" class="headerlink" title="2.PProf（性能剖析）"></a>2.PProf（性能剖析）</h2><p>👇下面的实验基于<a href="https://github.com/wolfogre/go-pprof-practice">go-pprof-practice</a>项目，这是一个性能堪忧的炸弹程序。</p><h3 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h3><p>pprof 可以通过命令行查看数据，也可以通过图形化页面<a href="https://graphviz.gitlab.io/download/">graphviz</a>直观展示</p><pre><code>brew install graphviz # macosapt install graphviz # ubuntuyum install graphviz # centos</code></pre><h3 id="2-2-运行项目"><a href="#2-2-运行项目" class="headerlink" title="2.2 运行项目"></a>2.2 运行项目</h3><p><a href="https://github.com/wolfogre/go-pprof-practice">go-pprof-practice</a>项目入口如下, 启动并访问 pprof 页面<code>http://localhost:6060/debug/pprof/</code></p><ul><li><strong>在这个页面点击触发采样并下载采样文件</strong>，命令行或可视化查看<ul><li>命令行：<code>go tool pprof profile_path</code></li><li>可视化：<code>go tool pprof -http=:8088 profile_path</code></li></ul></li><li>也可直接通过 go tool pprof 命令查看 <ul><li><code>go tool pprof -http=:8088 "http://localhost:6060/debug/pprof/xxx"</code></li></ul></li><li>其他操作<ul><li>curl下载采样：<code>curl -o heap-target http://localhost:6060/debug/pprof/xxx</code></li></ul></li></ul><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"log"</span>    <span class="token string">"net/http"</span>    <span class="token boolean">_</span> <span class="token string">"net/http/pprof"</span> <span class="token comment" spellcheck="true">// 自动注册 handler 到 http server，方便通过 http 接口获取程序运行采样报告</span>    <span class="token string">"os"</span>    <span class="token string">"runtime"</span>    <span class="token string">"time"</span>    <span class="token string">"github.com/wolfogre/go-pprof-practice/animal"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">SetFlags</span><span class="token punctuation">(</span>log<span class="token punctuation">.</span>Lshortfile <span class="token operator">|</span> log<span class="token punctuation">.</span>LstdFlags<span class="token punctuation">)</span>    log<span class="token punctuation">.</span><span class="token function">SetOutput</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">)</span>    runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 限制 CPU 使用数，避免过载</span>    runtime<span class="token punctuation">.</span><span class="token function">SetMutexProfileFraction</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 开启对锁调用的跟踪</span>    runtime<span class="token punctuation">.</span><span class="token function">SetBlockProfileRate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 开启对阻塞操作的跟踪</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动一个 http server </span>        <span class="token keyword">if</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":6060"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> animal<span class="token punctuation">.</span>AllAnimals <span class="token punctuation">{</span>            v<span class="token punctuation">.</span><span class="token function">Live</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-采样分析"><a href="#2-3-采样分析" class="headerlink" title="2.3 采样分析"></a>2.3 采样分析</h3><p>pprof 支持以下几种类型的采样数据，注意图中的 Count，可以初步评估程序是否有问题</p><img src="../images/Go性能分析/image-20250501212909015.png" alt="pprof页面" style="zoom: 33%;"><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>allocs</td><td><strong>内存分配</strong> 情况的采样信息</td></tr><tr><td>blocks</td><td><strong>阻塞操作</strong> 情况的采样信息</td></tr><tr><td>cmdline</td><td>显示程序 启动命令及参数</td></tr><tr><td>goroutine</td><td>当前所有 <strong>协程的堆栈信息</strong></td></tr><tr><td>heap</td><td><strong>堆上内存使用</strong> 情况的采样信息</td></tr><tr><td>mutex</td><td><strong>锁争用</strong> 情况的采样信息</td></tr><tr><td>profile</td><td><strong>CPU 占用</strong> 情况的采样信息</td></tr><tr><td>threadcreate</td><td><strong>系统线程创建</strong> 情况的采样信息</td></tr><tr><td>trace</td><td>程序运行跟踪信息</td></tr></tbody></table><h4 id="2-3-1-profile-CPU占用"><a href="#2-3-1-profile-CPU占用" class="headerlink" title="2.3.1 profile-CPU占用"></a>2.3.1 profile-CPU占用</h4><blockquote><p>在一段时间内进行打点采样，通过查看采样点在各个函数栈中的分布比例，以此来反映各函数对 cpu 的占用情况.</p></blockquote><p><code>go tool pprof -http=:8088 "http://localhost:6060/debug/pprof/profile"</code></p><ul><li>可以从 Peek/Top 列表看到每个函数消耗的资源</li></ul><img src="../images/Go性能分析/image-20250501222124084.png" alt="profile-Peek" style="zoom: 50%;"><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>flat</td><td>当前函数本身的执行耗时</td></tr><tr><td>flat%</td><td>flat 占 CPU 总时间的比例</td></tr><tr><td>sum%</td><td>当前函数及其父函数的总耗时占比</td></tr><tr><td>cum</td><td>当前函数及其子函数的总耗时</td></tr><tr><td>cum%</td><td>cum 占 CPU 总时间的比例</td></tr></tbody></table><ul><li>也可以从函数调用链直观看到链路上各个方法的消耗</li></ul><img src="../images/Go性能分析/image-20250501223134454.png" alt="CPU占用-Graph" style="zoom:30%;"><p>由图可见</p><ol><li>CPU 炸弹在 Tiger.Eat 函数里，for 循环把 CPU 打满</li><li>下游 asyncPreempt 函数消耗了 510ms，因为 g 超时触发抢占</li></ol><img src="../images/Go性能分析/image-20250501223513061.png" alt="profile-问题定位" style="zoom:40%;"><h4 id="2-3-2-heap-内存分配"><a href="#2-3-2-heap-内存分配" class="headerlink" title="2.3.2 heap-内存分配"></a>2.3.2 heap-内存分配</h4><p><code>go tool pprof -http=:8088 "http://localhost:6060/debug/pprof/heap"</code></p><ul><li>函数调用链可以看到 Mouse.Steal 占用了大量内存</li></ul><img src="../images/Go性能分析/image-20250501225729689.png" alt="heap-Graph" style="zoom:35%;"><ul><li>Source 可以直接定位到有问题的代码，在不断往 buffer 里追加数据</li></ul><img src="../images/Go性能分析/image-20250501225938311.png" alt="heap-Source" style="zoom:35%;"><h4 id="2-3-3-goroutine-协程分析"><a href="#2-3-3-goroutine-协程分析" class="headerlink" title="2.3.3 goroutine-协程分析"></a>2.3.3 goroutine-协程分析</h4><p><code>go tool pprof -http=:8088 "http://localhost:6060/debug/pprof/goroutine"</code></p><ul><li>这次用火焰图分析，可以看到 Wolf.Drink 函数创建大量协程</li></ul><img src="../images/Go性能分析/image-20250501230716513.png" alt="groutine-Flame Graph" style="zoom:40%;"><ul><li>Source 可以看到代码里发生了协程泄露</li></ul><img src="../images/Go性能分析/image-20250501231030535.png" alt="groutine-Source" style="zoom:40%;"><h4 id="2-3-4-mutex-锁争抢"><a href="#2-3-4-mutex-锁争抢" class="headerlink" title="2.3.4 mutex-锁争抢"></a>2.3.4 mutex-锁争抢</h4><blockquote><p>mutex 分析看的是某个 goroutine 持有锁的时长（mutex.Lock -&gt; mutex.Unlock 之间这段时间），且只有在存在锁竞争关系时才会上报这部分数据</p></blockquote><p><code>go tool pprof -http=:8088 "http://localhost:6060/debug/pprof/mutex"</code></p><ul><li>先通过火焰图或调用图粗粒度分析问题，Wolf.Howl 方法锁占用时间异常</li></ul><img src="../images/Go性能分析/image-20250501231627728.png" alt="mutex-Graph" style="zoom:30%;"><ul><li>再到 Source 定位问题</li></ul><img src="../images/Go性能分析/image-20250501231754062.png" alt="mutex-Source" style="zoom:30%;"><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>Wolf<span class="token punctuation">)</span> <span class="token function">Howl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"howl"</span><span class="token punctuation">)</span>    m <span class="token operator">:=</span> <span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">{</span><span class="token punctuation">}</span>    m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 锁占用时间</span>        m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-5-block-阻塞操作"><a href="#2-3-5-block-阻塞操作" class="headerlink" title="2.3.5 block-阻塞操作"></a>2.3.5 block-阻塞操作</h4><blockquote><p>查看某个 goroutine 陷入 waiting 状态（被动阻塞，通常因 gopark 操作触发，比如因加锁、读chan条件不满足而陷入阻塞）的触发次数和持续时长</p></blockquote><p><code>go tool pprof -http=:8088 "http://localhost:6060/debug/pprof/block"</code></p><ul><li>先通过火焰图或调用图粗粒度分析问题</li></ul><img src="../images/Go性能分析/image-20250501232623296.png" alt="block-Graph" style="zoom:25%;"><ul><li>Source 定位问题</li></ul><img src="../images/Go性能分析/image-20250501232954806.png" alt="block-Source" style="zoom:33%;"><h4 id="2-3-6-基准对比"><a href="#2-3-6-基准对比" class="headerlink" title="2.3.6 基准对比"></a>2.3.6 基准对比</h4><p>可以对比两个不同时间点的采样，能更好地发现内存泄露等问题，提升效率</p><p><code>go tool pprof -http=:8080 -base heap-base heap-target</code></p><h3 id="2-4-PProf-原理"><a href="#2-4-PProf-原理" class="headerlink" title="2.4 PProf 原理"></a>2.4 PProf 原理</h3><hr><h2 id="3-Trace（执行追踪）"><a href="#3-Trace（执行追踪）" class="headerlink" title="3.Trace（执行追踪）"></a>3.Trace（执行追踪）</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://mp.weixin.qq.com/s/Qwmo9FHCF010-0rMUbyuww">Golang pprof 案例实战与原理解析</a></p><p>[2] <a href="https://farmerchillax.github.io/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">Go性能分析工具</a></p><p>[3] <a href="https://blog.wolfogre.com/posts/go-ppof-practice/">golang pprof 实战</a></p><p>[4] <a href="https://zhuanlan.zhihu.com/p/680397395">Golang性能分析工具从原理到实战</a></p><p>[5] <a href="https://golang2.eddycjy.com/posts/ch6/01-pprof-1/">Go 大杀器之性能剖析 PProf</a></p><p>[6] <a href="https://huizhou92.com/p/golang-high-performance-programming-ep5-benchmark/">Golang High-Performance Programming EP5: Benchmark</a></p><p>[7] <a href="https://www.liwenzhou.com/posts/Go/unit-test/">Go语言基础之单元测试</a></p><p>[8] <a href="https://mp.weixin.qq.com/s/I9xSMxy32cALSNQAN8wlnQ">深入浅出 Go trace</a></p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> testing </tag>
            
            <tag> pprof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka-常见问题</title>
      <link href="/posts/6895709.html"/>
      <url>/posts/6895709.html</url>
      
        <content type="html"><![CDATA[<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="一、核心概念和架构"><a href="#一、核心概念和架构" class="headerlink" title="一、核心概念和架构"></a>一、核心概念和架构</h2><h3 id="1-Topic-如何实现高吞吐与负载均衡"><a href="#1-Topic-如何实现高吞吐与负载均衡" class="headerlink" title="1. Topic 如何实现高吞吐与负载均衡"></a>1. Topic 如何实现高吞吐与负载均衡</h3><h3 id="2-Partition-的副本机制及数据同步原理？"><a href="#2-Partition-的副本机制及数据同步原理？" class="headerlink" title="2. Partition 的副本机制及数据同步原理？"></a>2. Partition 的副本机制及数据同步原理？</h3><h3 id="3-ISR-的作用是什么？如何判断副本是否在-ISR-中？"><a href="#3-ISR-的作用是什么？如何判断副本是否在-ISR-中？" class="headerlink" title="3. ISR 的作用是什么？如何判断副本是否在 ISR 中？"></a>3. ISR 的作用是什么？如何判断副本是否在 ISR 中？</h3><h3 id="4-副本滞后时如何处理？replica-lag-time-max-ms-的作用？"><a href="#4-副本滞后时如何处理？replica-lag-time-max-ms-的作用？" class="headerlink" title="4. 副本滞后时如何处理？replica.lag.time.max.ms 的作用？"></a>4. 副本滞后时如何处理？replica.lag.time.max.ms 的作用？</h3><h3 id="5-HW-如何保证消费者读取一致性？LEO-如何影响生产者写入？"><a href="#5-HW-如何保证消费者读取一致性？LEO-如何影响生产者写入？" class="headerlink" title="5. HW 如何保证消费者读取一致性？LEO 如何影响生产者写入？"></a>5. HW 如何保证消费者读取一致性？LEO 如何影响生产者写入？</h3><h2 id="1-如何避免消息丢失"><a href="#1-如何避免消息丢失" class="headerlink" title="1.如何避免消息丢失"></a>1.如何避免消息丢失</h2><p>消息丢失主要是在这几种场景：</p><ol><li><p>Producer：Producer 发送到 Broker 丢失，消息没有成功投递</p><ul><li>使用带回调通知的发送 API，不要用 Fire and forget 模式</li><li>发送时设置重试次数</li></ul></li><li><p>Broker：Broker 保存消息(持久化)丢失</p><ul><li>Kafka 收到消息后会先存储在也缓存中(Page Cache)中，之后由操作系统根据自己的策略进行刷盘或者通过 fsync 命令强制刷盘。如果系统挂掉，在 PageCache 中的数据就会丢失。<ul><li>acks=0：消息很可能会丢</li><li>acks=1：如果 follower 没有收到 leader 同步的消息，leader 就挂了，消息会丢失</li><li>acks=-1(all)，只有所有副本全挂才会丢，基本不可能，可认为已经持久化</li></ul></li></ul></li><li><p>Consumer：Consumer 消费消息丢失</p><ul><li><p>唯一原因：Consumer 没有正确消费消息，就把 Offset 提交了，导致 Kafka 认为该消息已经被消费了，从而导致消息丢失。</p></li><li><p>不要开启自动提交，手动提交位移，确保休息消费完再提交</p></li></ul></li></ol><h2 id="2-如何避免重复消费"><a href="#2-如何避免重复消费" class="headerlink" title="2.如何避免重复消费"></a>2.如何避免重复消费</h2><h2 id="3-消息传递语义"><a href="#3-消息传递语义" class="headerlink" title="3.消息传递语义"></a>3.消息传递语义</h2><p>消息传递语义：Producer 和 Consumer 之间消息传递保证性，分为三种</p><ul><li><code>at-least-once</code>: 至少一次，消息不会丢，但可能重复传递<ul><li>默认 Kafka 保障，Producer ACK 机制 + Broker Replica 机制</li></ul></li><li><code>at-most-once</code>: 最多一次，消息可能丢，但不会重复传递<ul><li>用户在处理消息之前保存 Offset，实现该语义</li></ul></li><li><code>exactly-once</code>: 精准一次，消息不会丢，也不会重复传递<ul><li>用户自己实现幂等</li></ul></li></ul><h2 id="如何实现-exactly-once-语义"><a href="#如何实现-exactly-once-语义" class="headerlink" title="如何实现 exactly-once 语义"></a>如何实现 exactly-once 语义</h2><h2 id="4-Rebalance-触发时机"><a href="#4-Rebalance-触发时机" class="headerlink" title="4.Rebalance 触发时机"></a>4.Rebalance 触发时机</h2><ol><li>组成员数量发生变化</li><li>订阅主题数量发生变化，如正则匹配到了更多主题</li><li>订阅主题的分区数发生变化</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://www.tpointtech.com/kafka-interview-questions">Top 35+ Most Asked Kafka Interview Questions and Answers</a></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> kafka </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka-进阶篇</title>
      <link href="/posts/fbd900db.html"/>
      <url>/posts/fbd900db.html</url>
      
        <content type="html"><![CDATA[<h1 id="kafka-进阶篇"><a href="#kafka-进阶篇" class="headerlink" title="kafka-进阶篇"></a>kafka-进阶篇</h1><blockquote><p> <a href="https://xxf0512.github.io/posts/d451c14b.html">kafka-入门篇</a>介绍了kafka的重要概念。</p><p> 本文将从消息的视角出发，并结合实验，从消息生产、消息处理、消息消费全流程分析kafka的设计原理。</p><p> kafka版本：3.6.0</p></blockquote><h2 id="1-消息生产"><a href="#1-消息生产" class="headerlink" title="1. 消息生产"></a>1. 消息生产</h2><p>消息生产主要分为以下几个步骤</p><ol><li><code>构造消息</code>：创建消息对象</li><li><code>序列化</code>：将消息对象转换为字节数组</li><li><code>分区器</code>：根据消息的Key选择一个分区</li><li><code>缓冲区</code>：按分区缓冲一批消息</li><li><code>发送请求</code>：将数据发送到Kafka集群</li><li><code>响应处理</code>：返回成功或失败响应 </li></ol><img src="../images/kafka-进阶篇/kafkaproducerapi.png" alt="消息生产" style="zoom: 40%;"><p>以下是使用<code>github.com/IBM/sarama</code>实现的消息生产</p><ul><li>首先指定 brokers 和 config，初始化Producer对象<ul><li>brokers: broker地址，通常数量&gt;=3</li><li>config: 设置 acks、retry、partitioner 等参数</li></ul></li><li>根据 Topic、Key、Value 构造消息对象，此外还可以注入 Headers 等数据</li><li>调用<code>SendMessage</code>发送消息，获取消息写入的 partition 和 offset</li></ul><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>    topic <span class="token operator">=</span> <span class="token string">"add-user"</span>    brokers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"localhost:19092"</span><span class="token punctuation">,</span> <span class="token string">"localhost:19093"</span><span class="token punctuation">,</span> <span class="token string">"localhost:19094"</span><span class="token punctuation">}</span>    config  <span class="token operator">*</span>sarama<span class="token punctuation">.</span>Config<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    config <span class="token operator">=</span> sarama<span class="token punctuation">.</span><span class="token function">NewConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    config<span class="token punctuation">.</span>Producer<span class="token punctuation">.</span>Return<span class="token punctuation">.</span>Successes <span class="token operator">=</span> <span class="token boolean">true</span>               <span class="token comment" spellcheck="true">// 确保消息发送成功</span>    config<span class="token punctuation">.</span>Producer<span class="token punctuation">.</span>Retry<span class="token punctuation">.</span>Max <span class="token operator">=</span> <span class="token number">3</span>                         <span class="token comment" spellcheck="true">// 重试次数</span>    config<span class="token punctuation">.</span>Version <span class="token operator">=</span> sarama<span class="token punctuation">.</span>V3_6_0_0                      <span class="token comment" spellcheck="true">// 根据Kafka版本调整</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Produce</span><span class="token punctuation">(</span>msg Message<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    producer<span class="token punctuation">,</span> err <span class="token operator">:=</span> sarama<span class="token punctuation">.</span><span class="token function">NewSyncProducer</span><span class="token punctuation">(</span>brokers<span class="token punctuation">,</span> config<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">Wrap</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">"Failed to start producer"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> producer<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    encodedMsg <span class="token operator">:=</span> <span class="token operator">&amp;</span>sarama<span class="token punctuation">.</span>ProducerMessage<span class="token punctuation">{</span>        Topic<span class="token punctuation">:</span> topic<span class="token punctuation">,</span>        Key<span class="token punctuation">:</span>   sarama<span class="token punctuation">.</span><span class="token function">StringEncoder</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>Key<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 消息键（可选）</span>        Value<span class="token punctuation">:</span> sarama<span class="token punctuation">.</span><span class="token function">StringEncoder</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 消息值</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 发送消息</span>    partition<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> err <span class="token operator">:=</span> producer<span class="token punctuation">.</span><span class="token function">SendMessage</span><span class="token punctuation">(</span>encodedMsg<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">Wrap</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">"Failed to send message"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Sent message to partition %d, offset %d\n"</span><span class="token punctuation">,</span> partition<span class="token punctuation">,</span> offset<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-构造消息"><a href="#1-1-构造消息" class="headerlink" title="1.1 构造消息"></a>1.1 构造消息</h3><img src="../images/kafka-进阶篇/kafka-message.png" alt="消息结构" style="zoom: 33%;"><p>消息包括但不限于以下字段，需要说明的是，<strong>它并不是单纯意义上的消息</strong>，它包含了多个属性，原本需要发送的与业务相关的消息体只是其中的一个<code>Value</code>属性。</p><table><thead><tr><th>字段</th><th>简介</th></tr></thead><tbody><tr><td>Topic</td><td>消息要发往的主题，消息以主题为单位归类</td></tr><tr><td>Key</td><td>消息的键，可用于计算分区号（二次归类）、亦可用于日志压缩</td></tr><tr><td>Value</td><td><strong>消息本体</strong>，一般不为空，否则表示墓碑消息</td></tr><tr><td>Headers</td><td>消息头部，kv对 用于应用级别的扩展，可以存业务数据</td></tr><tr><td>Partition</td><td>消息要发往的分区号</td></tr><tr><td>Timestamp</td><td>消息的时间戳，两种类型：CreateTime（创建时间）、LogAppendTime（追加到日志文件的时间）</td></tr></tbody></table><p>*墓碑消息：在<strong>日志压缩（Log Compaction）</strong>机制中，用于告知消费者：<strong>某个 Key 的最新状态是“已删除”</strong>，应清理本地缓存的该 Key 数据。</p><h3 id="1-2-序列化"><a href="#1-2-序列化" class="headerlink" title="1.2 序列化"></a>1.2 序列化</h3><p>将消息 Key 和 Value 转换为字节数组</p><ul><li><code>go sarama</code>提供了 StringEncoder 将 string 转为 []byte</li><li>对于其他类型的数据，可以用json、sonic 等工具先转为 string 或 []byte</li></ul><h3 id="1-3-分区器"><a href="#1-3-分区器" class="headerlink" title="1.3 分区器"></a>1.3 分区器</h3><p>决定生产者将消息发送到哪个Partition，常用的有以下几种分区策略：</p><ul><li><code>轮询分区（Round-robin）</code>：顺序分配到每个分区<ul><li>优点：最大程度保证负载均衡</li></ul></li><li><code>随机分区（Randomness）</code>：根据随机数确定分区<ul><li>优点：实现简单</li></ul></li><li><code>哈希分区（Hash）</code>：消息键保序,对 Key 哈希取模确定分区 hash(Key) % numPartitions<ul><li>优点：相同 Key 的消息可分到同一个分区，保证顺序</li></ul></li><li><code>粘性分区（Sticky）</code>：会在一段时间内将消息发送到同一个分区，当批次满了或者达到一定时间后，选择另一个分区继续发送消息。Kafka 2.4.0 引入<ul><li>优点：便于批量处理，提高吞吐量</li></ul></li><li><code>自定义分区</code>：发送消息时指定分区序号</li></ul><p><strong><code>go sarama</code>默认采用<a href="https://github.com/IBM/sarama/blob/main/partitioner.go#L209">哈希分区</a>，若 Key 为 nil 则随机确认分区，否则哈希取模确认分区</strong></p><p>也可以配置或自己实现一套分区策略，只需实现<code>Partitioner</code>接口</p><pre class="line-numbers language-go"><code class="language-go">config<span class="token punctuation">.</span>Producer<span class="token punctuation">.</span>Partitioner <span class="token operator">=</span> sarama<span class="token punctuation">.</span>NewRoundRobinPartitioner <span class="token comment" spellcheck="true">// 轮询分区器</span><span class="token keyword">type</span> Partitioner <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Partition</span><span class="token punctuation">(</span>message <span class="token operator">*</span>ProducerMessage<span class="token punctuation">,</span> numPartitions <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int32</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>    <span class="token function">RequiresConsistency</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-缓冲区"><a href="#1-4-缓冲区" class="headerlink" title="1.4 缓冲区"></a>1.4 缓冲区</h3><p>Kafka批量发送可以提升数据发送效率，但也会增加延迟，需要在二者之间 tradeoff</p><p><code>go sarama</code>可以通过以下几种方式设置缓冲区 &amp; 触发消息提交</p><pre class="line-numbers language-go"><code class="language-go">config <span class="token operator">:=</span> sarama<span class="token punctuation">.</span><span class="token function">NewConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>config<span class="token punctuation">.</span>ChannelBufferSize <span class="token operator">=</span> <span class="token number">256</span> <span class="token comment" spellcheck="true">// 默认消息数量</span>config<span class="token punctuation">.</span>Producer<span class="token punctuation">.</span>Flush<span class="token punctuation">.</span>Bytes <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token comment" spellcheck="true">// 大小 1MB</span>config<span class="token punctuation">.</span>Producer<span class="token punctuation">.</span>Flush<span class="token punctuation">.</span>Messages <span class="token operator">=</span> <span class="token number">3</span> <span class="token comment" spellcheck="true">// 数量 </span>config<span class="token punctuation">.</span>Producer<span class="token punctuation">.</span>Flush<span class="token punctuation">.</span>Frequency <span class="token operator">=</span> time<span class="token punctuation">.</span>Duration <span class="token comment" spellcheck="true">// 发送频率</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-发送请求"><a href="#1-5-发送请求" class="headerlink" title="1.5 发送请求"></a>1.5 发送请求</h3><img src="../images/kafka-进阶篇/Sarama-Producer-流程.png" alt="Sarama AsyncProducer消息发送流程" style="zoom: 40%;"><p>以 sarama 为例，有两种类型的生产者</p><ul><li><code>SyncProducer 同步生产者</code>：阻塞请求，直到收到了 ack，通过<code>config.Producer.RequiredAcks</code>参数控制<ul><li>asks=0：fire and forget 只管发送，不管到达；性能很高，可靠性最差</li><li>asks=1（默认值）：只要 leader 副本成功写入消息即为成功；在性能和可靠性间取舍，leader 宕机时可能丢消息</li><li>asks=-1 or all：需要所有副本成功写入消息才认为成功；性能最低，可靠性最强，但也可能会丢消息，比如只有一个副本</li></ul></li><li><code>AsyncProducer 异步生产者</code>：使用 channel 发送消息，以及接收生产成功/失败的结果，channel 的大小通过<code>config.ChannelBufferSize</code>控制</li></ul><p><strong>数据压缩</strong> </p><p><u><strong>Producer 端压缩、Broker 端保持、Consumer 端解压</strong></u></p><ul><li><p>通过<code>Config.Producer.CompressionLevel</code>指定压缩等级</p><ul><li>压缩等级是算法内部的可调参数，数值越高通常代表压缩率越高（数据体积更小），但压缩速度越慢且CPU 占用越高</li></ul></li><li><p>通过<code>Config.Producer.Compression</code>指定压缩算法，例如：GZIP/Snappy/LZ4/ZSTD</p><ul><li>吞吐量方面：LZ4 &gt; Snappy &gt; zstd ≈ GZIP</li><li>压缩比方面，zstd &gt; LZ4 &gt; GZIP &gt; Snappy</li><li><strong>解压速度</strong>：LZ4 ≈ Snappy &gt; Zstd &gt; Gzip</li></ul></li></ul><p><strong>重试机制</strong></p><ul><li>可通过<code>config.Producer.Retry.Max = 3</code>设置消息发送的重试次数</li></ul><h3 id="1-6-响应处理"><a href="#1-6-响应处理" class="headerlink" title="1.6 响应处理"></a>1.6 响应处理</h3><ul><li><code>SyncProducer 同步生产者</code>：阻塞等待响应，直接返回结果给调用方</li><li><code>AsyncProducer 异步生产者</code>：通过 <code>Successes</code> 和 <code>Errors</code> <strong>channel</strong> 异步通知结果</li></ul><hr><h2 id="2-消息处理"><a href="#2-消息处理" class="headerlink" title="2. 消息处理"></a>2. 消息处理</h2><p>消息处理的流程如下，</p><p><strong>对于消息生产请求</strong></p><ol><li>请求进入 broker 的套接字接收缓冲区</li><li>处理用户请求<ul><li>网络线程从缓冲区捞一个用户请求，并负责该请求从接收到响应的全生命周期，直到处理完成才被放回线程池</li><li>将用户请求转换为消息生产请求对象，并添加到请求队列</li></ul></li><li>处理消息生产请求<ul><li>I/O 线程从队列捞取一个请求，做一些校验，和分区关联，最后把消息追加到 commit log</li><li>消息先存在 Page Cache 中，然后被批量刷盘，最终落到磁盘上</li><li>为了完成 Leader-Follower 副本同步，消息还会存到 Purgatory（名为炼狱的缓冲区）上</li></ul></li><li>响应请求<ul><li>当满足 acks 条件，如成功写入 Leader，将把结果写入响应队列</li><li>网络线程将结果捞出写入套接字发送缓冲区</li></ul></li></ol><p><strong>对于消息消费请求</strong>，流程基本相同，不同点如下</p><ol><li><p>I/O 线程会计算消息在日志文件中的位置</p></li><li><p>可以指定每批拿到多少数据才返回，把请求丢到 Purgatory 等待</p></li><li><p>Purgatory 中请求累计了足够多的数据后就可以响应</p></li></ol><img src="../images/kafka-进阶篇/Kafka_Internals_026.png" alt="Kafka-Broker" style="zoom: 50%;"><h3 id="2-1-数据面：副本同步"><a href="#2-1-数据面：副本同步" class="headerlink" title="2.1 数据面：副本同步"></a>2.1 数据面：副本同步</h3><p>副本同步也叫数据复制，是 Kafka 持久性和高可用的关键技术，如果副本因子是N，那么可以忍受 N-1 次 broker 宕机。</p><p>副本分为两类：</p><ul><li><code>Leader</code>：负责消息的收发，以及确认哪些 Follower 与自己同步</li><li><code>Follower</code>：主动从 Leader 拉取消息，返回同步的 Offset；根据是否与 Leader 同步，Follower 又被划分为；<ul><li>ISR(In-Sync Replica)：保持同步，Leader 的预备军，为其 backup，在它宕机时取代之</li><li>OSR(Out-Sync Replica)：存在不可接收的Gap，在阈值时间内没有拉取动作或没有拉取最新消息，通过<code>replica.lag.time.max.ms</code>配置</li></ul></li></ul><img src="../images/kafka-进阶篇/Kafka_Internals_034.png" alt="副本同步" style="zoom:30%;"><p>Leader 会维护两个同步状态：</p><ul><li>LEO(Log End Offset)：实际复制的位置，标识当前日志文件中下一条待写入的消息的offset</li><li>HW(High Watermark)：高水位，所有 Follower 都同步了之前的消息，可认为之前的消息已经持久化，消费者只能拉取到这个offset之前的消息；</li><li><strong>Leader HW = min(leader LEO, followers LEO)</strong></li><li><strong>Follower HW = min(leader HW, follower LEO)</strong></li></ul><h3 id="2-2-控制面：管理集群元数据"><a href="#2-2-控制面：管理集群元数据" class="headerlink" title="2.2 控制面：管理集群元数据"></a>2.2 控制面：管理集群元数据</h3><img src="../images/kafka-进阶篇/Kafka_Internals_048.png" alt="Data-Control Plane" style="zoom:38%;"><ul><li><code>Zookeeper Mode</code>：通过 ZooKeeper 的外部共识服务进行管理，其中一个 Broker 被指定为控制器。该控制器负责与 Zookeeper 以及集群中的其他 Broker 进行通信。集群的元数据持久保存在 ZooKeeper 中。</li><li><code>KRaft Mode</code>：(3.3.1 引入)：一部分 Broker 被指定为控制器，这些控制器提供之前由 Zookeeper 提供的共识服务。所有集群元数据现在都存储在 Kafka 主题中并由内部管理。<ul><li>优点<ul><li>更简单的部署和管理：只需安装和管理一个应用程序，Kafka 的运维占用空间显著减少</li><li>提升可扩展性：KRaft 的恢复时间比 ZooKeeper 快一个数量级。这使我们能够高效地扩展到单个集群中的数百万个分区</li><li>更高效的元数据传播：基于日志、事件驱动的元数据传播可提高 Kafka 许多核心功能的性能</li></ul></li></ul></li></ul><h4 id="2-2-1-Zookeeper"><a href="#2-2-1-Zookeeper" class="headerlink" title="2.2.1 Zookeeper"></a>2.2.1 Zookeeper</h4><img src="../images/kafka-进阶篇/Kafka_Internals_049.png" alt="zookeeper" style="zoom:30%;"><h4 id="2-2-2-KRaft"><a href="#2-2-2-KRaft" class="headerlink" title="2.2.2 KRaft"></a>2.2.2 KRaft</h4><img src="../images/kafka-进阶篇/Kafka_Internals_053.png" alt="kraft" style="zoom: 30%;"><ul><li><p>节点角色：节点可以专门作为 Controller 或 Broker，也可以同时承担两种角色</p><ul><li>控制器：每个 Controller 都会互相感知，并选出一个作为 leader（活跃控制器）；所有节点都会同步维护一份元数据缓存，出现故障时能快速选出新 leader</li><li><strong>集群元数据</strong>：存储在名为<code>__cluster_metadata</code>的单分区 Topic 中，在 Controller 和 Broker 之间同步状态</li></ul></li><li><p>选举 Controller Leader</p><ul><li>基于 Raft 协议：TODO 学习Raft</li></ul></li></ul><h3 id="2-4-物理存储"><a href="#2-4-物理存储" class="headerlink" title="2.4 物理存储"></a>2.4 物理存储</h3><h4 id="2-4-1-分区分配"><a href="#2-4-1-分区分配" class="headerlink" title="2.4.1 分区分配"></a>2.4.1 分区分配</h4><blockquote><p>决定每个 Partition 分配到哪个 Broker。</p></blockquote><p>首先明确总副本数为：分区数✖️副本因子，目标是把它们均匀地分配到所有 Broker，过程如下：</p><ul><li>先分配 Leader 副本，随机选取一个 Broker x 分配Leader0, 之后轮询 Broker(x+1)%n 分配Leader1…</li><li>之后根据 Leader 副本的位置分配 Follower, 尽量与 Leader 不在同一个 Broker 上<ul><li>Follower 0a, Follower 0b 分别分配到 Broker(x+1)%n, Broker(x+2)%n</li></ul></li></ul><h4 id="2-4-2-日志文件"><a href="#2-4-2-日志文件" class="headerlink" title="2.4.2 日志文件"></a>2.4.2 日志文件</h4><blockquote><p>消息以追加的形式写入磁盘文件，为了防止文件体积过大以及加速查询，将其进行分段并构建索引。</p></blockquote><p>详细内容见 <a href="https://xxf0512.github.io/posts/d451c14b.html#toc-heading-17">kafka-入门篇-存储结构</a></p><h4 id="2-4-3-日志清理"><a href="#2-4-3-日志清理" class="headerlink" title="2.4.3 日志清理"></a>2.4.3 日志清理</h4><blockquote><p>为了节省磁盘空间，需要对历史数据进行清理</p></blockquote><p>每个日志片段可分为干净区（被清理过）和 污浊区（未被清理），清理线程针对污浊区</p><ul><li><p>日志删除：</p><ul><li>基于时间：删除早于保留时间的 Segment，<code>log.retention.hours</code>（默认 168 小时，即 7 天）</li><li>基于大小：当分区总大小超过阈值时，删除最旧的 Segment，<code>log.retention.bytes</code>（默认 -1，即不限制）。</li></ul></li><li><p>日志压缩（Compact 策略，适用于 Key-Value 场景）</p><ul><li>保留每个 Key 的最新值，删除旧版本数据。</li><li>常用于 Topic 存储状态信息（如 __consumer_offsets）</li></ul></li></ul><h3 id="2-6-高性能设计（TODO-新开一文）"><a href="#2-6-高性能设计（TODO-新开一文）" class="headerlink" title="2.6 高性能设计（TODO 新开一文）"></a>2.6 高性能设计（TODO 新开一文）</h3><h4 id="2-6-1-Reactor-多路复用"><a href="#2-6-1-Reactor-多路复用" class="headerlink" title="2.6.1 Reactor 多路复用"></a>2.6.1 Reactor 多路复用</h4><h4 id="2-6-2-PageCache"><a href="#2-6-2-PageCache" class="headerlink" title="2.6.2 PageCache"></a>2.6.2 PageCache</h4><h4 id="2-6-3-顺序磁盘写入"><a href="#2-6-3-顺序磁盘写入" class="headerlink" title="2.6.3 顺序磁盘写入"></a>2.6.3 顺序磁盘写入</h4><h4 id="2-6-4-零拷贝"><a href="#2-6-4-零拷贝" class="headerlink" title="2.6.4 零拷贝"></a>2.6.4 零拷贝</h4><h4 id="2-6-5-时间轮"><a href="#2-6-5-时间轮" class="headerlink" title="2.6.5 时间轮"></a>2.6.5 时间轮</h4><hr><h2 id="3-消息消费"><a href="#3-消息消费" class="headerlink" title="3. 消息消费"></a>3. 消息消费</h2><p>消息消费主要分为以下几个步骤</p><ol><li><code>初始化</code>：初始化消费者组和消费者，设置相关配置</li><li><code>订阅主题</code>：订阅一个或多个主题</li><li><code>轮询拉取消息</code>：采用 pull 模式从 Broker 拉取消息</li><li><code>提交 Offset</code>：将数据发送到Kafka集群，按业务逻辑处理消息</li></ol><img src="../images/kafka-进阶篇/VBW2U.png" alt="消息消费" style="zoom:54%;"><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 实现 ConsumerGroupHandler 接口</span><span class="token keyword">type</span> ConsumerHandler <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h ConsumerHandler<span class="token punctuation">)</span> <span class="token function">Setup</span><span class="token punctuation">(</span>session sarama<span class="token punctuation">.</span>ConsumerGroupSession<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Consumer group setup"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h ConsumerHandler<span class="token punctuation">)</span> <span class="token function">Cleanup</span><span class="token punctuation">(</span>session sarama<span class="token punctuation">.</span>ConsumerGroupSession<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Consumer group cleanup"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h ConsumerHandler<span class="token punctuation">)</span> <span class="token function">ConsumeClaim</span><span class="token punctuation">(</span>session sarama<span class="token punctuation">.</span>ConsumerGroupSession<span class="token punctuation">,</span> claim sarama<span class="token punctuation">.</span>ConsumerGroupClaim<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 循环消费消息</span>    <span class="token keyword">for</span> msg <span class="token operator">:=</span> <span class="token keyword">range</span> claim<span class="token punctuation">.</span><span class="token function">Messages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Received message: Topic=%s Partition=%d Offset=%d Key=%s Value=%s\n"</span><span class="token punctuation">,</span>            msg<span class="token punctuation">.</span>Topic<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>Partition<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>Offset<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>Key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">)</span>        session<span class="token punctuation">.</span><span class="token function">MarkMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 标记消息已处理</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建消费者组</span>    consumerGroup<span class="token punctuation">,</span> err <span class="token operator">:=</span> sarama<span class="token punctuation">.</span><span class="token function">NewConsumerGroup</span><span class="token punctuation">(</span>brokers<span class="token punctuation">,</span> groupID<span class="token punctuation">,</span> config<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Failed to create consumer group: "</span> <span class="token operator">+</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> consumerGroup<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 启动消费者循环</span>    <span class="token keyword">var</span> <span class="token punctuation">(</span>        wg      sync<span class="token punctuation">.</span>WaitGroup        handler <span class="token operator">=</span> ConsumerHandler<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Consume 方法会阻塞，直到发生错误或上下文取消</span>            <span class="token keyword">if</span> err <span class="token operator">:=</span> consumerGroup<span class="token punctuation">.</span><span class="token function">Consume</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>topic<span class="token punctuation">}</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Consumer error: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-初始化消费者-组"><a href="#3-1-初始化消费者-组" class="headerlink" title="3.1 初始化消费者(组)"></a>3.1 初始化消费者(组)</h3><p><strong>消费者是消费消息的基本单位，为了提升消费并发能力，支持横向伸缩，引入了消费组的概念</strong>。</p><ul><li>消费组和消费者是 1:n 的关系：消费组即多个消费者集合，每个消费者只能从属于一个消费组</li><li>消费组和 Topic 是 n:n 的关系：消费组可订阅多个 Topic，每个 Topic 可被多个消费组订阅，互不影响</li><li>Topic 中的每个 Partition 只能由组内的一个消费者负责，当消费者数&gt;=Partition数，必定会有消费者闲置</li></ul><h4 id="3-1-1-初始化"><a href="#3-1-1-初始化" class="headerlink" title="3.1.1 初始化"></a>3.1.1 初始化</h4><ol><li><strong>消费者加入组</strong>：消费者启动后向协调器（Coordinator）发送<code>JoinGroup</code>请求。协调器根据<code>group.id</code>哈希选择所属的<code>__consumer_offsets</code>分区，该分区的<code>Leader Broker</code>担任协调器</li><li><strong>选举群主（Group Leader）</strong>：第一个发送<code>JoinGroup</code>请求的消费者被选为群主，负责执行分区分配策略。群主获取所有活跃消费者的订阅信息（含订阅的主题列表）</li></ol><h4 id="3-1-2-分区分配-amp-Rebalance"><a href="#3-1-2-分区分配-amp-Rebalance" class="headerlink" title="3.1.2 分区分配 &amp; Rebalance"></a>3.1.2 分区分配 &amp; Rebalance</h4><p><strong>分区分配</strong>：确定分区归属哪个消费者</p><ul><li><strong>处理流程</strong><ul><li>群主将分配结果提通过<code>SyncGroup</code>请求交给协调器</li><li>协调器将分配结果通过<code>SyncGroupResponse</code>发送发送给所有消费者</li><li>消费者根据分配的分区拉取消息，记录<code>Offset</code>至<code>__consumer_offsets</code></li></ul></li></ul><p><strong>Rebalance</strong>：分区所有权重新分配的过程，当分区数或消费者数发生变化，可能会触发。<strong>需要尽量避免</strong></p><ul><li><p>暂停消费：会造成群组一段时间的不可用</p></li><li><p>重复消费或数据丢失</p><ul><li>若消费者在重分配前未正确提交偏移量（Offset），新分配的消费者可能从旧偏移量重新消费，导致重复处理</li><li>若偏移量提交早于实际处理完成，则可能丢失消息</li></ul></li><li><p><strong>处理流程</strong></p><ul><li>触发条件：消费者加入/退出（心跳超时或主动下线）、订阅主题的分区数变化、新增匹配主题（如使用通配符订阅）</li><li>协调器通知所有消费者暂停消费（Stop-the-world），进入 <code>Revoke</code> 阶段（撤销当前分配）</li><li>重新执行分区分配策略，生成新方案并同步</li><li>消费者从新分配的分区恢复消费，可能需重建本地状态</li></ul></li></ul><img src="../images/kafka-进阶篇/Kafka_Internals_081-20250420171526725.png" alt="分区分配" style="zoom:50%;"><p><strong>分配策略</strong></p><ul><li><p><code>Range</code>:<strong>以单个主题为分配单位</strong>，按分区序号和消费者名称字典序排序。每个消费者分配的分区数为 <code>分区数/消费者数</code>，余数分配给前几个消费者</p><ul><li>优点：简单</li><li>缺点：重分配代价高，当消费者订阅多个主题时，前几个消费者可能承担更多分区，导致数据倾斜</li></ul><img src="../images/kafka-进阶篇/1*eUNvEg-Ys6YHesg1VIT22g.png" alt="RangeAssignor" style="zoom: 50%;"></li><li><p><code>轮询分配（RoundRobin）</code>：<strong>全局轮询</strong>所有主题的分区和消费者，按哈希排序后均匀分配。</p><ul><li>优点：跨主题分配更均衡，适合消费者订阅相同主题的场景</li><li>缺点：重分配代价高</li></ul><img src="../images/kafka-进阶篇/1*iFqxP31GfiTENF-zY95KYA.png" alt="RoundRobinAssignor" style="zoom:50%;"><img src="../images/kafka-进阶篇/1*NvNMEs7cI6R7zzYw3PCgLw.png" alt="RoundRobinAssignor with reassignment" style="zoom:50%;"></li><li><p><code>粘性策略（Sticky）</code>：重分配时尽可能保留原有分配结果以减少变动，在此基础上尽量保持分区分配均衡</p><ul><li>优点：重分配代价低</li></ul><img src="../images/kafka-进阶篇/1*iFqxP31GfiTENF-zY95KYA.png" alt="StickyAssignor" style="zoom:50%;"><img src="../images/kafka-进阶篇/1*9yltZuq9bo5kG-QHb9wddw.png" alt="StickyAssignor with reassignment" style="zoom:50%;"></li><li><p><code>合作式粘性策略（CooperativeSticky）</code>：将全局重平衡拆分为多次小规模调整，减少消费者停顿时间</p><ul><li>Kafka 2.4+ 默认使用 <code>Range + CooperativeSticky</code> 组合策略，逐步淘汰旧策略</li></ul></li></ul><h3 id="3-2-订阅主题"><a href="#3-2-订阅主题" class="headerlink" title="3.2 订阅主题"></a>3.2 订阅主题</h3><p>支持指定名称或正则匹配</p><ul><li>指定名称：传入 Topic 名称列表<ul><li>特点：消费者组内协调分区分配，支持负载均衡</li></ul></li><li>正则匹配：匹配动态 Topic 名称<ul><li>特点：自动订阅新创建的匹配主题，无需手动维护列表；对于新增主题，会触发一次 Rebalance</li></ul></li></ul><h3 id="3-3-轮询拉取数据"><a href="#3-3-轮询拉取数据" class="headerlink" title="3.3 轮询拉取数据"></a>3.3 轮询拉取数据</h3><p>开启一个无限循环，使用<code>poll()</code>方法拉取消息</p><ul><li><code>poll()</code>方法返回一个记录列表：包含消息归属的 Topic、Partition、Offset 以及键值对</li><li><font color="red" bold=""><u>实际上，查找组协调器、加入群组、接受分区分配、Rebalance、发送心跳等全过程都是在这个循环中完成的</u></font></li></ul><h3 id="3-4-提交-Offset"><a href="#3-4-提交-Offset" class="headerlink" title="3.4 提交 Offset"></a>3.4 提交 Offset</h3><p><code>poll()</code>方法总是返回还没有被当前消费者读取过的记录，需要消费者主动提交 Offset，维护消费进度。</p><p>消费者往<code>__consumer_offsets</code>发送消息，其中包含每个分区的 Offset</p><h4 id="3-4-1-consumer-offsets"><a href="#3-4-1-consumer-offsets" class="headerlink" title="3.4.1 __consumer_offsets"></a>3.4.1 <code>__consumer_offsets</code></h4><p><code>__consumer_offsets</code> 是一个特殊的内部主题，用于持久化存储消费者组的<strong>消费位移（Offset）</strong>和其他元数据，直接影响消息消费的可靠性、故障恢复能力和负载均衡行为</p><ul><li><p>核心作用</p><ul><li>位移持久化：记录消费者组在每个分区的消费进度，确保消费者重启或故障后能继续从正确位置消费</li><li>消费者组协调：存储消费者组的元数据（如成员列表、分区分配方案），支持消费者组的动态扩缩容（Rebalance）</li><li>幂等性保障：与 Kafka 事务机制结合，支持 Exactly-Once 语义（通过事务性位移提交）</li></ul></li><li><p>存储结构</p><ul><li><p>默认分区数：50（由 <code>offsets.topic.num.partitions</code> 控制）</p></li><li><p>默认保留时间：7 天（由 <code>offsets.retention.ms</code> 控制）</p></li><li><p>日志压缩策略：启用 Compact 策略，仅保留每个键（Key）的最新值</p></li><li><p>消息格式：</p><ul><li>Key</li></ul><pre><code>Key = [GroupID, Topic, Partition]</code></pre><ul><li>Value</li></ul><pre><code>Value = {    offset: int64,          // 提交的位移值    metadata: string,       // 用户自定义元数据（如应用上下文）    commit_timestamp: int64,// 提交时间戳（用于保留策略）    expire_timestamp: int64 // 位移过期时间（由 `offsets.retention.ms` 控制）}</code></pre></li></ul></li></ul><img src="../images/kafka-进阶篇/image-20250420162502264.png" alt="__consumer_offsets" style="zoom:40%;"><h4 id="3-4-2-提交策略"><a href="#3-4-2-提交策略" class="headerlink" title="3.4.2 提交策略"></a>3.4.2 提交策略</h4><table><thead><tr><th align="center"><strong>策略</strong></th><th>介绍</th><th align="center">可靠性</th><th align="center">吞吐量</th><th align="center">复杂度</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">自动提交</td><td>消费者定期提交最大的 Offset，sarama <code>Consumer.Offsets.AutoCommit</code>默认 1 秒/次</td><td align="center">低</td><td align="center">高</td><td align="center">低</td><td align="center">日志采集、监控数据</td></tr><tr><td align="center">手动同步提交</td><td>代码显示调用<code>commitSync()</code>,会阻塞请求，等待提交结果</td><td align="center">高</td><td align="center">中</td><td align="center">中</td><td align="center">金融交易、计费系统</td></tr><tr><td align="center">手动异步提交</td><td>代码显示调用<code>commitAsync()</code></td><td align="center">中</td><td align="center">高</td><td align="center">高</td><td align="center">高吞吐且允许短暂不一致</td></tr><tr><td align="center">事务提交</td><td>结合 Kafka 事务 API，将消息消费与 Offset 提交绑定为原子操作，实现 Exactly-Once 语义。</td><td align="center">最高</td><td align="center">低</td><td align="center">最高</td><td align="center">跨系统原子操作（Exactly-Once）</td></tr></tbody></table><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Kafka权威指南</p><p>[2] 深入理解Kafka：核心设计与实践原理</p><p>[3] <a href="https://learn.conduktor.io/kafka/kafka-producers">kafka-producers</a></p><p>[4] <a href="https://blog.det.life/apache-kafka-producer-db3b177f65d2?gi=ce43bf5466d8">Apache Kafka — Producer</a></p><p>[5] <a href="https://belowthemalt.com/2020/12/07/kafka-producer-api-internals/">Kafka Producer API Internals</a></p><p>[6] <a href="https://blog.csdn.net/u013256816/article/details/80300225">Kafka 消息格式的演变</a></p><p>[7] <a href="https://mp.weixin.qq.com/s?__biz=MjM5NDEzNjU3OA==&amp;mid=2648467500&amp;idx=1&amp;sn=6a9ba39adb9d1137666a24272b5bbc78&amp;chksm=bf09e9540a91084a95ab3e40aaedfa4461ec6bbb8f5225bd63ba16e9dda9e27d2b898ad4428f#rd">Go sarama Kafka Producer</a></p><p>[8] <a href="https://juejin.cn/post/7306756690728419354">golang中使用kafka的综合指南</a></p><p>[9] <a href="https://www.lixueduan.com/posts/kafka/06-sarama-producer/">sarama 客户端 producer 源码分析(优质博主！)</a></p><p>[10] <a href="https://www.lixueduan.com/posts/kafka/08-compression/">生产者压缩算法详解及源码分析</a></p><p>[11] <a href="https://developer.confluent.io/courses/architecture/broker/"><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Inside the Apache Kafka Broker <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 墙裂推荐！</a></p><p>[12] <a href="https://www.cnblogs.com/payapa/p/15401357.html">sarama的消费者组分析、使用 </a></p><p>[13] <a href="https://blog.csdn.net/m0_45406092/article/details/118470052">Kafka消费者组三种分区分配策略</a></p><p>[14] <a href="https://mp.weixin.qq.com/s?__biz=MzU1NjYyMDE5OA==&amp;mid=2247484691&amp;idx=1&amp;sn=5827a5aa36a2cd87ec23bf81d7c346b1&amp;chksm=fa2d6671e94a199963a14f451926ad66bc9a9066e45d4937767e45d80e8becdd43140feff45b#rd">Kafka消费者分区分配策略详解</a></p><p>[15] <a href="https://medium.com/streamthoughts/understanding-kafka-partition-assignment-strategies-and-how-to-write-your-own-custom-assignor-ebeda1fc06f3">Understanding Kafka partition assignment strategies</a></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka-入门篇</title>
      <link href="/posts/d451c14b.html"/>
      <url>/posts/d451c14b.html</url>
      
        <content type="html"><![CDATA[<h1 id="kafka-入门篇"><a href="#kafka-入门篇" class="headerlink" title="kafka-入门篇"></a>kafka-入门篇</h1><h2 id="1-三大特性"><a href="#1-三大特性" class="headerlink" title="1. 三大特性"></a>1. 三大特性</h2><table><thead><tr><th>特性</th><th>描述</th><th>保障机制</th></tr></thead><tbody><tr><td>高性能</td><td>实现每秒百万级消息处理能力</td><td>顺序读写、Reactor多路复用、零拷贝、批量压缩传输</td></tr><tr><td>高并发</td><td>通过分布式设计支持大规模并发访问</td><td>分区与并行化、消费者组、异步处理与多线程</td></tr><tr><td>高可用</td><td>通过冗余机制保障服务不间断</td><td>多副本、Leader选举、ISR、ACK</td></tr></tbody></table><h2 id="2-三大功能"><a href="#2-三大功能" class="headerlink" title="2. 三大功能"></a>2. 三大功能</h2><table><thead><tr><th>功能</th><th>描述</th><th>应用场景</th></tr></thead><tbody><tr><td>异步</td><td>生产者发送消息后无需等待消费者处理，通过<strong>非阻塞通信</strong>提高系统吞吐量和响应速度</td><td>文件处理任务、用户注册后异步发送邮件/短信</td></tr><tr><td>解耦</td><td>通过发布-订阅模型<strong>分离生产者和消费者</strong>，消除系统组件间的耦合</td><td>事件驱动系统</td></tr><tr><td>削峰</td><td>利用消息队列<strong>缓冲突发流量</strong>，平滑处理生产与消费速率差异，防止下游系统因瞬时高并发崩溃</td><td>电商秒杀/大促流量缓冲</td></tr></tbody></table><h2 id="3-重要概念"><a href="#3-重要概念" class="headerlink" title="3.重要概念"></a>3.重要概念</h2><h3 id="3-1-核心组件"><a href="#3-1-核心组件" class="headerlink" title="3.1 核心组件"></a>3.1 核心组件</h3><table><thead><tr><th>概念</th><th>简介</th></tr></thead><tbody><tr><td>Producer (生产者)</td><td>向 Broker 发送消息的客户端，支持异步批量发送、数据压缩及自定义分区策略（如 Key 哈希或轮询）</td></tr><tr><td>Consumer (消费者)</td><td>从 Broker 读取消息的客户端，支持按分区顺序消费或回溯（Offset），基于 Pull 模式主动拉取数据</td></tr><tr><td>Consumer Group (消费者组)</td><td>多个消费者组成的逻辑单元,组内每个消费者负责消费不同分区的数据，以<strong>提高消费能力</strong><br>组内消费者共享消费进度（Offset），<strong>每个分区仅由组内一个消费者消费</strong></td></tr><tr><td>Broker (物理节点)</td><td>负责存储消息、处理读写请求及副本同步<br>一台物理机器就是一个 Broker，一个 Broker 可以容纳多个 Topic</td></tr></tbody></table><img src="../images/kafka-入门篇/0*6FVLBloofcJp_RsF-4530203.png" alt="Producer-Broker-Consumer" style="zoom: 50%;"><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><ul><li><p>消息可靠性配置</p><ul><li><strong>性能优化</strong>：<ul><li>acks=0：不等待确认，最高吞吐但可能丢数据，适合日志采集等低可靠性场景。</li><li>acks=1：仅 Leader 确认，默认值，Leader 副本写入即响应，均衡吞吐与可靠性。</li><li>acks=all：全副本确认，需所有 ISR 副本确认，确保数据不丢失，适合金融等高要求场景。</li></ul></li><li>重试机制：设置 retries，配合 <code>retry.backoff.ms</code> 避免瞬态故障导致消息丢失</li></ul></li><li><p>性能优化</p><ul><li>批量发送：启用 <code>producer.type=async</code>，调整 <code>batch.size</code>（如 32KB）和 <code>linger.ms</code>（如 100ms）提升吞吐。</li><li>压缩策略：选用 <code>compression.type=lz4</code> 或 <code>snappy</code>，减少网络传输开销。</li><li>缓冲区管理：增大 <code>buffer.memory</code>（如 64MB）防止发送阻塞</li></ul></li><li><p>序列化与分区</p><ul><li>序列化器选择：明确指定 <code>key.serializer</code> 和 <code>value.serializer</code>，避免默认编码导致乱码。</li><li>自定义分区器：根据业务逻辑实现 <code>Partitioner</code>，避免数据倾斜（如按 Key 哈希分配）</li></ul></li></ul><h4 id="Consumer-amp-Consumer-Group"><a href="#Consumer-amp-Consumer-Group" class="headerlink" title="Consumer &amp; Consumer Group"></a>Consumer &amp; Consumer Group</h4><ul><li>组管理与容错<ul><li><strong>消费者数量</strong>：<code>消费者数 ≤ 分区数，超过时部分消费者闲置</code>，建议消费者数 = 分区数以最大化吞吐</li></ul></li><li>Rebalance<ul><li>触发条件：当消费者增减、分区数变化时，Kafka会触发一次重平衡操作，重新分配分区给群组中的消费者</li></ul></li><li>幂等消费<ul><li>去重机制：结合业务唯一键（如订单号）或数据库乐观锁（版本号）处理重复消息</li><li>死信队列：将处理失败的消息转入独立 Topic，便于人工干预或异步重试</li></ul></li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><ul><li>存储与性能<ul><li>磁盘优化：使用 SSD 或多磁盘路径（log.dirs）提升 IO 性能</li><li>日志清理：配置 log.retention.hours=72 或 log.retention.bytes=1GB 自动清理旧数据</li></ul></li></ul><hr><h3 id="3-2-消息组织"><a href="#3-2-消息组织" class="headerlink" title="3.2 消息组织"></a>3.2 消息组织</h3><table><thead><tr><th>概念</th><th>简介</th></tr></thead><tbody><tr><td>Message (消息)</td><td>数据传输的基本单元，类似于数据库中的一条记录，每条消息由 <strong>键（Key）</strong>、<strong>值（Value）</strong>、<strong>时间戳（Timestamp）</strong> 和可选元数据组成<br><strong>字节数组</strong>：消息本身是字节数组，无固定格式，支持任意类型数据（如 JSON）；<br><strong>键的作用</strong>：用于分区策略（如哈希分配），相同键的消息会被写入同一分区，保证顺序性； <br><strong>持久化</strong>：消息被追加到分区日志文件末尾，不可修改或删除，仅按时间或大小策略清理；</td></tr><tr><td>Topic (主题)</td><td><strong>消息的逻辑分类单元</strong>，类似数据库表，可以理解为一个消息队列的名字，生产者和消费者通过 Topic 交互</td></tr><tr><td>Partition (分区)</td><td>Topic 的物理分片，每个分区是一个有序、不可变的消息队列，分布在多个 Broker 上<br><strong>有序性</strong>：同一分区内的消息严格按写入<strong>顺序存储和消费</strong>；<br><strong>并行处理</strong>：多个分区允许消费者组内多个实例并行消费，提升吞吐量（如 10 分区的 Topic 可支持 10 倍并发）；<br><strong>副本机制</strong>：每个分区有 1 个 Leader（处理读写）和多个 Follower（同步备份），通过 ISR 机制（同步副本集）保障高可用。<br><strong>分片存储</strong>：每个 Partition 对应一组 <code>.log</code>（数据文件）和 <code>.index</code>（索引文件），支持高效二分查找</td></tr><tr><td>Offset (偏移量)</td><td>消息在分区中的唯一位置标识，单调递增且不可变<br><strong>消费定位</strong>：消费者通过 Offset 确定下次从何处开始消费，支持自动提交或手动提交记录Offset；<br><strong>存放位置</strong>：早期Offset存储在ZooKeeper，v0.9 开始 Offset 存储在 Kafka 内置 Topic __consumer_offsets 中，支持高频写入和持久化；</td></tr></tbody></table><img src="../images/kafka-入门篇/consumer-groups-4533447.png" alt="Topic-Partition-Offset" style="zoom:50%;"><h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><ul><li>顺序性与幂等处理<ul><li><strong>顺序性</strong>：<u><code>Kafka 仅保证同一分区内的消息顺序，跨分区的消息顺序无法保证</code></u>。若业务需要严格顺序（如订单状态变更），需通过消息 Key 路由到同一分区</li><li><strong>幂等性</strong>：生产者需开启 <code>enable.idempotence=true</code>，避免因网络重试导致重复消息；消费者需处理重复消费问题（如数据库去重或版本号校验）</li></ul></li><li>消息体优化<ul><li>大小限制：单条消息建议不超过 1MB，避免因大消息体导致磁盘 I/O 压力增大和网络传输延迟</li></ul></li><li>异常处理机制<ul><li>重试策略：生产端配置 retries 参数（建议 ≥3），消费端结合异步重试队列（如 Kafka 死信队列）处理失败消息</li></ul></li></ul><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><ul><li>分区与副本规划<ul><li>分区数：根据吞吐量需求设置，通常建议为 <strong>Broker 数量的整数倍</strong>（如 3 倍）。过多的分区会增加文件句柄和磁盘I/O压力以及内存占用</li><li>副本数：至少设置 3 副本（<code>replication.factor=3</code>），结合 <code>min.insync.replicas=2</code> 提升容错能力</li></ul></li><li>生命周期管理<ul><li>数据保留策略：根据业务需求选择时间（<code>retention.ms</code>）或大小（<code>retention.bytes</code>）策略，避免磁盘耗尽</li><li>清理策略：若需保留 Key 最新状态（如用户配置更新），启用 <code>log.cleanup.policy=compact</code></li></ul></li><li>命名与分类<ul><li>命名规范：Topic 名称需具有业务语义（如 <code>order-events</code>），避免使用泛化名称（如 <code>test</code>）</li></ul></li></ul><h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><ul><li>负载均衡与路由策略<ul><li>均匀分配：通过 Key 哈希（默认）或轮询策略写入分区，避免单个分区数据倾斜导致积压。</li><li>动态扩容：增加分区时需同步扩展消费者组，否则新分区可能无消费者处理</li></ul></li></ul><h4 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h4><ul><li>提交策略<ul><li>自动提交：设置 <code>enable.auto.commit=true</code> 和 <code>auto.commit.interval.ms</code>（默认 5 秒），适合低延迟场景，但可能导致重复消费。</li><li>手动提交：关闭自动提交，通过 <code>commitSync()</code> 或 <code>commitAsync()</code> 精确控制提交时机（如批处理完成后），确保“至少一次”语义</li></ul></li></ul><hr><h3 id="3-3-副本机制"><a href="#3-3-副本机制" class="headerlink" title="3.3 副本机制"></a>3.3 副本机制</h3><table><thead><tr><th>概念</th><th>简介</th></tr></thead><tbody><tr><td>Replica (副本)</td><td>保障数据高可用性和容错性的核心设计，每个 Topic 的 Partition 可以配置多个副本，这些副本分布在不同的 Broker 上，形成冗余备份</td></tr><tr><td>ISR (In-Sync Replicas，同步副本集)</td><td>动态维护的与 Leader 保持同步的副本集合，包含 Leader 自身和同步的 Follower 副本</td></tr><tr><td>OSR (Out-of-Sync Replicas，非同步副本集)</td><td>滞后于 Leader 的副本集合，与 ISR 共同构成分区的全量副本集合（AR，Assigned Replicas）</td></tr><tr><td>HW (High Watermark，高水位)</td><td>标识已提交消息的最大偏移量，消费者仅能读取 HW 之前的消息。HW 由 ISR 中最小的 LEO 决定</td></tr><tr><td>LEO (Log End Offset，日志末端偏移)</td><td>当前分区最新消息的偏移量，反映副本的实时写入进度</td></tr></tbody></table><img src="../images/kafka-入门篇/Replica-ISR.png" alt="Replica-ISR" style="zoom: 33%;"><img src="../images/kafka-入门篇/HW-LEO.png" alt="HW-LEO" style="zoom: 67%;"><h4 id="Replica"><a href="#Replica" class="headerlink" title="Replica"></a>Replica</h4><ul><li>两类副本<ul><li><strong>Leader</strong>：每个分区的唯一主副本，负责处理所有读写请求。生产者将消息写入 Leader，消费者从 Leader 读取消息</li><li><strong>Follower</strong>：从 Leader 异步拉取数据并同步到本地日志，不处理客户端请求。唯一任务是保持与 Leader 的数据同步，并在 Leader 故障时参与选举成为新 Leader</li></ul></li><li>Replication Factor 副本因子<ul><li>表示每个分区的数据副本数量。例如，副本因子为 3 时，每个分区的数据会存储到 3 个不同 Broker 上</li></ul></li></ul><h4 id="AR-ISR-OSR"><a href="#AR-ISR-OSR" class="headerlink" title="AR (ISR + OSR)"></a>AR (ISR + OSR)</h4><ul><li><p>同步判定条件：Follower 副本需在<code>replica.lag.time.max.ms</code>时间内追上 Leader 的日志偏移量（LEO），否则会被移出ISR（归入OSR），恢复同步后重新加入</p></li><li><p>ISR</p><ul><li>数据一致性：生产者在<code>acks=all</code>模式下需等待 ISR 中所有副本确认写入，确保消息提交后不会丢失</li><li>故障容错：Leader 故障时，优先从 ISR 中选举新 Leader，避免数据不一致</li></ul></li><li><p>OSR</p><ul><li><strong>数据备份</strong>：OSR 副本可作为数据恢复的”最后防线”，当 ISR 副本全部故障时，尝试从 OSR 恢复数据</li></ul></li></ul><hr><h3 id="3-4-存储结构"><a href="#3-4-存储结构" class="headerlink" title="3.4 存储结构"></a>3.4 存储结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><ul><li>Topic：逻辑上的消息分类单位</li><li>Partition：<code>Kafka存储的基本物理单位</code>，每个Topic被划分为多个Patition</li></ul><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p>每个Partition对应一个独立的日志文件，消息按顺序追加写入</p><ul><li>分区的意义<ul><li>水平扩展：将数据分布到多个 Broker，提升并发处理能力。</li><li>顺序写入优化：仅追加写（Append-Only），充分利用磁盘顺序 I/O 的高性能</li></ul></li></ul><h6 id="Segment-分段"><a href="#Segment-分段" class="headerlink" title="Segment (分段)"></a>Segment (分段)</h6><ul><li>每个分区的日志被切分为多个 <strong>Segment 文件</strong>，避免单个文件过大（默认 1GB）</li><li>每个 Segment 包含：<ul><li><code>.log</code>文件：存储<strong>实际消息数据</strong>，按消息偏移量（Offset）顺序写入</li><li><code>.index</code>文件：<strong>稀疏索引</strong>，记录消息偏移量与物理位置的映射关系，加速查询</li><li><code>.timeindex</code>文件：<strong>基于时间戳的索引</strong>，支持按时间范围检索消息</li></ul></li><li>分段示例</li></ul><pre class="line-numbers language-txt"><code class="language-txt">topic-name-0/  ├── 00000000000000000000.log        # 实际消息数据  ├── 00000000000000000000.index      # 稀疏矩阵  └── 00000000000000000000.timeindex  # 基于时间戳的索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="../images/kafka-入门篇/segment.png" alt="存储分层结构" style="zoom: 90%;"><h6 id="Index-索引"><a href="#Index-索引" class="headerlink" title="Index (索引)"></a>Index (索引)</h6><ul><li>稀疏索引设计<ul><li>仅记录部分消息的偏移量（如每 100 条消息），通过二分查找快速定位目标消息所在的 Segment，再顺序扫描细化位置。</li><li>优点：<strong>减少索引文件大小，避免内存占用过高，同时兼顾查询效率</strong></li></ul></li></ul><img src="../images/kafka-入门篇/log-index-mapping.png" alt="日志结构" style="zoom: 20%;"><h4 id="存储优化技术"><a href="#存储优化技术" class="headerlink" title="存储优化技术"></a>存储优化技术</h4><ul><li><p>顺序写入与页缓存（PageCache）</p><ul><li>顺序写入：仅追加写日志文件，避免磁盘随机寻址，机械磁盘吞吐量可达数百 MB/s。</li><li>页缓存：利用操作系统缓存机制，将磁盘数据预读至内存，减少直接 I/O 操作。</li></ul></li><li><p>零拷贝（Zero-Copy）</p><ul><li>数据从磁盘文件直接传输到网络设备（NIC），绕过用户态与内核态多次拷贝，降低 CPU 开销与延迟。</li></ul></li><li><p>日志清理机制</p><ul><li>基于时间：自动删除超过保留时长（如 7 天）的 Segment。</li><li>基于空间：限制分区总大小，超出时删除旧数据。</li><li>日志压缩（Compaction）：保留相同 Key 的最新 Value，适用于状态更新场景</li></ul></li></ul><hr><h3 id="3-5-元数据与协调服务"><a href="#3-5-元数据与协调服务" class="headerlink" title="3.5 元数据与协调服务"></a>3.5 元数据与协调服务</h3><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>元数据是 Kafka 集群运行的基础信息，包括以下内容：</p><ul><li><strong>集群基础信息</strong><ul><li>Broker 节点列表：记录所有 Broker 的 IP、端口、ID 及角色（如 Controller）。</li><li>Topic 与 Partition 定义：每个 Topic 的分区数、副本分布（Leader/Follower）、ISR 列表（同步副本集）。</li><li>消费者组状态：Consumer Group 的成员信息、消费偏移量（Offset）及分区分配策略。</li></ul></li><li><strong>动态运行时数据</strong><ul><li>Partition 的 Leader 信息：由协调服务动态维护，用于消息路由。</li><li>消费者偏移量 Offset 管理：记录消费者消费进度，确保故障恢复后从正确位置继续消费。</li></ul></li><li><strong>元数据存储方式</strong><ul><li>ZooKeeper 模式（旧版）：元数据存储在 ZooKeeper 的 /brokers、/consumers 等节点中。</li><li>KRaft 模式（新版，Kafka 2.8+）：元数据由 Kafka 自身通过 Raft 协议管理，存储在内部 Topic __cluster_metadata 中，不再依赖 ZooKeeper。</li></ul></li></ul><h4 id="协调服务"><a href="#协调服务" class="headerlink" title="协调服务"></a>协调服务</h4><p>协调服务负责维护元数据一致性及集群动态管理，核心功能如下：</p><ul><li>ZooKeeper 协调机制（旧版）<ul><li>Broker 注册与选举：Broker 启动时向 ZooKeeper 注册，通过临时节点（/brokers/ids）监控节点存活状态。Controller 节点（由 ZooKeeper 选举）负责分区 Leader 选举。</li><li>消费者组管理：消费者通过 ZooKeeper 协调分区分配（如 ConsumerRebalanceListener），Offset 默认存储在 ZooKeeper 的 /consumers 路径（Kafka 0.9 后改为内部 Topic __consumer_offsets）。</li><li>负载均衡：动态调整 Partition 分布，响应 Broker 增减或故障。</li></ul></li><li>KRaft 协调机制（新版）<ul><li>Raft 协议实现一致性：Controller 节点通过 Raft 协议选举 Leader，所有元数据变更需多数派确认后提交到日志（Log），确保多节点状态一致。</li><li>事件驱动架构：Broker 订阅 KRaft 日志，根据事件（如 Partition 分配变更）更新本地元数据缓存，实现最终一致性。</li><li>性能优化：KRaft 模式下，元数据操作吞吐量显著提升（如 200 万分区场景下性能优于 ZooKeeper），且运维复杂度降低。</li></ul></li></ul><h2 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h2><h3 id="4-1-环境搭建"><a href="#4-1-环境搭建" class="headerlink" title="4.1 环境搭建"></a>4.1 环境搭建</h3><p>通过 docker 快速启动 kafka 以及可视化操作平台，执行 <code>docker-compose up -d</code></p><ul><li>3个broker节点</li><li>1个zookeeper节点</li><li>1个kafka-ui节点</li></ul><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">zookeeper</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> bitnami/zookeeper<span class="token punctuation">:</span><span class="token number">3.8</span>    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> zookeeper    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"2181:2181"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>         <span class="token punctuation">-</span> ./zookeeper<span class="token punctuation">:</span>/bitnami/zookeeper    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">ALLOW_ANONYMOUS_LOGIN</span><span class="token punctuation">:</span> <span class="token string">"yes"</span> <span class="token comment" spellcheck="true"># 允许匿名登录</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> kafka_network  <span class="token key atrule">kafka01</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> bitnami/kafka<span class="token punctuation">:</span><span class="token number">3.6</span>    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> kafka01    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"9092:9092"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>         <span class="token punctuation">-</span> ./kafka01<span class="token punctuation">:</span>/bitnami/kafka    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">KAFKA_CFG_NODE_ID</span><span class="token punctuation">:</span> <span class="token number">1 </span><span class="token comment" spellcheck="true"># Broker唯一标识符</span>      <span class="token key atrule">KAFKA_CFG_ZOOKEEPER_CONNECT</span><span class="token punctuation">:</span> zookeeper<span class="token punctuation">:</span><span class="token number">2181 </span><span class="token comment" spellcheck="true"># 连接zookeeper集群</span>      <span class="token key atrule">KAFKA_CFG_ADVERTISED_LISTENERS</span><span class="token punctuation">:</span> PLAINTEXT<span class="token punctuation">:</span>//kafka01<span class="token punctuation">:</span><span class="token number">9092 </span><span class="token comment" spellcheck="true"># Broker监听客户端请求的协议、地址和端口</span>      <span class="token key atrule">KAFKA_CFG_LISTENERS</span><span class="token punctuation">:</span> PLAINTEXT<span class="token punctuation">:</span>//<span class="token punctuation">:</span><span class="token number">9092 </span><span class="token comment" spellcheck="true"># 向客户端公布的访问地址</span>      <span class="token key atrule">ALLOW_PLAINTEXT_LISTENER</span><span class="token punctuation">:</span> <span class="token string">"yes"</span> <span class="token comment" spellcheck="true"># 允许使用未加密的PLAINTEXT协议</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> zookeeper    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> kafka_network  <span class="token key atrule">kafka02</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> bitnami/kafka<span class="token punctuation">:</span><span class="token number">3.6</span>    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> kafka02    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"9093:9092"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>         <span class="token punctuation">-</span> ./kafka02<span class="token punctuation">:</span>/bitnami/kafka    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">KAFKA_CFG_NODE_ID</span><span class="token punctuation">:</span> <span class="token number">2</span>      <span class="token key atrule">KAFKA_CFG_ZOOKEEPER_CONNECT</span><span class="token punctuation">:</span> zookeeper<span class="token punctuation">:</span><span class="token number">2181</span>      <span class="token key atrule">KAFKA_CFG_ADVERTISED_LISTENERS</span><span class="token punctuation">:</span> PLAINTEXT<span class="token punctuation">:</span>//kafka02<span class="token punctuation">:</span><span class="token number">9092</span>      <span class="token key atrule">KAFKA_CFG_LISTENERS</span><span class="token punctuation">:</span> PLAINTEXT<span class="token punctuation">:</span>//<span class="token punctuation">:</span><span class="token number">9092</span>      <span class="token key atrule">ALLOW_PLAINTEXT_LISTENER</span><span class="token punctuation">:</span> <span class="token string">"yes"</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> zookeeper    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> kafka_network  <span class="token key atrule">kafka03</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> bitnami/kafka<span class="token punctuation">:</span><span class="token number">3.6</span>    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> kafka03    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"9094:9092"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>         <span class="token punctuation">-</span> ./kafka03<span class="token punctuation">:</span>/bitnami/kafka    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">KAFKA_CFG_NODE_ID</span><span class="token punctuation">:</span> <span class="token number">3</span>      <span class="token key atrule">KAFKA_CFG_ZOOKEEPER_CONNECT</span><span class="token punctuation">:</span> zookeeper<span class="token punctuation">:</span><span class="token number">2181</span>      <span class="token key atrule">KAFKA_CFG_ADVERTISED_LISTENERS</span><span class="token punctuation">:</span> PLAINTEXT<span class="token punctuation">:</span>//kafka03<span class="token punctuation">:</span><span class="token number">9092</span>      <span class="token key atrule">KAFKA_CFG_LISTENERS</span><span class="token punctuation">:</span> PLAINTEXT<span class="token punctuation">:</span>//<span class="token punctuation">:</span><span class="token number">9092</span>      <span class="token key atrule">ALLOW_PLAINTEXT_LISTENER</span><span class="token punctuation">:</span> <span class="token string">"yes"</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> zookeeper    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> kafka_network  <span class="token key atrule">kafka-ui</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> provectuslabs/kafka<span class="token punctuation">-</span>ui    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> kafka<span class="token punctuation">-</span>ui    <span class="token key atrule">ports</span><span class="token punctuation">:</span>       <span class="token punctuation">-</span> <span class="token string">"8080:8080"</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">DYNAMIC_CONFIG_ENABLED</span><span class="token punctuation">:</span> <span class="token string">'true'</span>      <span class="token key atrule">KAFKA_CLUSTERS_0_NAME</span><span class="token punctuation">:</span> kafka<span class="token punctuation">-</span>cluster      <span class="token key atrule">KAFKA_CLUSTERS_0_BOOTSTRAP_SERVERS</span><span class="token punctuation">:</span> kafka01<span class="token punctuation">:</span><span class="token number">9092</span><span class="token punctuation">,</span>kafka02<span class="token punctuation">:</span><span class="token number">9093</span><span class="token punctuation">,</span>kafka03<span class="token punctuation">:</span><span class="token number">9094 </span><span class="token comment" spellcheck="true"># 集群节点列表</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> kafka01      <span class="token punctuation">-</span> kafka02      <span class="token punctuation">-</span> kafka03    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> kafka_network<span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">kafka_network</span><span class="token punctuation">:</span>    <span class="token key atrule">driver</span><span class="token punctuation">:</span> bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-创建-Topic"><a href="#4-2-创建-Topic" class="headerlink" title="4.2 创建 Topic"></a>4.2 创建 Topic</h3><img src="../images/kafka-入门篇/image-20250413213830852.png" alt="创建Topic" style="zoom: 40%;"><table><thead><tr><th>参数</th><th>说明</th><th>注意</th></tr></thead><tbody><tr><td>Topic Name</td><td>主题名，用于区分不同的数据流</td><td>命名需清晰反映业务用途</td></tr><tr><td>Number of Partitions</td><td>分区数，分区数量决定数据并行处理能力，直接影响吞吐量上限<br></td><td>分区数应与消费者组内消费者数量匹配<br>分区过多会增加文件句柄和内存开销</td></tr><tr><td>Cleanup policy</td><td>控制过期数据的清理策略，支持<code>delete</code>（删除）和<code>compact</code>（压缩）</td><td>1.<code>delete</code>策略：按时间（<code>log.retention.hours</code>）或大小（<code>log.retention.bytes</code>）删除旧 Segment 文件。默认保留 7 天，适用于日志类无状态数据。<br>2.<code>compact</code>策略：保留每个 Key 的最新 Value，适合维护终态（如用户配置、账户余额）。需确保消息包含 Key，否则策略无效。<br>3.<code>混合</code>策略：delete + compact 可同时启用，兼顾压缩活跃数据与清理过期 Segment</td></tr><tr><td>Min In Sync Replicas</td><td>生产者写入时需确认的最小同步副本数（ISR）</td><td>建议设为 <code>Replication Factor - 1</code>（如副本因子为 3，则设为 2）<br>若 ISR 数量不足，生产者会抛出 <code>NotEnoughReplicasException</code></td></tr><tr><td>Replication Factor</td><td>每个分区的副本数量，决定容错能力</td><td>生产环境推荐设为 3，容忍 2 个 Broker 故障<br><strong>副本数不得超过集群 Broker 总数，否则 Topic 创建失败</strong></td></tr><tr><td>Time to retain data</td><td>数据保留时间</td><td>删除策略下，Segment 文件按最大时间戳判断是否过期</td></tr><tr><td>Max size on disk</td><td>Topic 最大存储容量</td><td>若总大小超限，优先删除最旧 Segment，但实际删除可能延迟</td></tr><tr><td>Maximum message size in bytes</td><td>单条消息最大大小（默认 1MB）</td><td>若消息超限，生产者会抛出<code>RecordTooLargeException</code></td></tr></tbody></table><ul><li><strong>副本数(4) &gt; Broker数(3) ===&gt; Topic 创建失败</strong></li></ul><img src="../images/kafka-入门篇/image-20250413220540196.png" alt="副本数 大于 Broker数" style="zoom:40%;"><ul><li><strong>副本数(2) &lt; Broker数(3) ===&gt; Topic 创建成功</strong><ul><li>Replicas列，第一个绿色数字表示Leader所在的Broker</li></ul></li></ul><img src="../images/kafka-入门篇/image-20250413221039516.png" alt="Topic创建成功" style="zoom:40%;"><h3 id="4-3-生产-Message"><a href="#4-3-生产-Message" class="headerlink" title="4.3 生产 Message"></a>4.3 生产 Message</h3><img src="../images/kafka-入门篇/image-20250413221934486.png" alt="生产 Message" style="zoom:40%;"><p>发送消息时并不强制要求指定 Partition，生产者可根据业务需求选择是否显式指定。</p><ul><li>不指定 Partition 时的默认策略，Kafka 提供了多种自动分区分配策略：<ul><li><strong>基于 Key 的哈希分配（Key-Ordering）</strong><ul><li>若消息包含 Key，则通过 <strong>Murmur2 哈希算法</strong>对 Key 进行哈希计算，将相同 Key 的消息分配到同一 Partition，保证同一业务实体的消息顺序性。</li><li>适用场景：需顺序消费的场景（如订单状态更新、用户行为追踪）</li></ul></li><li><strong>轮询策略（Round-Robin）</strong><ul><li>若消息未指定 Partition 且无 Key，Kafka 默认按 <strong>轮询方式</strong> 将消息均匀分配到所有可用 Partition。</li><li>特点：负载均衡性好，适合高吞吐场景</li></ul></li><li><strong>粘性分区策略（Sticky Partitioning）</strong><ul><li>Kafka 2.4+ 引入的优化策略：在无 Key 且未指定 Partition 时，<strong>优先将消息批量填充到同一 Partition 的批次中</strong>，待批次满后切换至另一 Partition。</li><li>优势：减少未满批次数量，降低延迟并提升吞吐量</li></ul></li></ul></li></ul><h3 id="Broker-状态"><a href="#Broker-状态" class="headerlink" title="Broker 状态"></a>Broker 状态</h3><img src="../images/kafka-入门篇/image-20250413222753518.png" alt="Brokers" style="zoom:40%;"><ul><li>Broker ID 为 1 的节点是 Controller 节点，负责管理和维护集群状态</li><li>每个 Broker 上都有 1 个 Leader 副本，2 个在线的 Partition</li></ul><h3 id="Controller-选举"><a href="#Controller-选举" class="headerlink" title="Controller 选举"></a>Controller 选举</h3><ul><li>把 kafka01 容器下线，重新选举 kafka02 为新的 Controller</li></ul><img src="../images/kafka-入门篇/image-20250413223504449.png" alt="Controller Broker 下线" style="zoom:40%;"><ul><li>kafka01 重新上线，Controller依然是 kafka02</li></ul><img src="../images/kafka-入门篇/image-20250413223935353.png" alt="Broker 重新上线" style="zoom:40%;"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://kajalrawal.medium.com/kafka-broker-kafka-topic-consumer-and-record-flow-in-kafka-ec55104977b8">Kafka Broker, Kafka Topic, Consumer and Record Flow in Kafka</a></p><p>[2] <a href="https://ibm-cloud-architecture.github.io/refarch-eda/technology/kafka-consumers/">Kafka Consumers</a></p><p>[3] <a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;mid=2247488841&amp;idx=1&amp;sn=2ea884012493403ab45b450271708fc8&amp;chksm=cefb3c78f98cb56e4580cf8529bc8510df121786a8bf341a8660037cdb4f4cbb4925dc7fa616&amp;scene=178&amp;cur_album_id=2147576628053442561#rd">Kafka基础</a></p><p>[4] <a href="https://mp.weixin.qq.com/s?__biz=MzA5MTIyNjk1MA==&amp;mid=2247483730&amp;idx=1&amp;sn=6488c826d2000a49ab9b52836d9aab2d&amp;chksm=91c87bc659d8cdac97b8cdcefbe18c6f745ec88ef57f8ca24f986fbb2b7458c810ab2fbebf87#rd">Kafka软件Topic数量对性能的影响</a></p><p>[5] Kafka权威指南</p><p>[6] <a href="https://segmentfault.com/a/1190000021824942">Kafka文件存储机制</a></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言并发控制</title>
      <link href="/posts/7a1fa4f.html"/>
      <url>/posts/7a1fa4f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言并发控制"><a href="#Go语言并发控制" class="headerlink" title="Go语言并发控制"></a>Go语言并发控制</h1><blockquote><p>参考:<br>Go语言底层原理剖析 - 第17章 并发控制<br><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">Go语言设计与实现 - 6.2 同步原语与锁</a></p></blockquote><hr><p>在高并发场景下，必定涉及到协程之间的交流与并发控制。除了通道外，go语言还提供了context以及各种锁机制，下面逐一进行介绍。</p><br><br><h2 id="1-context"><a href="#1-context" class="headerlink" title="1. context"></a>1. context</h2><p>Go1.7中引入context包，使得父子协程之间可以进行交流，可以优雅地控制协程的退出。</p><h3 id="1-1-context使用方式"><a href="#1-1-context使用方式" class="headerlink" title="1.1 context使用方式"></a>1.1 context使用方式</h3><p>context是使用频率非常高的包，不仅Go源码中经常使用，很多Go编写的第三方包也有所使用。context一般作为接口的第一个参数传递超时信息，在Go源码中，net/http、net、sql包的使用方法如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// net/http</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">WithContext</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token operator">*</span>Request<span class="token comment" spellcheck="true">// sql</span><span class="token keyword">func</span> <span class="token punctuation">(</span>db <span class="token operator">*</span>DB<span class="token punctuation">)</span> <span class="token function">BeginTx</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> opts <span class="token operator">*</span>TxOptions<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Tx<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// net</span><span class="token keyword">func</span> <span class="token punctuation">(</span>d <span class="token operator">*</span>Dialer<span class="token punctuation">)</span> <span class="token function">DialContext</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> network<span class="token punctuation">,</span> address <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Conn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="1-2-context接口详解"><a href="#1-2-context接口详解" class="headerlink" title="1.2 context接口详解"></a>1.2 context接口详解</h3><h4 id="1-2-1-context接口结构"><a href="#1-2-1-context接口结构" class="headerlink" title="1.2.1 context接口结构"></a>1.2.1 context接口结构</h4><p><code>context.Context</code>本质是一个接口，提供了4种方法：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Context <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>    <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20220328/1648468559536-05c4145d-3397-4fd8-aaed-19e3e78e49eb-20220328233245645.png" alt="context-interface" style="zoom:67%;"><h4 id="1-2-2-context接口实现"><a href="#1-2-2-context接口实现" class="headerlink" title="1.2.2 context接口实现"></a>1.2.2 context接口实现</h4><p><code>context</code>只是一个接口，意味着需要有具体的实现。Go标准库对此进行了简单的实现，用户也可以按照接口定义的方法自己实现。<br>context包中定义了一个空的context类<code>emptyCtx</code>，本质是int别名，并对上述4种函数进行了实现。</p><pre class="line-numbers language-go"><code class="language-go">$GOPATH<span class="token operator">/</span>src<span class="token operator">/</span>context<span class="token operator">/</span>context<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token comment" spellcheck="true">// An emptyCtx is never canceled, has no values, and has no deadline. It is not</span><span class="token comment" spellcheck="true">// struct{}, since vars of this type must have distinct addresses.</span><span class="token keyword">type</span> emptyCtx <span class="token builtin">int</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Value</span><span class="token punctuation">(</span>key any<span class="token punctuation">)</span> any <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> e <span class="token punctuation">{</span>    <span class="token keyword">case</span> background<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"context.Background"</span>    <span class="token keyword">case</span> todo<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"context.TODO"</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">"unknown empty Context"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后声明了两个emptyCtx的对象：<code>background</code>&amp;<code>todo</code>，并提供相应的获取方式，妥妥的<code>单例模式-懒汉版本</code></p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>    background <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>emptyCtx<span class="token punctuation">)</span>    todo       <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>emptyCtx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Background returns a non-nil, empty Context. It is never canceled, has no</span><span class="token comment" spellcheck="true">// values, and has no deadline. It is typically used by the main function,</span><span class="token comment" spellcheck="true">// initialization, and tests, and as the top-level Context for incoming</span><span class="token comment" spellcheck="true">// requests.</span><span class="token keyword">func</span> <span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Context <span class="token punctuation">{</span>    <span class="token keyword">return</span> background<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// TODO returns a non-nil, empty Context. Code should use context.TODO when</span><span class="token comment" spellcheck="true">// it's unclear which Context to use or it is not yet available (because the</span><span class="token comment" spellcheck="true">// surrounding function has not yet been extended to accept a Context</span><span class="token comment" spellcheck="true">// parameter).</span><span class="token keyword">func</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Context <span class="token punctuation">{</span>    <span class="token keyword">return</span> todo<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用context.Background函数或context.TODO函数会返回最简单的context实现。context.Background函数一般作为根对象存在，其不可以退出，也不能携带值。要具体地使用context的功能，需要派生出新的context，配套的使用函数如下，其中前三个函数用于处理退出。</p><img src="/images/20220328/派生context配套函数.png" alt="派生context配套函数" style="zoom:67%;"><br><br><h3 id="1-3-context原理"><a href="#1-3-context原理" class="headerlink" title="1.3 context原理"></a>1.3 context原理</h3><p>context在很大程度上利用了通道在close时会通知所有监听它的协程这一特性来实现。每个派生出的子协程都会创建一个新的退出通道，组织好context之间的关系即可实现继承链上退出的传递，图17-2所示的三个协程中，关闭通道A会连带关闭调用链上的通道B、通道C。</p><img src="/images/20220328/context退出.png" alt="context退出" style="zoom:67%;"><p>前面也已经提到，context包中定义了结构体emptyCtx，emptyCtx什么内容都没有，其不可以被退出，也不能携带值。<br><code>background</code>和<code>todo</code>是emptyCtx的实例化对象，可以通过<code>context.Background</code>函数或<code>context.TODO</code>函数获取到，一般作为最初始的根对象。</p><h4 id="1-3-1-WithCancel"><a href="#1-3-1-WithCancel" class="headerlink" title="1.3.1 WithCancel"></a>1.3.1 WithCancel</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// WithCancel returns a copy of parent with a new Done channel. The returned</span><span class="token comment" spellcheck="true">// context's Done channel is closed when the returned cancel function is called</span><span class="token comment" spellcheck="true">// or when the parent context's Done channel is closed, whichever happens first.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Canceling this context releases resources associated with it, so code should</span><span class="token comment" spellcheck="true">// call cancel as soon as the operations running in this Context complete.</span><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> parent <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"cannot create context from nil parent"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    c <span class="token operator">:=</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当调用WithCancel函数时，会产生一个子context结构cancelCtx，并保留了父context的信息。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// newCancelCtx returns an initialized cancelCtx.</span><span class="token keyword">func</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> cancelCtx <span class="token punctuation">{</span>    <span class="token keyword">return</span> cancelCtx<span class="token punctuation">{</span>Context<span class="token punctuation">:</span> parent<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// A cancelCtx can be canceled. When canceled, it also cancels any children</span><span class="token comment" spellcheck="true">// that implement canceler.</span><span class="token keyword">type</span> cancelCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context    mu       sync<span class="token punctuation">.</span>Mutex            <span class="token comment" spellcheck="true">// protects following fields</span>    done     atomic<span class="token punctuation">.</span>Value          <span class="token comment" spellcheck="true">// of chan struct{}, created lazily, closed by first cancel call</span>    children <span class="token keyword">map</span><span class="token punctuation">[</span>canceler<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// set to nil by the first cancel call</span>    err      <span class="token builtin">error</span>                 <span class="token comment" spellcheck="true">// set to non-nil by the first cancel call</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>children字段保存当前context之后派生的子context的信息，每个context都会有一个新的done通道，这保证了子context的退出不会影响父context。</p><h4 id="1-3-2-WithTimeout"><a href="#1-3-2-WithTimeout" class="headerlink" title="1.3.2 WithTimeout"></a>1.3.2 WithTimeout</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Canceling this context releases resources associated with it, so code should</span><span class="token comment" spellcheck="true">// call cancel as soon as the operations running in this Context complete:</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//     func slowOperationWithTimeout(ctx context.Context) (Result, error) {</span><span class="token comment" spellcheck="true">//         ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)</span><span class="token comment" spellcheck="true">//         defer cancel()  // releases resources if slowOperation completes before timeout elapses</span><span class="token comment" spellcheck="true">//         return slowOperation(ctx)</span><span class="token comment" spellcheck="true">//     }</span><span class="token keyword">func</span> <span class="token function">WithTimeout</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WithTimeout函数只是对时间的一个封装，最终会调用WithDeadline函数。</p><h4 id="1-3-3-WithDeadline"><a href="#1-3-3-WithDeadline" class="headerlink" title="1.3.3 WithDeadline"></a>1.3.3 WithDeadline</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// WithDeadline returns a copy of the parent context with the deadline adjusted</span><span class="token comment" spellcheck="true">// to be no later than d. If the parent's deadline is already earlier than d,</span><span class="token comment" spellcheck="true">// WithDeadline(parent, d) is semantically equivalent to parent. The returned</span><span class="token comment" spellcheck="true">// context's Done channel is closed when the deadline expires, when the returned</span><span class="token comment" spellcheck="true">// cancel function is called, or when the parent context's Done channel is</span><span class="token comment" spellcheck="true">// closed, whichever happens first.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Canceling this context releases resources associated with it, so code should</span><span class="token comment" spellcheck="true">// call cancel as soon as the operations running in this Context complete.</span><span class="token keyword">func</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> d time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> parent <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"cannot create context from nil parent"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> cur<span class="token punctuation">,</span> ok <span class="token operator">:=</span> parent<span class="token punctuation">.</span><span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span><span class="token function">Before</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// The current deadline is already sooner than the new one.</span>        <span class="token keyword">return</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    c <span class="token operator">:=</span> <span class="token operator">&amp;</span>timerCtx<span class="token punctuation">{</span>        cancelCtx<span class="token punctuation">:</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">,</span>        deadline<span class="token punctuation">:</span>  d<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> c<span class="token punctuation">)</span>    dur <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>    <span class="token keyword">if</span> dur <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// deadline has already passed</span>        <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span>timer <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">AfterFunc</span><span class="token punctuation">(</span>dur<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WithDeadline函数先判断父context是否比当前设置的超时参数d先退出，如果是，那么子协程会随着父context的退出而退出，没有必要再设置定时器。然后创建一个新的context，初始化通道。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// propagateCancel arranges for child to be canceled when parent is.</span><span class="token keyword">func</span> <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> child canceler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    done <span class="token operator">:=</span> parent<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> done <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// parent is never canceled</span>    <span class="token punctuation">}</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>done<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">// parent is already canceled</span>        child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> p<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">parentCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// parent has already been canceled</span>            child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>err<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>children <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                p<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span>canceler<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span>        p<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>goroutines<span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">select</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>parent<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>child<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>propagateCancel函数会将子context加入父协程的children哈希表中，并开启一个定时器。当定时器到期时，会调用cancel方法关闭通道。</p><h4 id="1-3-4-WithValue"><a href="#1-3-4-WithValue" class="headerlink" title="1.3.4 WithValue"></a>1.3.4 WithValue</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// WithValue returns a copy of parent in which the value associated with key is</span><span class="token comment" spellcheck="true">// val.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Use context Values only for request-scoped data that transits processes and</span><span class="token comment" spellcheck="true">// APIs, not for passing optional parameters to functions.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// The provided key must be comparable and should not be of type</span><span class="token comment" spellcheck="true">// string or any other built-in type to avoid collisions between</span><span class="token comment" spellcheck="true">// packages using context. Users of WithValue should define their own</span><span class="token comment" spellcheck="true">// types for keys. To avoid allocating when assigning to an</span><span class="token comment" spellcheck="true">// interface{}, context keys often have concrete type</span><span class="token comment" spellcheck="true">// struct{}. Alternatively, exported context key variables' static</span><span class="token comment" spellcheck="true">// type should be a pointer or interface.</span><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val any<span class="token punctuation">)</span> Context <span class="token punctuation">{</span>    <span class="token keyword">if</span> parent <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"cannot create context from nil parent"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> key <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"nil key"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token operator">!</span>reflectlite<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"key is not comparable"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>valueCtx<span class="token punctuation">{</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// A valueCtx carries a key-value pair. It implements Value for that key and</span><span class="token comment" spellcheck="true">// delegates all other calls to the embedded Context.</span><span class="token keyword">type</span> valueCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context    key<span class="token punctuation">,</span> val any<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WithValue返回一个valueCtx结构体实例。</p><hr><br><br><h2 id="2-数据争用-data-race"><a href="#2-数据争用-data-race" class="headerlink" title="2. 数据争用 data race"></a>2. 数据争用 data race</h2><h3 id="2-1-两个例子"><a href="#2-1-两个例子" class="headerlink" title="2.1 两个例子"></a>2.1 两个例子</h3><p>数据争用（data race）在Go语言中指两个协程同时访问相同的内存空间，并且至少有一个写操作的情况。这种情况常常是并发错误的根源，也是最难调试的并发错误之一。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    count <span class="token operator">+=</span> <span class="token number">1</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三个协程共同访问了全局变量count，乍看之下可能没有问题，但是该程序其实是有数据争用的，count的结果也是不明确的。count+=1操作看起来是一条指令，但是对CPU来说，需要先读取count的值，执行+1操作，再将count的值写回内存。</p><p>再举一例，Go语言中的经典数据争用错误。如下伪代码所示，在hash表中，存储了我们希望存储到Redis数据库中的数据（data）。但是在Go语言使用range时，变量k是一个堆上地址不变的对象，该地址存储的值会随着range遍历而发生变化。如果此时我们将变量k的地址放入协程save，以提供并发存储而不堵塞程序，那么最后的结果可能是后面的数据覆盖前面的数据，同时导致一些数据不被存储，并且每一次执行完存储的数据也是不明确的。</p><img src="/images/20220328/数据争用.png" alt="数据争用" style="zoom:67%;"><br><h3 id="2-2-检测工具race"><a href="#2-2-检测工具race" class="headerlink" title="2.2 检测工具race"></a>2.2 检测工具race</h3><p>Go 1.1后提供了强大的检查工具race来排查数据争用问题。race可以使用在多个Go指令中，当检测器在程序中找到数据争用时，将打印报告。对于第一个例子：</p><pre class="line-numbers language-bash"><code class="language-bash">go run -race main.gooutput:<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>WARNING: DATA RACERead at 0x000100799880 by goroutine 8:  main.add<span class="token punctuation">(</span><span class="token punctuation">)</span>      /Users/xuxiangfei/Code/Demos/test_demos/main.go:11 +0x2cPrevious <span class="token function">write</span> at 0x000100799880 by goroutine 7:  main.add<span class="token punctuation">(</span><span class="token punctuation">)</span>      /Users/xuxiangfei/Code/Demos/test_demos/main.go:11 +0x40Goroutine 8 <span class="token punctuation">(</span>running<span class="token punctuation">)</span> created at:  main.main<span class="token punctuation">(</span><span class="token punctuation">)</span>      /Users/xuxiangfei/Code/Demos/test_demos/main.go:17 +0x38Goroutine 7 <span class="token punctuation">(</span>running<span class="token punctuation">)</span> created at:  main.main<span class="token punctuation">(</span><span class="token punctuation">)</span>      /Users/xuxiangfei/Code/Demos/test_demos/main.go:16 +0x2c<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>3Found 1 data race<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">exit</span> status 66<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>报错后输出的栈帧信息中能看出具体发生冲突的位置。Read at表明读取发生在main.go文件的第11行，而Previous write表明前一个写入也发生在main.go文件的第11行，从而非常快速地发现并定位数据争用问题。<br>竞争检测的成本因程序而异，对于典型的程序，内存使用量可能增加5～10倍，执行时间会增加2～20倍。</p><hr><br><br><h2 id="3-锁机制"><a href="#3-锁机制" class="headerlink" title="3. 锁机制"></a>3. 锁机制</h2><p>为了解决数据争用以及其他并发问题，Go语言提供了一系列的锁机制。</p><h3 id="3-1-原子锁"><a href="#3-1-原子锁" class="headerlink" title="3.1 原子锁"></a>3.1 原子锁</h3><p>所谓原子操作，就是“不可中断的一个或一系列操作”。对于2.1中的例子count+=1实际上并不是一个原子操作，读内存和写内存是两步原子操作。<br>需要有一种机制解决并发访问时数据冲突及内存操作乱序的问题，即提供一种原子性的操作。这通常依赖硬件的支持，例如X86指令集中的LOCK指令，对应Go语言中的<code>**sync/atomic**</code>包。下例使用了<code>atomic.AddInt64</code>函数将变量加1，这种原子操作不会发生并发时的数据争用问题。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync/atomic"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">var</span> count <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    atomic<span class="token punctuation">.</span><span class="token function">AddInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原子操作是底层最基础的同步保证，通过原子操作可以构建起许多同步原语，例如自旋锁、信号量、互斥锁等。</p><br><h3 id="3-2-自旋锁"><a href="#3-2-自旋锁" class="headerlink" title="3.2 自旋锁"></a>3.2 自旋锁</h3><p>在sync/atomic包中还有一个重要的操作—<code>CompareAndSwap</code>，与元素值进行对比并替换。使用该操作我们能够构建起<code>自旋锁</code>，只有获取该锁，才能执行区域中的代码。如下所示，使用一个for循环不断轮询原子操作，直到原子操作成功才获取该锁。<br>自旋锁会空转浪费资源，对系统对性能有很大的影响。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync/atomic"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">var</span> flag <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">var</span> count <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>flag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span>            atomic<span class="token punctuation">.</span><span class="token function">StoreInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>flag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="3-3-互斥锁"><a href="#3-3-互斥锁" class="headerlink" title="3.3 互斥锁"></a>3.3 互斥锁</h3><p>通过原子操作构建起的互斥锁，虽然高效而且简单，但是其并不是万能的。例如，当某一个协程长时间霸占锁，其他协程抢占锁时将无意义地消耗CPU资源。同时当有许多正在获取锁的协程时，可能有协程一直抢占不到锁。</p><h4 id="3-3-1-思想介绍"><a href="#3-3-1-思想介绍" class="headerlink" title="3.3.1 思想介绍"></a>3.3.1 思想介绍</h4><p>为了解决这种问题，操作系统的锁接口提供了<strong>终止与唤醒</strong>的机制，例如Linux中的pthread mutex，避免了频繁自旋造成的浪费。<br>在操作系统内部会构建起锁的等待队列，以便之后依次被唤醒。调用操作系统级别的锁会锁住整个线程使之无法运行，另外锁的抢占还会涉及线程之间的上下文切换。</p><h4 id="3-3-2-使用说明"><a href="#3-3-2-使用说明" class="headerlink" title="3.3.2 使用说明"></a>3.3.2 使用说明</h4><p>Go语言拥有比线程更加轻量级的协程，在协程的基础上实现了一种比传统操作系统级别的锁更加轻量级的互斥锁，其使用方式如下所示。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> count <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">var</span> m sync<span class="token punctuation">.</span>Mutex<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    count <span class="token operator">+=</span> <span class="token number">1</span>    m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sync.Mutex构建起了互斥锁，在同一时刻，只会有一个获取锁的协程继续执行，而其他的协程将陷入等待状态，这和自旋锁的功能是类似的，但是其提供了更加复杂的机制避免自旋锁的争用问题。</p><h4 id="3-3-3-实现原理"><a href="#3-3-3-实现原理" class="headerlink" title="3.3.3 实现原理"></a>3.3.3 实现原理</h4><h5 id="3-3-3-1-数据结构"><a href="#3-3-3-1-数据结构" class="headerlink" title="3.3.3.1 数据结构"></a>3.3.3.1 数据结构</h5><p>互斥锁是一种混合锁，其实现方式包含了自旋锁，同时参考了操作系统锁的实现。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// A Mutex is a mutual exclusion lock.</span><span class="token comment" spellcheck="true">// The zero value for a Mutex is an unlocked mutex.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// A Mutex must not be copied after first use.</span><span class="token keyword">type</span> Mutex <span class="token keyword">struct</span> <span class="token punctuation">{</span>    state <span class="token builtin">int32</span>    sema  <span class="token builtin">uint32</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sync.Mutex结构比较简单，其包含了表示当前锁状态的state及信号量sema。</p><ul><li>state：通过位图的形式存储了当前锁的状态，如图所示，其中包含锁是否为锁定状态、正在等待被锁唤醒的协程数量、两个和饥饿模式有关的标志。</li></ul><img src="/images/20220328/Mutex.png" alt="Mutex" style="zoom:67%;"><ul><li>sema：互质锁中实现的信号量。</li></ul><p>为了解决某一个协程可能长时间无法获取锁的问题，Go 1.9之后使用了饥饿模式。在饥饿模式下，unlock会唤醒最先申请加速的协程，从而保证公平。</p><h5 id="3-3-3-1-正常模式-amp-饥饿模式"><a href="#3-3-3-1-正常模式-amp-饥饿模式" class="headerlink" title="3.3.3.1 正常模式 &amp; 饥饿模式"></a>3.3.3.1 正常模式 &amp; 饥饿模式</h5><p>Mutex有两种模式：正常模式 与 饥饿模式</p><p><strong>正常模式</strong>：锁的等待者会按照先进先出的顺序获取锁。刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被“饿死”。</p><p><strong>饥饿模式</strong>：互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</p><h5 id="3-3-3-2-获取锁"><a href="#3-3-3-2-获取锁" class="headerlink" title="3.3.3.2 获取锁"></a>3.3.3.2 获取锁</h5><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Lock locks m.</span><span class="token comment" spellcheck="true">// If the lock is already in use, the calling goroutine</span><span class="token comment" spellcheck="true">// blocks until the mutex is available.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Fast path: grab unlocked mutex.</span>    <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mutexLocked<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> race<span class="token punctuation">.</span>Enabled <span class="token punctuation">{</span>            race<span class="token punctuation">.</span><span class="token function">Acquire</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Slow path (outlined so that the fast path can be inlined)</span>    m<span class="token punctuation">.</span><span class="token function">lockSlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20220328/获取互斥锁.png" alt="获取互斥锁" style="zoom: 67%;"><br><h3 id="3-4-读写锁"><a href="#3-4-读写锁" class="headerlink" title="3.4 读写锁"></a>3.4 读写锁</h3><h4 id="3-4-1-思想介绍"><a href="#3-4-1-思想介绍" class="headerlink" title="3.4.1 思想介绍"></a>3.4.1 思想介绍</h4><p>读写锁通过两种锁来实现，一种为读锁，另一种为写锁。当进行读取操作时，需要加读锁，而进行写入操作时需要加写锁。</p><table><thead><tr><th></th><th>读锁</th><th>写锁</th></tr></thead><tbody><tr><td>读锁</td><td>不互斥</td><td>互斥</td></tr><tr><td>写锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><ol><li>多个协程可以同时获得读锁并执行</li><li>如果此时有协程申请了写锁，那么该写锁会等待所有的读锁都释放后才能获取写锁继续执行</li><li>如果当前的协程申请读锁时已经存在写锁，那么读锁会等待写锁释放后再获取锁继续执行</li></ol><p>举个例子，哈希表并不是并发安全的，它只能够并发读取，并发写入时会出现冲突。一种简单的规避方式如下所示，可以在获取map中的数据时加入RLock读锁，在写入数据时使用Lock写锁。</p><h4 id="3-4-2-实现原理"><a href="#3-4-2-实现原理" class="headerlink" title="3.4.2 实现原理"></a>3.4.2 实现原理</h4><p>读写锁复用了互斥锁及信号量这两种机制。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// There is a modified copy of this file in runtime/rwmutex.go.</span><span class="token comment" spellcheck="true">// If you make any changes here, see if you should make them there.</span><span class="token comment" spellcheck="true">// A RWMutex is a reader/writer mutual exclusion lock.</span><span class="token comment" spellcheck="true">// The lock can be held by an arbitrary number of readers or a single writer.</span><span class="token comment" spellcheck="true">// The zero value for a RWMutex is an unlocked mutex.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// A RWMutex must not be copied after first use.</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// If a goroutine holds a RWMutex for reading and another goroutine might</span><span class="token comment" spellcheck="true">// call Lock, no goroutine should expect to be able to acquire a read lock</span><span class="token comment" spellcheck="true">// until the initial read lock is released. In particular, this prohibits</span><span class="token comment" spellcheck="true">// recursive read locking. This is to ensure that the lock eventually becomes</span><span class="token comment" spellcheck="true">// available; a blocked Lock call excludes new readers from acquiring the</span><span class="token comment" spellcheck="true">// lock.</span><span class="token keyword">type</span> RWMutex <span class="token keyword">struct</span> <span class="token punctuation">{</span>    w           Mutex  <span class="token comment" spellcheck="true">// held if there are pending writers</span>    writerSem   <span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// semaphore for writers to wait for completing readers</span>    readerSem   <span class="token builtin">uint32</span> <span class="token comment" spellcheck="true">// semaphore for readers to wait for completing writers</span>    readerCount <span class="token builtin">int32</span>  <span class="token comment" spellcheck="true">// number of pending readers</span>    readerWait  <span class="token builtin">int32</span>  <span class="token comment" spellcheck="true">// number of departing readers</span><span class="token punctuation">}</span><span class="token keyword">const</span> rwmutexMaxReaders <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>读锁加锁</strong><br>先通过原子操作将readerCount加1，如果readerCount≥0就直接返回，所以如果只有获取读取锁的操作，那么其成本只有一个原子操作。当readerCount&lt;0时，说明当前有写锁，当前协程将借助信号量陷入等待状态，如果获取到信号量则立即退出，没有获取到信号量时的逻辑与互斥锁的逻辑相似。</li><li><strong>读锁解锁</strong><br>如果当前没有写锁，则其成本只有一个原子操作并直接退出。<br>如果当前有写锁正在等待，则调用rUnlockSlow判断当前是否为最后一个被释放的读锁，如果是则需要增加信号量并唤醒写锁。</li><li><strong>写锁加锁</strong><br>调用Lock方法，必须先获取互斥锁，因为它复用了互斥锁的功能。接着readerCount减去rwmutexMaxReaders阻止后续的读操作。<br>但获取互斥锁并不一定能直接获取写锁，如果当前已经有其他Goroutine持有互斥锁的读锁，那么当前协程会加入全局等待队列并进入休眠状态，当最后一个读锁被释放时，会唤醒该协程。</li><li><strong>写锁解锁</strong><br>调用Unlock方法。将readerCount加上rwmutexMaxReaders，表示不会堵塞后续的读锁，依次唤醒所有等待中的读锁。当所有的读锁唤醒完毕后会释放互斥锁。</li></ol><br><h3 id="3-5-WaitGroup"><a href="#3-5-WaitGroup" class="headerlink" title="3.5 WaitGroup"></a>3.5 WaitGroup</h3><h4 id="3-5-1-使用方式"><a href="#3-5-1-使用方式" class="headerlink" title="3.5.1 使用方式"></a>3.5.1 使用方式</h4><p><code>sync.WaitGroup</code> 可以等待一组 Goroutine 的返回，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求：</p><pre class="line-numbers language-go"><code class="language-go">requests <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Request<span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>wg <span class="token operator">:=</span> <span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>requests<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> request <span class="token operator">:=</span> <span class="token keyword">range</span> requests <span class="token punctuation">{</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// res, err := service.call(r)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似于操作系统中的 <code>fork-in</code> 模式，<code>WaitGroup.Wait()</code> 会hang住，直到 <code>len(requests)</code> 个子协程全部 <code>Done()</code> 了。</p><h4 id="3-5-2-实现原理"><a href="#3-5-2-实现原理" class="headerlink" title="3.5.2 实现原理"></a>3.5.2 实现原理</h4><h5 id="3-5-2-1-数据结构"><a href="#3-5-2-1-数据结构" class="headerlink" title="3.5.2.1 数据结构"></a>3.5.2.1 数据结构</h5><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> WaitGroup <span class="token keyword">struct</span> <span class="token punctuation">{</span>    noCopy noCopy    state1 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">uint32</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>WaitGroup</code>结构体中只包含两个成员变量：</p><ul><li><code>noCopy</code> — 保证 <code>WaitGroup</code>不会被开发者通过再赋值的方式拷贝</li><li><code>state1</code> — 存储着状态和信号量；</li></ul><img src="/images/20220328/golang-waitgroup-state.png" alt="golang-waitgroup-state" style="zoom:67%;"><p><code>WaitGroup</code>对外暴露了三个方法：</p><ol><li><code>WaitGroup.Add</code></li><li><code>WaitGroup.Wait</code> </li><li><code>WaitGroup.Done</code> </li></ol><h5 id="3-5-2-2-WaitGroup-Add"><a href="#3-5-2-2-WaitGroup-Add" class="headerlink" title="3.5.2.2 WaitGroup.Add"></a>3.5.2.2 WaitGroup.Add</h5><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>wg <span class="token operator">*</span>WaitGroup<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>delta <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    statep<span class="token punctuation">,</span> semap <span class="token operator">:=</span> wg<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    state <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">AddUint64</span><span class="token punctuation">(</span>statep<span class="token punctuation">,</span> <span class="token function">uint64</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">)</span>    v <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span>state <span class="token operator">>></span> <span class="token number">32</span><span class="token punctuation">)</span>    w <span class="token operator">:=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>    <span class="token keyword">if</span> v <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"sync: negative WaitGroup counter"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> v <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> w <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>statep <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token punctuation">;</span> w <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> w<span class="token operator">--</span> <span class="token punctuation">{</span>        <span class="token function">runtime_Semrelease</span><span class="token punctuation">(</span>semap<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>WaitGroup.Add</code> 可以更新 <code>WaitGroup</code> 中的计数器 <code>counter</code>。虽然 <code>WaitGroup.Add</code> 方法传入的参数可以为负数，但是计数器只能是非负数，一旦出现负数就会发生程序崩溃。当调用计数器归零，即所有任务都执行完成时，才会通过 <code>sync.runtime_Semrelease</code> 唤醒处于等待状态的 Goroutine。</p><h5 id="3-5-2-3-WaitGroup-Wait"><a href="#3-5-2-3-WaitGroup-Wait" class="headerlink" title="3.5.2.3 WaitGroup.Wait"></a>3.5.2.3 WaitGroup.Wait</h5><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>wg <span class="token operator">*</span>WaitGroup<span class="token punctuation">)</span> <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    statep<span class="token punctuation">,</span> semap <span class="token operator">:=</span> wg<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        state <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint64</span><span class="token punctuation">(</span>statep<span class="token punctuation">)</span>        v <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span>state <span class="token operator">>></span> <span class="token number">32</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> v <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapUint64</span><span class="token punctuation">(</span>statep<span class="token punctuation">,</span> state<span class="token punctuation">,</span> state<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">runtime_Semacquire</span><span class="token punctuation">(</span>semap<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">+</span>statep <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"sync: WaitGroup is reused before previous Wait has returned"</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>WaitGroup.Add</code> 会在计数器大于 0 并且不存在等待的 Goroutine 时，调用 <code>runtime.sync_runtime_Semacquire</code>陷入睡眠。</p><p>当 <code>WaitGroup</code> 的计数器归零时，陷入睡眠状态的 Goroutine 会被唤醒，上述方法也会立刻返回。</p><h5 id="3-5-2-4-WaitGroup-Done"><a href="#3-5-2-4-WaitGroup-Done" class="headerlink" title="3.5.2.4 WaitGroup.Done"></a>3.5.2.4 WaitGroup.Done</h5><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Done decrements the WaitGroup counter by one.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>wg <span class="token operator">*</span>WaitGroup<span class="token punctuation">)</span> <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>WaitGroup.Done</code> 只是对 <code>WaitGroup.Add</code> 方法的简单封装，我们可以向 <code>sync.WaitGroup.Add</code> 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒等待的 Goroutine；</p><br><h3 id="3-6-Once"><a href="#3-6-Once" class="headerlink" title="3.6 Once"></a>3.6 Once</h3><h4 id="3-6-1-使用方式"><a href="#3-6-1-使用方式" class="headerlink" title="3.6.1 使用方式"></a>3.6.1 使用方式</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    o <span class="token operator">:=</span> <span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>Once<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        o<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"only once"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// only once</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <code>sync.Once</code>可以保证在 Go 程序运行期间的某段代码只会执行一次。</p><h4 id="3-6-2-实现原理"><a href="#3-6-2-实现原理" class="headerlink" title="3.6.2 实现原理"></a>3.6.2 实现原理</h4><h5 id="3-6-2-1-数据结构"><a href="#3-6-2-1-数据结构" class="headerlink" title="3.6.2.1 数据结构"></a>3.6.2.1 数据结构</h5><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Once <span class="token keyword">struct</span> <span class="token punctuation">{</span>    done <span class="token builtin">uint32</span>    m    Mutex<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>done: 标识代码块是否执行过</li><li>m: 互斥锁</li></ul><h5 id="3-6-2-2-Once-Do"><a href="#3-6-2-2-Once-Do" class="headerlink" title="3.6.2.2 Once.Do"></a>3.6.2.2 Once.Do</h5><p><code>Once.Do</code>是 <code>Once</code>结构体对外唯一暴露的方法，该方法会接收一个入参为空的函数：</p><ul><li>如果传入的函数已经执行过，会直接返回；</li><li>如果传入的函数没有执行过，会调用 <code>Once.doSlow</code>执行传入的函数：</li></ul><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>Once<span class="token punctuation">)</span> <span class="token function">Do</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>o<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        o<span class="token punctuation">.</span><span class="token function">doSlow</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>Once<span class="token punctuation">)</span> <span class="token function">doSlow</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    o<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> o<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> o<span class="token punctuation">.</span>done <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">defer</span> atomic<span class="token punctuation">.</span><span class="token function">StoreUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>o<span class="token punctuation">.</span>done<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>为当前 Goroutine 获取互斥锁；</li><li>执行传入的无入参函数；</li><li>运行延迟函数调用，将成员变量 <code>done</code> 更新成 1；</li></ol><h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><p>Go语言中的互斥锁算一种混合锁，结合了原子操作、自旋、信号量、全局哈希表、等待队列、操作系统级别锁等多种技术，实现相对复杂。<br>但是Go语言的锁相对于操作系统级别的锁<strong>更快</strong>，因为在大部分情况下锁的争用停留在用户态。在有些场景下使用锁更简单，会<strong>比通道有更清晰的语义表达</strong>，需要结合具体的场景使用。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go数据结构-channel</title>
      <link href="/posts/d59d13e1.html"/>
      <url>/posts/d59d13e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go数据结构-channel"><a href="#Go数据结构-channel" class="headerlink" title="Go数据结构-channel"></a>Go数据结构-channel</h1><blockquote><p>参考: Go语言底层原理剖析 - 第16章 通道于协程间通信</p></blockquote><br><br><h2 id="1-channel是干啥的"><a href="#1-channel是干啥的" class="headerlink" title="1. channel是干啥的"></a>1. channel是干啥的</h2><p>Go语言之父<a href="https://github.com/robpike">Rob Pike</a>有句名言：“Don’t communicate by sharing memory, share memory by communicating.”，即“不要通过共享内存来通信，要通过通信来共享内存。”。</p><img src="/images/20220327/joi3kf3.png" alt="Quotes by Rob Pike" style="zoom:67%;"><p><strong>通过共享内存来通信</strong>比较简单的方法就是，在内存中开辟一块空间，多个线程或者进程可以同时访问这块空间，直觉上会觉得这种方式非常方便，但是也一定会出现<strong>数据冲突</strong>。为了解决数据冲突，人们又发明了各种锁，而并发性能也会因此下降。</p><p><strong>通过通信来实现进程/线程/协程之间的交互</strong>给出了一个新的解决方案，其思想主要是：先提供一个或多个高性能队列，线程/进程/协程需要访问别人时，不能直接读写别人的数据，而要通过队列提出请求，然后在对方处理请求时再做相应处理。Go语言给这种方案提供了一个利器：channel！</p><p>channel即通道，是Go语言中<strong>进行协程间通信的数据结构</strong>，是进行并发编程的利器，也是Go语言遵循CSP并发编程模式的结果，这种模型最重要的思想是通过通道来传递消息。</p><hr><br><br><h2 id="2-channel如何使用"><a href="#2-channel如何使用" class="headerlink" title="2. channel如何使用"></a>2. channel如何使用</h2><h3 id="2-1-声明与初始化"><a href="#2-1-声明与初始化" class="headerlink" title="2.1 声明与初始化"></a>2.1 声明与初始化</h3><h4 id="2-1-1-声明"><a href="#2-1-1-声明" class="headerlink" title="2.1.1 声明"></a>2.1.1 声明</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> name <span class="token keyword">chan</span> T<span class="token comment" spellcheck="true">// name: channel的名称</span><span class="token comment" spellcheck="true">// chan T: channel的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>声明时可以用箭头 <code>&lt;-</code> 限制通道的读写：</p><ol><li><code>chan int</code> 表示通道可以读写int；</li><li><code>chan&lt;- int</code> 表示通道只能写入int；</li><li><code>&lt;-chan int</code> 表示通道只能读取int；</li></ol><p>一个还未初始化的通道会被预置为nil初始化的通道会被预置为nil，无法向通道中写入或读取任何数据。要对通道进行操作，需要使用make操作符，make会初始化通道，在内存中分配通道的空间。</p><h4 id="2-1-2-初始化"><a href="#2-1-2-初始化" class="headerlink" title="2.1.2 初始化"></a>2.1.2 初始化</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 无缓冲区</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 有缓冲区</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>初始化的通道可以设置其缓冲区的长度，默认为无缓冲区。</p><br><h3 id="2-2-读写数据"><a href="#2-2-读写数据" class="headerlink" title="2.2 读写数据"></a>2.2 读写数据</h3><p>Go语言设计者将箭头 <code>&lt;-</code> 作为操作符进行通道的读取和写入。</p><h4 id="2-2-1-读写无缓冲区通道"><a href="#2-2-1-读写无缓冲区通道" class="headerlink" title="2.2.1 读写无缓冲区通道"></a>2.2.1 读写无缓冲区通道</h4><p>对于无缓冲通道，能够向通道写入数据的前提是必须有另一个协程在读取通道。否则，当前的协程会陷入休眠状态，最终陷入死锁。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    c <span class="token operator">&lt;-</span> <span class="token number">100</span> <span class="token comment" spellcheck="true">// or &lt;- c</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// fatal error: all goroutines are asleep - deadlock!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>有读有写</strong></p><p>读取通道有两种返回值的形式，借助编译时将该形式转换为不同的处理函数。第1个返回值仍然为通道读取到的数据，第2个返回值为布尔类型，返回值为false代表当前通道已经关闭。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">sender</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> ok<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">sender</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>    c <span class="token operator">&lt;-</span> <span class="token number">100</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// hold住main协程</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 100 true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-读写有缓冲区通道"><a href="#2-2-2-读写有缓冲区通道" class="headerlink" title="2.2.2 读写有缓冲区通道"></a>2.2.2 读写有缓冲区通道</h4><p>对有缓存区的通道读/写数据，如果缓存区为空/缓存区满了，才会发生死锁。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// &lt;-c</span>  c <span class="token operator">&lt;-</span> <span class="token number">100</span>    c <span class="token operator">&lt;-</span> <span class="token number">100</span>    c <span class="token operator">&lt;-</span> <span class="token number">100</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="2-3-通道关闭"><a href="#2-3-通道关闭" class="headerlink" title="2.3 通道关闭"></a>2.3 通道关闭</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>    c <span class="token operator">&lt;-</span> <span class="token number">100</span>    <span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>    c <span class="token operator">&lt;-</span> <span class="token number">100</span> <span class="token comment" spellcheck="true">// panic: send on closed channel</span>    <span class="token operator">&lt;-</span>c <span class="token comment" spellcheck="true">// 正常</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在正常读取的情况下，通道返回的ok为true。通道在关闭时仍然会返回，但是data为其类型的零值，ok也变为了false。和通道读取不同的是，不能向已经关闭的通道中写入数据。</p><p>试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。</p><p>有两个协程正在等待通道中的数据，当main协程关闭通道后，两个协程都会收到通知。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"goroutine one:"</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"goroutine two:"</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// goroutine two: 0 false</span><span class="token comment" spellcheck="true">// goroutine one: 0 false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><br><br><h2 id="3-select多路复用"><a href="#3-select多路复用" class="headerlink" title="3. select多路复用"></a>3. select多路复用</h2><p>在实践中使用通道时，更多的时候会与select结合，因为时常会出现多个通道与多个协程进行通信的情况，我们当然不希望由于一个通道的读写陷入堵塞，影响其他通道的正常读写。select正是为了解决这一问题诞生的，select赋予了Go语言更加强大的功能。在使用方法上，select的语法类似switch，形式如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token keyword">default</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和switch不同的是，每个case语句都必须对应通道的读写操作。select语句会陷入堵塞，直到一个或多个通道能够正常读写才恢复。</p><p>需要注意的是，select在使用时有几个特性：</p><ol><li>select随机选择机制<br>当多个通道同时准备好执行读写操作时，select会选择哪一个case执行呢？答案是具有一定的随机性。</li><li>select堵塞与控制<br>如果select中没有任何的通道准备好，那么当前select所在的协程会永远陷入等待，直到有一个case中的通道准备好为止。在实践中，为了避免这种情况发生，有时会加上default分支。default分支的作用是当所有的通道都陷入堵塞时，正常执行default分支。</li><li>循环select<br>很多时候，我们不希望select执行完一个分支就退出，而是循环往复执行select中的内容，因此需要将for与select进行组合。</li><li>select与nil<br>一个为nil的通道，不管是读取还是写入都将陷入堵塞状态。当select语句的case对nil通道进行操作时，case分支将永远得不到执行。</li></ol><hr><br><br><h2 id="4-channel底层原理"><a href="#4-channel底层原理" class="headerlink" title="4. channel底层原理"></a>4. channel底层原理</h2><h3 id="4-1-hchan数据结构"><a href="#4-1-hchan数据结构" class="headerlink" title="4.1 hchan数据结构"></a>4.1 hchan数据结构</h3><p>通道在运行时是一个hchan结构体，存储了数据列表，等待读取和发送的协程列表等字段。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> hchan <span class="token keyword">struct</span> <span class="token punctuation">{</span>    qcount   <span class="token builtin">uint</span>           <span class="token comment" spellcheck="true">// total data in the queue</span>    dataqsiz <span class="token builtin">uint</span>           <span class="token comment" spellcheck="true">// size of the circular queue</span>    buf      unsafe<span class="token punctuation">.</span>Pointer <span class="token comment" spellcheck="true">// points to an array of dataqsiz elements</span>    elemsize <span class="token builtin">uint16</span>    closed   <span class="token builtin">uint32</span>    elemtype <span class="token operator">*</span>_type <span class="token comment" spellcheck="true">// element type</span>    sendx    <span class="token builtin">uint</span>   <span class="token comment" spellcheck="true">// send index</span>    recvx    <span class="token builtin">uint</span>   <span class="token comment" spellcheck="true">// receive index</span>    recvq    waitq  <span class="token comment" spellcheck="true">// list of recv waiters</span>    sendq    waitq  <span class="token comment" spellcheck="true">// list of send waiters</span>    <span class="token comment" spellcheck="true">// lock protects all fields in hchan, as well as several</span>    <span class="token comment" spellcheck="true">// fields in sudogs blocked on this channel.</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// Do not change another G's status while holding this lock</span>    <span class="token comment" spellcheck="true">// (in particular, do not ready a G), as this can deadlock</span>    <span class="token comment" spellcheck="true">// with stack shrinking.</span>    lock mutex<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20220327/hchan.png" alt="hchan" style="zoom:50%;"><p>对于有缓存的通道，存储在buf中的数据虽然是线性的数组，但是用数组和序号recvx、recvq模拟了一个环形队列。recvx可以找到从buf哪个位置获取通道中的元素，而sendx能够找到写入时放入buf的位置，而sendx能够找到写入时放入buf的位置。</p><img src="/images/20220327/buf.png" alt="buf" style="zoom:50%;"><p>当到达循环队列的末尾时，sendx会置为0，以防止其下一次写入0号位置，开始循环利用空间。这同样意味着，当前的通道中只能放入指定大小的数据。当通道中的数据满了后，再次写入数据将陷入等待，直到第0号位置被取出后，才能继续写入。</p><br><h3 id="4-2-初始化步骤"><a href="#4-2-初始化步骤" class="headerlink" title="4.2 初始化步骤"></a>4.2 初始化步骤</h3><p>初始化即给通道分配所需的内存：</p><ol><li>当分配大小为0时，只需要在内存中分配hchan结构体的大小即可；</li><li>当通道的元素中不包含指针时，连续分配hchan结构体大小+size元素大小；</li><li>当通道的元素中包含指针时，需要单独分配内存空间，因为当元素中包含指针时，需要单独分配空间才能正常进行垃圾回收。</li></ol><img src="/images/20220327/通道初始化.png" alt="通道初始化" style="zoom: 50%;"><br><h3 id="4-3-通道写入"><a href="#4-3-通道写入" class="headerlink" title="4.3 通道写入"></a>4.3 通道写入</h3><img src="/images/20220327/通道写入.png" alt="通道写入" style="zoom: 50%;"><br><h3 id="4-4-通道读取"><a href="#4-4-通道读取" class="headerlink" title="4.4 通道读取"></a>4.4 通道读取</h3><img src="/images/20220327/通道读取.png" alt="通道读取" style="zoom:50%;"><br><br>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 并发 </tag>
            
            <tag> channel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go协程-goroutine</title>
      <link href="/posts/5574edca.html"/>
      <url>/posts/5574edca.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go协程-goroutine"><a href="#Go协程-goroutine" class="headerlink" title="Go协程-goroutine"></a>Go协程-goroutine</h1><blockquote><p>参考<br>  Go语言底层原理剖析 - 第14、15章 协程</p></blockquote><hr><br><br><h2 id="1-协程基础"><a href="#1-协程基础" class="headerlink" title="1 协程基础"></a>1 协程基础</h2><h3 id="1-1-进程与线程"><a href="#1-1-进程与线程" class="headerlink" title="1.1 进程与线程"></a>1.1 进程与线程</h3><p>协程可以看作轻量的线程，因此为了深入理解协程，必须对进程、线程及上下文切换等概念有所了解。 </p><p>在计算机科学中，<strong>线程是可以由调度程序（通常是操作系统的一部分）独立管理的最小程序指令集</strong>，<strong>而进程是程序运行的实例</strong>。简单来说，<strong>线程是程序执行的基本单位，进程是资源管理的基本单位</strong>。<br>线程是进程的组成部分，一个进程可以包含多个线程，这些线程并发执行并共享进程的内存（例如全局变量）等资源。而进程之间相对独立，不同进程具有不同的内存地址空间、代表程序运行的机器码、进程状态、操作系统资源描述符等。</p><img src="/images/20220216/线程与进程的区别.png" alt="线程与进程的区别" style="zoom: 50%;"><br><h3 id="1-2-线程上下文切换"><a href="#1-2-线程上下文切换" class="headerlink" title="1.2 线程上下文切换"></a>1.2 线程上下文切换</h3><p>在多核CPU上，线程可以分布在多个CPU核心上，从而实现真正的并行处理。为了平衡每个线程能够被CPU处理的时间并最大化利用CPU资源，操作系统需要在适当的时间通过定时器中断（Timer Interrupt）、I/O设备中断、系统调用时执行上下文切换（Context Switch）。</p><p>当发生线程上下文切换时，需要从操作系统用户态转移到内核态，记录上一个线程的重要寄存器值（例如栈寄存器SP）、进程状态等信息，这些信息存储在操作系统线程控制块（Thread Control Block）中。当切换到下一个要执行的线程时，需要加载重要的CPU寄存器值，并从内核态转移到操作系统用户态。​</p><br><h3 id="1-3-线程与协程"><a href="#1-3-线程与协程" class="headerlink" title="1.3 线程与协程"></a>1.3 线程与协程</h3><p>一般来说，协程被认为是轻量级的线程。下面从调度方式、上下文切换的速度、调度策略、栈的大小这四个方面分析线程与协程的不同。</p><h4 id="1-3-1-调度方式"><a href="#1-3-1-调度方式" class="headerlink" title="1.3.1 调度方式"></a>1.3.1 调度方式</h4><p>线程不同的是，协程是用户态的，操作系统内核感知不到协程的存在，协程的管理依赖Go语言运行时自身提供的调度器。Go语言中的协程是从属于某一个线程的，协程与线程的对应关系为M:N，即多对多。Go语言调度器可以将多个协程调度到一个线程中，一个协程也可能切换到多个线程中执行。</p><img src="/images/20220216/线程与协程的对应关系.png" alt="线程与协程的对应关系" style="zoom: 50%;"><h4 id="1-3-2-上下文切换的速度"><a href="#1-3-2-上下文切换的速度" class="headerlink" title="1.3.2 上下文切换的速度"></a>1.3.2 上下文切换的速度</h4><p>由于协程切换无须OS用户态和内核态的切换，只需要保留极少的状态和寄存器变量值（SP/BP/PC），而线程切换会保留额外的寄存器变量值（例如浮点寄存器），所以协程（0.2微秒）的速度要比线程快（1～2微秒）。</p><h4 id="1-3-3-调度策略"><a href="#1-3-3-调度策略" class="headerlink" title="1.3.3 调度策略"></a>1.3.3 调度策略</h4><p>线程的调度在大部分时间是抢占式的，操作系统调度器为了均衡每个线程的执行周期，会定时发出中断信号强制执行线程上下文切换。<br>而Go语言中的协程在一般情况下是协作式调度的，当一个协程处理完自己的任务后，可以主动将执行权限让渡给其他协程。这意味着协程可以更好地在规定时间内完成自己的工作，而不会轻易被抢占。当一个协程运行了过长时间时，Go语言调度器才会强制抢占其执行。</p><h4 id="1-3-4-栈的大小"><a href="#1-3-4-栈的大小" class="headerlink" title="1.3.4 栈的大小"></a>1.3.4 栈的大小</h4><p>线程的栈大小一般是在创建时指定的，为了避免出现栈溢出（Stack Overflow），默认的栈会相对较大（例如2MB）而且在运行时不能更改。<br>Go语言中的协程栈默认为2KB，在Go运行时的帮助下会动态检测栈的大小，并动态地进行扩容。</p><br><h3 id="1-4-并发与并行"><a href="#1-4-并发与并行" class="headerlink" title="1.4 并发与并行"></a>1.4 并发与并行</h3><p>并发指同时处理多个任务的能力，并不意味着同一时刻所有任务都在执行，而是在一个时间段内，所有的任务都能执行完毕。<br>并行指同时处理多个任务的状态，多核处理器是其必要条件。<br>由于Go语言中的协程依托于线程，所以即便处理器运行的是同一个线程，在线程内Go语言调度器也会切换多个协程执行，这时协程是并发的。如果多个协程被分配给了不同的线程，而这些线程同时被不同的CPU核心处理，那么这些协程就是并行处理的。</p><img src="/images/20220216/并发与并行的区别.png" alt="并发与并行的区别" style="zoom:50%;"><hr><br><br><h2 id="2-协程入门"><a href="#2-协程入门" class="headerlink" title="2 协程入门"></a>2 协程入门</h2><p>首先用一个例子来介绍如何使用协程，以及使用协程所带来的性能提升。</p><h3 id="2-1-协程实践"><a href="#2-1-协程实践" class="headerlink" title="2.1 协程实践"></a>2.1 协程实践</h3><h4 id="2-1-1-顺序执行"><a href="#2-1-1-顺序执行" class="headerlink" title="2.1.1 顺序执行"></a>2.1.1 顺序执行</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"net/http"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">var</span> links <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>    <span class="token string">"http://www.baidu.com"</span><span class="token punctuation">,</span>    <span class="token string">"http://www.jd.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://www.taobao.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://www.163.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://www.sohu.com"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">checkLink</span><span class="token punctuation">(</span>link <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">"  --> might be down!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">"  --> is up!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> link <span class="token operator">:=</span> <span class="token keyword">range</span> links <span class="token punctuation">{</span>        <span class="token function">checkLink</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 顺序执行</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"cost:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// http://www.baidu.com   --> is up!</span><span class="token comment" spellcheck="true">// http://www.jd.com   --> is up!</span><span class="token comment" spellcheck="true">// https://www.taobao.com   --> is up!</span><span class="token comment" spellcheck="true">// https://www.163.com   --> is up!</span><span class="token comment" spellcheck="true">// https://www.sohu.com   --> is up!</span><span class="token comment" spellcheck="true">// cost: 579.066375ms</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对5个url进行顺序请求，必须等待前一个请求执行完毕，后一个请求才能继续执行。<br>​</p><h4 id="2-1-1-并行执行"><a href="#2-1-1-并行执行" class="headerlink" title="2.1.1 并行执行"></a>2.1.1 并行执行</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"net/http"</span>    <span class="token string">"sync"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">var</span> links <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>    <span class="token string">"http://www.baidu.com"</span><span class="token punctuation">,</span>    <span class="token string">"http://www.jd.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://www.taobao.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://www.163.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://www.sohu.com"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">checkLink</span><span class="token punctuation">(</span>link <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">"  --> might be down!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">"  --> is up!"</span><span class="token punctuation">)</span>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> link <span class="token operator">:=</span> <span class="token keyword">range</span> links <span class="token punctuation">{</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token function">checkLink</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 并行执行</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"cost:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// http://www.baidu.com   --> is up!</span><span class="token comment" spellcheck="true">// https://www.sohu.com   --> is up!</span><span class="token comment" spellcheck="true">// https://www.163.com   --> is up!</span><span class="token comment" spellcheck="true">// http://www.jd.com   --> is up!</span><span class="token comment" spellcheck="true">// https://www.taobao.com   --> is up!</span><span class="token comment" spellcheck="true">// cost: 241.047917ms</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面对url并行请求，使用<code>waitgroup</code>控制子协程的<code>fork-in</code>，主协程需要等待子协程都完成才能退出。如果不使用<code>waitgroup</code>，主协程会直接退出并不会等待子协程。对比运行时间，并行执行要比顺序执行快得多。<br>​</p><hr><br><br><h2 id="3-协程进阶"><a href="#3-协程进阶" class="headerlink" title="3 协程进阶"></a>3 协程进阶</h2><h3 id="3-1-GMP模型"><a href="#3-1-GMP模型" class="headerlink" title="3.1 GMP模型"></a>3.1 GMP模型</h3><p>前面提到线程与协程之间是M:N的关系，GMP模型描述了协程是如何依托线程调度到CPU中执行的。</p><p>G代表的是Go语言中的协程（Goroutine），M代表的是实际的线程，而P代表的是Go逻辑处理器（Process）。Go语言为了方便协程调度与缓存，抽象出了逻辑处理器。</p><img src="/images/20220216/GMP模型.png" alt="GMP模型" style="zoom:50%;"><p>一个P可能在其本地包含多个G，同时，一个P在任一时刻只能绑定一个M。M与P、P与G之间并不是固定绑定的。</p><br><h3 id="3-2-协程调度-基础篇"><a href="#3-2-协程调度-基础篇" class="headerlink" title="3.2 协程调度-基础篇"></a>3.2 协程调度-基础篇</h3><h4 id="3-2-1-协程生命周期与状态转移"><a href="#3-2-1-协程生命周期与状态转移" class="headerlink" title="3.2.1 协程生命周期与状态转移"></a>3.2.1 协程生命周期与状态转移</h4><p>为了便于对协程进行管理，Go语言的调度器将协程分为多种状态。</p><img src="/images/20220216/协程的状态与转移.png" alt="协程的状态与转移" style="zoom: 67%;"><h4 id="3-2-2-g0协程与协程切换"><a href="#3-2-2-g0协程与协程切换" class="headerlink" title="3.2.2 g0协程与协程切换"></a>3.2.2 g0协程与协程切换</h4><p>每个线程中都有一个特殊的协程g0，协程g0运行在操作系统线程栈上，其作用主要是执行协程调度的一系列运行时代码，而一般的协程无差别地用于执行用户代码。</p><p>在用户协程退出或者被抢占时，意味着需要重新执行协程调度，这时需要从用户协程g切换到协程g0，g0再调度新的协程。g→g0→g的过程叫作协程的上下文切换，切换时需要保存执行现场，即三个寄存器：rsp、rip、rbp。rsp寄存器始终指向函数调用栈栈顶，rip寄存器指向程序要执行的下一条指令的地址，rbp存储了函数栈帧的起始位置。</p><img src="/images/20220216/g.gobuf.png" alt="g.gobuf" style="zoom: 50%;"><h4 id="3-2-3-线程绑定"><a href="#3-2-3-线程绑定" class="headerlink" title="3.2.3 线程绑定"></a>3.2.3 线程绑定</h4><p>线程本地存储的实际是结构体m中m.tls的地址，同时m.tls[0]会存储当前线程正在运行的协程g的地址，因此在任意一个线程内部，通过线程本地存储，都可以在任意时刻获取绑定到当前线程上的协程g、结构体m、逻辑处理器P、特殊协程g0等信息。</p><img src="/images/20220216/m.tls.png" alt="m.tls" style="zoom:50%;"><br><h3 id="3-3-协程调度-核心篇"><a href="#3-3-协程调度-核心篇" class="headerlink" title="3.3 协程调度-核心篇"></a>3.3 协程调度-核心篇</h3><h4 id="3-3-1-调度循环"><a href="#3-3-1-调度循环" class="headerlink" title="3.3.1 调度循环"></a>3.3.1 调度循环</h4><p>从协程g0调度到协程g，经历了从schedule函数到execute函数再到gogo函数的过程。</p><img src="/images/20220216/调度循环.png" alt="调度循环" style="zoom: 67%;"><h4 id="3-3-2-运行队列-全局-amp-局部"><a href="#3-3-2-运行队列-全局-amp-局部" class="headerlink" title="3.3.2 运行队列-全局&amp;局部"></a>3.3.2 运行队列-全局&amp;局部</h4><p>Go语言调度器将运行队列分为局部运行队列与全局运行队列。</p><p><strong>局部运行队列</strong>是每个P特有的长度为256的数组runq，该数组模拟了一个循环队列，其中runqhead标识了循环队列的开头，runqtail标识了循环队列的末尾。每次将G放入本地队列时，都从循环队列的末尾插入，而获取时从循环队列的头部获取。在每个P内部还有一个特殊的runnext字段，标识下一个要执行的协程。<br><strong>全局运行队列</strong>存储在schedt.runq中，被所有P共享。</p><img src="/images/20220216/改进后的GMP模型.png" alt="改进后的GMP模型" style="zoom: 33%;"><h4 id="3-3-3-调度过程"><a href="#3-3-3-调度过程" class="headerlink" title="3.3.3 调度过程"></a>3.3.3 调度过程</h4><img src="/images/20220216/调度协程的优先级与顺序.png" alt="调度协程的优先级与顺序" style="zoom:67%;"><h4 id="3-3-4-调度时机"><a href="#3-3-4-调度时机" class="headerlink" title="3.3.4 调度时机"></a>3.3.4 调度时机</h4><h5 id="3-3-4-1-主动调度"><a href="#3-3-4-1-主动调度" class="headerlink" title="3.3.4.1 主动调度"></a>3.3.4.1 主动调度</h5><p>协程可以选择主动让渡自己的执行权利，这主要是通过用户在代码中执行runtime.Gosched函数实现的。主动调度的原理比较简单，需要先从当前协程切换到协程g0，取消G与M之间的绑定关系，将G放入全局运行队列，并调用schedule函数开始新一轮的循环。</p><h5 id="3-3-4-2-被动调度"><a href="#3-3-4-2-被动调度" class="headerlink" title="3.3.4.2 被动调度"></a>3.3.4.2 被动调度</h5><p>被动调度指协程在休眠、channel通道堵塞、网络I/O堵塞、执行垃圾回收而暂停时，被动让渡自己执行权利的过程，可以保证最大化利用CPU资源。<br>和主动调度类似的是，被动调度需要先从当前协程切换到协程g0，更新协程的状态并解绑与M的关系，重新调度。和主动调度不同的是，被动调度不会将G放入全局运行队列，因为当前G的状态不是_Grunnable而是_Gwaiting，所以，被动调度需要一个额外的唤醒机制。</p><h5 id="3-3-4-3-抢占调度"><a href="#3-3-4-3-抢占调度" class="headerlink" title="3.3.4.3 抢占调度"></a>3.3.4.3 抢占调度</h5><p>为了让每个协程都有执行的机会，并且最大化利用CPU资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务。系统监控在一个独立的M上运行，不用绑定逻辑处理器P，系统监控每隔10ms会检测是否有准备就绪的网络协程，并放置到全局队列中。和抢占调度相关的是，系统监控服务会判断当前协程是否运行时间过长，或者处于系统调用阶段，如果是，则会抢占当前G的执行。其核心逻辑位于runtime.retake函数中。<br>​</p><p>To：信号强制抢占</p><br><br>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> goroutine </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/posts/43a71ae4.html"/>
      <url>/posts/43a71ae4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考<br><a href="https://www.bilibili.com/video/BV19y4y127h4?p=1">MySQL索引【编程不良人】</a><br>高性能MySQL第5章 - 创建高性能的索引<br><a href="https://www.cnblogs.com/lianzhilei/p/11250589.html">B树、B+树详解</a></p></blockquote><hr><h2 id="1-索引基础"><a href="#1-索引基础" class="headerlink" title="1. 索引基础"></a>1. 索引基础</h2><p>索引诞生的主要目的就是加速数据的查询，MySQL的索引类似于书的目录，通过目录可以快速找到页码，从而快速定位内容。除此之外，索引大大减少了机器需要扫描的数据量，可以将随机I/O变为顺序I/O。索引也是有缺点的：维护索引会消耗数据库资源包括空间资源和时间资源。</p><p>不同的数据库会在优缺点之间权衡，根据其适合的业务场景调整索引的结构。下面的介绍针对主流的MySQL的InnoDB引擎展开。</p><hr><br><h2 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2. 索引分类"></a>2. 索引分类</h2><p>常用的InnoDB引擎主要支持四种索引：</p><ul><li>主键索引</li><li>唯一索引</li><li>单值索引</li><li>复合索引</li></ul><h3 id="2-1-主键索引"><a href="#2-1-主键索引" class="headerlink" title="2.1 主键索引"></a>2.1 主键索引</h3><p>将某字段设置为主键后，数据库会对该主键自动建立索引。若不设置主键则不会自动建立主键索引。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 创建数据表，不设置主键 --</span><span class="token keyword">create</span> <span class="token keyword">table</span> user1<span class="token punctuation">(</span>    id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  age <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 查看主键 --</span><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> user1<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 创建数据表，设置主键 --</span><span class="token keyword">create</span> <span class="token keyword">table</span> user2<span class="token punctuation">(</span>    id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  age <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 查看主键 --</span><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> user2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/20220125/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png" alt="主键索引"></p><br><p><code>user1</code>没有设置主键，因此没有索引。<br><code>user2</code>设置主键为id，自动对id建立了主键索引。图中可以看到<code>Key_name</code>为<code>PRIMARY</code>表示这是一个主键索引。</p><br><h3 id="2-2-唯一索引"><a href="#2-2-唯一索引" class="headerlink" title="2.2 唯一索引"></a>2.2 唯一索引</h3><p>与主键索引相同的是<strong>索引列的值必须唯一</strong>，不同的是主键索引列不允许空值，而唯一索引列允许有空值。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 建表时创建唯一索引，unique(column_name1), unique(column_name2) ... --</span><span class="token keyword">create</span> <span class="token keyword">table</span> user1<span class="token punctuation">(</span>    id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  age <span class="token keyword">int</span><span class="token punctuation">,</span>  <span class="token keyword">unique</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 建表后创建唯一索引 --</span><span class="token keyword">create</span> <span class="token keyword">table</span> user2<span class="token punctuation">(</span>    id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  age <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">unique</span> <span class="token keyword">index</span> unique_user2 <span class="token keyword">on</span> user2<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 删除索引 --</span><span class="token keyword">drop</span> <span class="token keyword">unique</span> <span class="token keyword">index</span> 索引名 <span class="token keyword">on</span> 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/20220125/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95.png" alt="唯一索引"></p><p><br>通过<code>create unique index</code>语句创建索引，可以自定义索引的名称。索引列的值必须唯一，所以<code>Non_unique</code>为0。<br>​<br></p><h3 id="2-3-单值索引"><a href="#2-3-单值索引" class="headerlink" title="2.3 单值索引"></a>2.3 单值索引</h3><p>单值索引也称单列索引、普通索引。一个索引只包含单个列，一个表可以有多个单值索引。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 建表时创建单值索引，key(column_name1), key(column_name2) ... --</span><span class="token keyword">create</span> <span class="token keyword">table</span> user1<span class="token punctuation">(</span>    id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  age <span class="token keyword">int</span><span class="token punctuation">,</span>  <span class="token keyword">key</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 建表后创建单值索引 --</span><span class="token keyword">create</span> <span class="token keyword">table</span> user2<span class="token punctuation">(</span>    id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  age <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> index_user2 <span class="token keyword">on</span> user2<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 删除索引 --</span><span class="token keyword">drop</span> <span class="token keyword">index</span> 索引名 <span class="token keyword">on</span> 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/20220125/%E5%8D%95%E5%80%BC%E7%B4%A2%E5%BC%95.png" alt="单值索引"></p><p><br>通过<code>create index</code>语句创建索引，可以自定义索引的名称。索引列的值不用唯一，所以<code>Non_unique</code>为1。单值索引列允许为空，所以<code>Null</code>为YES。</p><br><h3 id="2-4-复合索引"><a href="#2-4-复合索引" class="headerlink" title="2.4 复合索引"></a>2.4 复合索引</h3><p>一个索引包含多个列。 </p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 建表时创建复合索引，key(column_name1, column_name2 ...) --</span><span class="token keyword">create</span> <span class="token keyword">table</span> user1<span class="token punctuation">(</span>    id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  age <span class="token keyword">int</span><span class="token punctuation">,</span>  <span class="token keyword">key</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 建表后创建复合索引 --</span><span class="token keyword">create</span> <span class="token keyword">table</span> user2<span class="token punctuation">(</span>    id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  age <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> index_user2 <span class="token keyword">on</span> user2<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 删除索引 --</span><span class="token keyword">drop</span> <span class="token keyword">index</span> 索引名 <span class="token keyword">on</span> 表名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/20220125/%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95.png" alt="复合索引"></p><p><br><code>Seq_in_index</code>表示索引列在索引中的顺序。<br>​<br></p><h4 id="2-4-1-最左前缀原则"><a href="#2-4-1-最左前缀原则" class="headerlink" title="2.4.1 最左前缀原则"></a>2.4.1 最左前缀原则</h4><p>创建复合索引时基于name和age字段，在查询时要遵循<strong>最左前缀原则</strong>，即必须复合最左前缀的顺序采用使用复合索引。 同时MySQL还做了一个优化，引擎在查询时为了更好利用索引，在查询过程中会动态调整查询字段顺序。<br>假设现在创建复合索引语句为：<code>create index index_name on user(name, age, tel)</code>，查询时：</p><ul><li>name age tel    可以利用索引，符合最左前缀原则</li><li>name tel age    可以利用索引，动态调整字段顺序后符合最左前缀原则</li><li>age tel               不可以利用索引</li><li>tel age name    可以利用索引，动态调整字段顺序后符合最左前缀原则</li><li>tel name            不可以利用索引</li></ul><hr><br><h2 id="3-索引底层原理"><a href="#3-索引底层原理" class="headerlink" title="3. 索引底层原理"></a>3. 索引底层原理</h2><p> 首先观察下面的例子，插入无序的数据。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">user</span><span class="token punctuation">(</span>    id <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  age <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Tim'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Andy'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'John'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">'Jodan'</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'Kobe'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20220125/有序输出.png" alt="有序输出" style="zoom:67%;"><p><br>在输出时，会按照主键的大小顺序输出。索引的底层实现决定了这种现象，下面介绍一下索引底层原理。<br></p><p>​<br></p><h3 id="3-1-B-树"><a href="#3-1-B-树" class="headerlink" title="3.1 B+树"></a>3.1 B+树</h3><p>MySQL 的 InnoDB 引擎使用 B+树 作为索引的数据结构，这是一种基于B树的改进。关于B-tree和B+tree的解释可以参考下面的博客。<br>B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接，形成一个链表。如下图所示，其高度为2，每页可存放4条记录，扇出（fan out）为5：</p><br><p><img src="/images/20220125/B+%E6%A0%91.png" alt="B+树"></p><p><br>B树的非叶子节点也可以存放数据，意味着每一页可放置的记录条数更少。当数据量很大时，B树的深度较大，查询时磁盘的I/O次数也会更多，进而会影响查询效率。<br>​</p><p>而B+树的数据是按照被索引字段，顺序存放在叶子节点的，非叶子节点只寸被索引字段和指针，可以放置的记录条数更多。上面例子中<code>select * from user</code>实际是对叶子结点链表的遍历，所以是顺序输出的。<br>在InnoDB存储引擎中，每个页的大小为16KB。B+树的高度一般都在2～4层，这意味着查找某一键值最多只需要2到4次IO操作，这还不错。因为现在一般的磁盘每秒至少可以做100次IO操作，2～4次的IO操作意味着查询时间只需0.02～0.04秒。<br><br><br></p><h3 id="3-2-聚簇索引-vs-非聚簇索引"><a href="#3-2-聚簇索引-vs-非聚簇索引" class="headerlink" title="3.2 聚簇索引 vs 非聚簇索引"></a>3.2 聚簇索引 vs 非聚簇索引</h3><ul><li><strong>聚簇索引</strong>：将索引与数据存储到一起，索引结构的叶子结点保存了行数据。聚簇索引指的不一定就是主键索引，但主键索引一定是聚簇索引。</li><li>**非聚簇索引(辅助索引)**：将索引与数据分开存储，索引结构的叶子结点指向了数据对应的位置。非聚簇索引存储的不再是行的物理位置，而是主键值，非聚簇索引访问数据总是需要二次查找。</li></ul><img src="/images/20220125/聚簇索引-非聚簇索引.png" alt="聚簇索引-非聚簇索引" style="zoom:67%;"><p><br><strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB会选择一个<strong>唯一且非空的索引</strong>代替。如果没有这样的索引，InnoDB会<strong>隐式定义一个主键</strong>（类似oracle中的Rowld)来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。<br>​</p><hr><br><h2 id="4-面试常见问题"><a href="#4-面试常见问题" class="headerlink" title="4. 面试常见问题"></a>4. 面试常见问题</h2><h3 id="4-1-聚簇索引需要注意什么？"><a href="#4-1-聚簇索引需要注意什么？" class="headerlink" title="4.1 聚簇索引需要注意什么？"></a>4.1 聚簇索引需要注意什么？</h3><ul><li>当使用主键为聚簇索引时，主键最好不要使用uuid，因为uuid的值太过离散，不适合排序且可能出现新增加记录的 uuid，会插入在索引树中间的位置，导致索引树调整复杂度变大，消耗更多的时间和资源。</li><li>建议使用int类型的自增，方便排序并且默认会在索引树的末尾增加主键值，对索引树的结构影响最小。而且，主键值占用的存储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间，也会影响到IO操作读取到的数据量。</li></ul><h3 id="4-2-为什么主键通常建议使用自增id？"><a href="#4-2-为什么主键通常建议使用自增id？" class="headerlink" title="4.2 为什么主键通常建议使用自增id？"></a>4.2 为什么主键通常建议使用自增id？</h3><ul><li>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</li></ul><h3 id="4-3-什么情况下无法利用索引呢？"><a href="#4-3-什么情况下无法利用索引呢？" class="headerlink" title="4.3 什么情况下无法利用索引呢？"></a>4.3 什么情况下无法利用索引呢？</h3><ul><li>查询语句中使用LIKE关键字<br>在查询语句中使用LIKE关键字进行查询时，如果匹配字符串的第一个字符为“%”，索引不会被使用。如果“%”不是在第一个位置，索引就会被使用。</li><li>查询语句中使用多列索引<br>多列索引是在表的多个字段上创建一个索引，只有查询条件中使用了这些字段中的第一个字段，索引才会被使用。</li><li>查询语句中使用OR关键字<br>查询语句只有OR关键字时，如果OR前后的两个条件的列都是索引，那么查询中将使用索引。如果OR前后有一个条件的列不是索引，那么查询中将不使用索引。</li></ul><br><br>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言项目布局</title>
      <link href="/posts/292214e3.html"/>
      <url>/posts/292214e3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言项目布局"><a href="#Go语言项目布局" class="headerlink" title="Go语言项目布局"></a>Go语言项目布局</h1><blockquote><p>参考<br><a href="https://github.com/golang-standards/project-layout">Golang项目布局开源项目-29.1K Stars</a><br>《Go语言精进之路》第二部分<br><a href="https://www.youtube.com/watch?v=oL6JBUk6tj0">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps</a></p></blockquote><hr><br><br><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在项目中，合理的布局会让项目更加清晰。随着项目的增长，保持良好的项目结构非常重要，否则最终会得到一团混乱的代码。为了便于开发者协作，最好使用通用的结构，下面这个开源项目中介绍了 Go 语言项目布局的最佳实践，目前有接近 3 万个 star，对我后续的开发还是有一定参考价值的。</p><p><a href="https://github.com/golang-standards/project-layout">https://github.com/golang-standards/project-layout</a></p><p>从 <code>Go 1.14</code>开始，建议Go项目使用<a href="https://github.com/golang/go/wiki/Modules">Go Modules</a> 进行依赖管理，用 <code>go.mod</code> 来记录特定的依赖信息。</p><hr><br><br><h2 id="2-Go语言自身结构"><a href="#2-Go语言自身结构" class="headerlink" title="2. Go语言自身结构"></a>2. Go语言自身结构</h2><p>作为 Go 语言的创世项目，Go 的项目结构的布局对后续的 Go 语言项目具有重要的参考意义。下面的结构基于 <code>Go 1.16</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ tree -LF 1 /usr/local/go/usr/local/go├── AUTHORS├── CONTRIBUTING.md├── CONTRIBUTORS├── LICENSE├── PATENTS├── README.md├── SECURITY.md├── VERSION├── api/├── bin/├── doc/├── favicon.ico├── lib/├── misc/├── pkg/├── robots.txt├── src/└── test/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>尤其是早期 Go 项目中 <code>src</code>目录下面的结构，更是在后续被 Go 社区作为 Go 应用项目结构的模板广泛使用。</p><ul><li>代码构建的脚本源文件放在 <code>src</code>下面的顶层目录下。</li><li><code>src</code>下的二级目录 <code>cmd</code>下面存放着 Go 工具链相关的可执行文件（比如 <code>go</code> 、 <code>gofmt</code>等）的主目录以及它们的 <code>main</code>包源文件。</li><li><code>src</code>存放着上面 <code>cmd</code>下各工具链程序依赖的包、Go 运行时以及 Go 标准库的源文件。</li><li><code>src</code>下面的二级目录 <code>internal</code>，用于存放无法被外部导入、仅 Go 项目自用的包。</li><li><code>src</code>下面的 <code>go.mod</code>和 <code>go.sum</code>，实现了 Go 项目自身的 <code>go module</code>迁移。Go项目内所有包被放到名为 <code>std</code>的 <code>module</code>下面，其依赖的包依然是 <code>golang.org/x</code>下的各个包。</li></ul><pre class="line-numbers language-bash"><code class="language-bash">$ tree -LF 1 /usr/local/go/src/usr/local/go/src├── Make.dist├── README.vendor├── all.bash*├── all.bat├── all.rc*├── archive/├── bootstrap.bash*├── bufio/├── buildall.bash*├── builtin/├── bytes/├── clean.bash*├── clean.bat├── clean.rc*├── cmd/├── cmp.bash├── compress/├── container/├── context/├── crypto/├── database/├── debug/├── embed/├── encoding/├── errors/├── expvar/├── flag/├── fmt/├── go/├── go.mod├── go.sum├── hash/├── html/├── image/├── index/├── internal/├── io/├── log/├── make.bash*├── make.bat├── make.rc*├── math/├── mime/├── net/├── os/├── path/├── plugin/├── race.bash*├── race.bat├── reflect/├── regexp/├── run.bash*├── run.bat├── run.rc*├── runtime/├── sort/├── strconv/├── strings/├── sync/├── syscall/├── testdata/├── testing/├── text/├── time/├── unicode/├── unsafe/└── vendor/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><br><br><h2 id="3-以构建二进制可执行文件为目的的-Go-项目结构"><a href="#3-以构建二进制可执行文件为目的的-Go-项目结构" class="headerlink" title="3. 以构建二进制可执行文件为目的的 Go 项目结构"></a>3. 以构建二进制可执行文件为目的的 Go 项目结构</h2><p>下图是一个支持（在 <code>cmd</code>下）构建二进制可执行文件的典型 Go 项目的结构。</p><img src="/images/20220124/项目结构.png" alt="项目结构" style="zoom:50%;"><ul><li><code>cmd目录</code>：项目的主干，存放项目要构建的可执行文件对应的 <code>main</code>包的源文件。如果有多个可执行文件需要构建，则将每个可执行文件的 <code>main</code>包单独放在一个子目录中，比如图中的 <code>app1、app2</code>。一些Go项目将 <code>cmd</code>这个名字改为 <code>app</code>，但其功能并没有变。<br>通常有一个小的&nbsp;<code>main</code>&nbsp;函数，从&nbsp;<code>/internal</code>&nbsp;和&nbsp;<code>/pkg</code>&nbsp;目录导入和调用代码。不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于&nbsp;<code>/pkg</code>&nbsp;目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到&nbsp;<code>/internal</code>&nbsp;目录中。</li><li><code>pkg目录</code>：该目录下的包可以被外部项目引用，算是项目导出包的一个聚合。对于一些规模稍大的项目，过多的包会让项目顶层目录不再简洁，显得很拥挤，因此对于复杂的 Go 项目建议保留 <code>pkg</code>目录。</li><li><code>internal目录</code>：对于不想暴露给外部引用，仅限项目内部使用的包，在项目结构上可以通过 Go 1.4 版本中引入的 <code>internal</code>包机制来实现。</li><li><code>go.mod</code>和 <code>go.sum</code>：Go 语言包依赖管理使用的配置文件。</li><li><code>Makefile</code>：项目构建工具所用脚本的“代表”，一般会放在 <code>build</code>目录下。</li></ul><hr><br><br><h2 id="4-通用应用目录"><a href="#4-通用应用目录" class="headerlink" title="4. 通用应用目录"></a>4. 通用应用目录</h2><ul><li><code>configs目录</code>：配置文件模板或默认配置。</li><li><code>init目录</code>：系统初始化文件目录。</li><li><code>scripts目录</code>：执行各种构建、安装、分析等操作的脚本。</li><li><code>build目录</code>：打包和持续集成。将你的云( AMI )、容器( Docker )、操作系统( deb、rpm、pkg )包配置和脚本放在&nbsp;<code>/build/package</code>&nbsp;目录下。将你的 CI (travis、circle、drone)配置和脚本放在&nbsp;<code>/build/ci</code>&nbsp;目录中。</li><li><code>test目录</code>：额外的外部测试应用程序和测试数据。</li></ul><hr><br><br><h2 id="5-其他目录"><a href="#5-其他目录" class="headerlink" title="5. 其他目录"></a>5. 其他目录</h2><ul><li><code>docs目录</code>：设计和用户文档(除了 <code>godoc</code> 生成的文档之外)。</li><li><code>tools目录</code>：这个项目的支持工具。注意，这些工具可以从&nbsp;<code>/pkg</code>&nbsp;和&nbsp;<code>/internal</code>&nbsp;目录导入代码。</li><li><code>examples目录</code>：应用程序和/或公共库的示例。</li><li><code>third_party目录</code> ：外部辅助工具，分叉代码和其他第三方工具(例如 Swagger UI)。</li></ul><p>可以根据项目需求合理添加其他目录结构。</p><p>注意：有些 Go 项目确实有一个&nbsp;<code>src</code>&nbsp;文件夹，但这通常发生在开发人员有 Java 背景，在那里它是一种常见的模式。如果可以的话，尽量不要采用这种 Java 模式。你真的不希望你的 Go 代码或 Go 项目看起来像 Java</p><br><br>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 工程技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 数据结构 - interface</title>
      <link href="/posts/31d1c6ce.html"/>
      <url>/posts/31d1c6ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go-数据结构-interface"><a href="#Go-数据结构-interface" class="headerlink" title="Go 数据结构 - interface"></a>Go 数据结构 - interface</h1><blockquote><p>参考<br>  <a href="https://www.liwenzhou.com/posts/Go/12_interface/">Go 语言基础之接口 - 李文周</a><br>  <a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/">Go 语言设计与实现接口 - 面向信仰编程</a><br>  <a href="https://qcrao91.gitbook.io/go/interface">Go 语言 interface - 码农桃花源</a><br>  《Go 语言底层原理》第 12 章</p></blockquote><hr><br><br><h2 id="1-接口概述"><a href="#1-接口概述" class="headerlink" title="1. 接口概述"></a>1. 接口概述</h2><img src="/images/20220118/接口.png" alt="接口" style="zoom: 67%;"><p>接口定义了一种规范，提供数据传输的渠道。不论是前后端交互的接口，还是程序设计中的接口，抑或是常用的 Type-A、Type-C 结构，只有符合接口的规范设计，才能让不同组件相互连接完成数据的传输。接口可以隔离底层的实现，用户只需要知道怎么用接口就行了。</p><br><h3 id="1-1-显式接口"><a href="#1-1-显式接口" class="headerlink" title="1.1 显式接口"></a>1.1 显式接口</h3><p>作为后端开发领域中的大哥大，Java 需要显示声明实现的接口。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> String hello <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterfaceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>MyInterface<span class="token punctuation">.</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>MyInterface</code> 接口中声明了 方法 <code>sayHello</code> 和 变量 <code>hello</code></p><p><code>MyInterfaceImpl</code> 类 使用 <code>implements</code> 关键字显式的声明实现了接口 <code>MyInterface</code></p><p>这是一种侵入式接口设计，实现类需要明确声明自己实现了某个接口。这也意味着对接口产生了依赖，当接口被删除时程序就无法运行，耦合度较高。</p><br><h3 id="1-2-隐式接口"><a href="#1-2-隐式接口" class="headerlink" title="1.2 隐式接口"></a>1.2 隐式接口</h3><p>Go 语言中接口的实现都是隐式的，只需实现接口中定义的方法，而无需显示的声明实现了该接口。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> MyInterface <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> MyInterfaceImpl <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m MyInterfaceImpl<span class="token punctuation">)</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>MyInterface</code> 接口中声明了 方法 <code>sayHello</code></p><p><code>MyInterfaceImpl</code> 结构体实现了 方法 <code>sayHello</code> ，但是没有显示的声明。</p><p>这是一种非侵入式接口设计，只需要实现接口的所有方法就叫实现了该接口，即便该接口删掉了也不会影响。(鸭子类型，只要实现了鸭子叫、鸭子跑方法，就可以认定它是鸭子)，耦合度很低。</p><hr><br><br><h2 id="2-接口实例"><a href="#2-接口实例" class="headerlink" title="2. 接口实例"></a>2. 接口实例</h2><h3 id="2-1-空接口-amp-带方法签名接口"><a href="#2-1-空接口-amp-带方法签名接口" class="headerlink" title="2.1 空接口 &amp; 带方法签名接口"></a>2.1 空接口 &amp; 带方法签名接口</h3><p>Go 语言中接口有两种类型，带方法签名的接口和空接口。</p><p>因为目前 <code>Go1.17</code> 前都没有范型，空接口作为伪范型用的非常多，如 <code>fmt</code> 中打印函数的入参都是空接口。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Empty</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token string">"xyz"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// xyz</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 123</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面介绍如何使用带方法签名的接口。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">type</span> Duck <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> Zhouhei <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>z Zhouhei<span class="token punctuation">)</span> <span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周黑鸭 walk..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>z Zhouhei<span class="token punctuation">)</span> <span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周黑鸭 quack..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> Jiujiu <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>j Jiujiu<span class="token punctuation">)</span> <span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"久久鸭 walk..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>j Jiujiu<span class="token punctuation">)</span> <span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"久久鸭 quack..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Duck interface 作为</span><span class="token keyword">func</span> <span class="token function">DuckWalk</span><span class="token punctuation">(</span>d Duck<span class="token punctuation">)</span> <span class="token punctuation">{</span>    d<span class="token punctuation">.</span><span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">DuckQuack</span><span class="token punctuation">(</span>d Duck<span class="token punctuation">)</span> <span class="token punctuation">{</span>    d<span class="token punctuation">.</span><span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    z <span class="token operator">:=</span> Zhouhei<span class="token punctuation">{</span><span class="token punctuation">}</span>    j <span class="token operator">:=</span> Jiujiu<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">DuckWalk</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 周黑鸭 walk...</span>    <span class="token function">DuckQuack</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 周黑鸭 quack...</span>    <span class="token function">DuckWalk</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 久久鸭 walk...</span>    <span class="token function">DuckQuack</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 久久鸭 quack...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是接口使用中很常见的例子， <code>Duck 接口 </code> 中定义了两个方法， <code>Zhouhei</code> 和 <code>Jiujiu</code> 两个结构体实现了这两个方法，即实现了 <code>Duck 接口 </code>。同时 <code>Duck 接口 </code> 作为 <code>DuckWalk</code> 和 <code>DuckQuack</code> 函数的入参，可以接收这两个结构体。</p><p>这种设计使得代码的扩展性比较高，如果再来一个结构体，只需实现接口中的方法即可通过 <code>DuckWalk</code> 和 <code>DuckQuack</code> 函数被调用。</p><br><h3 id="2-2-值接收者-amp-指针接收者"><a href="#2-2-值接收者-amp-指针接收者" class="headerlink" title="2.2 值接收者 &amp; 指针接收者"></a>2.2 值接收者 &amp; 指针接收者</h3><p>在结构体实现方法时，一般将结构体称为方法的接收者。接收者类型有两种： <code>值接收者</code> 和 <code>指针接收者</code>，上面例子中使用的就是值接收者。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// ============== 值接收 ===============</span><span class="token keyword">func</span> <span class="token punctuation">(</span>z Zhouhei<span class="token punctuation">)</span> <span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周黑鸭 walk..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span>z1 <span class="token operator">:=</span> Zhouhei<span class="token punctuation">{</span><span class="token punctuation">}</span>z2 <span class="token operator">:=</span> <span class="token operator">&amp;</span>Zhouhei<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">DuckWalk</span><span class="token punctuation">(</span>z1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 周黑鸭 walk...</span><span class="token function">DuckWalk</span><span class="token punctuation">(</span>z2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 周黑鸭 walk...</span><span class="token comment" spellcheck="true">// ============== 指针接收 ===============</span><span class="token keyword">func</span> <span class="token punctuation">(</span>z <span class="token operator">*</span>Zhouhei<span class="token punctuation">)</span> <span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周黑鸭 walk..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span>z1 <span class="token operator">:=</span> Zhouhei<span class="token punctuation">{</span><span class="token punctuation">}</span>z2 <span class="token operator">:=</span> <span class="token operator">&amp;</span>Zhouhei<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token function">DuckWalk</span><span class="token punctuation">(</span>z1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 报错</span><span class="token comment" spellcheck="true">// cannot use z1 (type Zhouhei) as type Duck in argument to DuckWalk:</span><span class="token comment" spellcheck="true">//   Zhouhei does not implement Duck (Walk method has pointer receiver)</span><span class="token function">DuckWalk</span><span class="token punctuation">(</span>z2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 周黑鸭 walk...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当接收者为值类型： <code>Zhouhei</code> 值对象和指针对象都可以赋值给该接口变量。<br>因为 Go 语言中有对指针类型变量求值的语法糖，通过指针可以获取到对象，指针 <code>&amp;Zhouhei{}</code> 内部会自动求值 <code>Zhouhei{}</code></li><li>当接收者为指针类型：值对象无法赋值给该接口变量。<br>因为值对象 <code>Zhouhei{}</code> 与方法接收者 指针对象 <code>*Zhouhei</code> 类型不一致</li></ul><br><p><strong>用值接收者还是指针接收者？</strong></p><ul><li>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；使用指针作为方法的接收者的理由：<ul><li>方法能够修改接收者指向的值。</li><li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li></ul></li><li>如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</li></ul><p>是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的 <code>本质</code>。</p><p>如果类型具备 “原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就 ** 定义值接收者类型的方法 **。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</p><p>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就 ** 定义指针接收者的方法 **。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份 <code>实体</code>。</p><br><h3 id="2-3-接口类型断言"><a href="#2-3-接口类型断言" class="headerlink" title="2.3 接口类型断言"></a>2.3 接口类型断言</h3><p>一个接口的值（简称接口值）是由 <code>一个具体类型</code> 和 <code>具体类型的值</code> 两部分组成的。这两部分分别称为接口的 <code>动态类型</code> 和 <code>动态值</code>。</p><img src="/images/20220118/类型断言.png" alt="类型断言" style="zoom: 33%;"><p>可以使用语法 <code>i.(Type)</code> 在运行时获取存储在接口中的动态值。其中 i 代表接口，Type 代表实现此接口的动态类型。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">type</span> Duck <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> Zhouhei <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>z Zhouhei<span class="token punctuation">)</span> <span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周黑鸭 walk..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>z Zhouhei<span class="token punctuation">)</span> <span class="token function">Quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"周黑鸭 quack..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> Jiujiu <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>j Jiujiu<span class="token punctuation">)</span> <span class="token function">Walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"久久鸭 walk..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> d Duck    d <span class="token operator">=</span> Jiujiu<span class="token punctuation">{</span><span class="token punctuation">}</span>    value <span class="token operator">:=</span> d<span class="token punctuation">.</span><span class="token punctuation">(</span>Zhouhei<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// cannot use Jiujiu{} (type Jiujiu) as type Duck in assignment:</span>    <span class="token comment" spellcheck="true">//   Jiujiu does not implement Duck (missing Quack method)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先声明一个接口变量作为 Jiujiu 对象的载体，然后通过类型断言语句判断是否为 Zhouhei 类型，产生错误信息：未实现 Quack 方法。</p><p>这种写法不够优雅，一般接口类型断言语句这样写: <code>value, ok := i.(Type)</code></p><p>断言语句经常会和 <code>switch</code> 一起用</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">check</span><span class="token punctuation">(</span>arg <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> f <span class="token operator">:=</span> arg<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bool"</span><span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token builtin">string</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"未识别类型"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">check</span><span class="token punctuation">(</span><span class="token string">"xyz"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// string</span>    <span class="token function">check</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// bool</span>    <span class="token function">check</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 未识别类型 123</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><br><br><h2 id="3-接口原理"><a href="#3-接口原理" class="headerlink" title="3. 接口原理"></a>3. 接口原理</h2><p>Go 语言根据接口类型是否包含一组方法将接口类型分成了两类：</p><ul><li>使用&nbsp;<code>runtime.iface</code>&nbsp;结构体表示包含方法的接口</li><li>使用&nbsp;<code>runtime.eface</code>&nbsp;结构体表示不包含任何方法的&nbsp;<code>interface{}</code>&nbsp;类型，它的结构也相对来说比较简单，只包含指向底层数据和类型的两个指针；</li></ul><img src="/images/20220118/接口结构体.png" alt="接口结构体" style="zoom:50%;"><p><code>data 字段 </code> 存储了接口中动态类型的函数指针。</p><p><code>tab 字段 </code> 存储了接口的类型、接口中的动态数据类型、动态数据类型的函数指针等。其类型为 <code>*itab</code>，这也是接口的核心。</p><img src="/images/20220118/itab结构体.png" alt="itab 结构体" style="zoom:50%;"><p><code>hash</code>&nbsp;是对&nbsp;<code>_type.hash</code>&nbsp;的拷贝，当我们想将&nbsp;<code>interface</code>&nbsp;类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型&nbsp;<code>runtime._type</code>&nbsp;是否一致；</p><p><code>fun</code>&nbsp;是一个动态大小的数组，它是一个用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以&nbsp;<code>fun</code>&nbsp;数组中保存的元素数量是不确定的</p><img src="/images/20220118/接口底层结构.png" alt="接口底层结构" style="zoom:50%;"><br><h3 id="3-1-类型结构体"><a href="#3-1-类型结构体" class="headerlink" title="3.1 类型结构体"></a>3.1 类型结构体</h3><p><code>itab</code> 中的 <code>_type 字段 </code> 代表接口存储的动态类型。Go 语言的各种数据类型都是在_type 字段的基础上通过增加额外字段来管理的。</p><p>下面是运行时包中的结构体，其中包含了很多类型的元信息，例如：类型的大小、哈希、对齐以及种类等。</p><img src="/images/20220118/type结构体.png" alt="_type结构体" style="zoom:50%;"><ul><li><code>size</code>&nbsp;字段存储了类型占用的内存空间，为内存空间的分配提供信息；</li><li><code>hash</code>&nbsp;字段能够帮助我们快速确定类型是否相等；</li><li><code>equal</code>&nbsp;字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从&nbsp;<code>typeAlg</code>&nbsp;结构体中迁移过来的；</li></ul><br><br>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 数据结构 - map</title>
      <link href="/posts/7e08620c.html"/>
      <url>/posts/7e08620c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go-数据结构-map"><a href="#Go-数据结构-map" class="headerlink" title="Go 数据结构 - map"></a>Go 数据结构 - map</h1><blockquote><p>参考<br>  《Go 语言底层原理剖析》第 8 章<br>  <a href="https://mp.weixin.qq.com/s/2CDpE5wfoiNXm1agMAq4wA">深度解密 Go 语言之 map - 码农桃花源</a><br>  <a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">理解 Golang 哈希表 map 的原理</a><br>  <a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#332-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Go 语言设计与实现</a> 注：本文部分内容从该博客中复制，博主写的太棒了，respect~</p></blockquote><p>map 作为一种基础数据结构，经常会用到，比如统计元素个数、去重等，但是 Go 内置的 map 有个缺点即不支持并发操作。下面将对 map 的使用方式以及底层原理进行介绍，最后再介绍如何实现一个支持并发操作的 map。</p><hr><br><br><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>很多语言里都支持 map 数据结构，如 Go 的 map、Java 的 HashMap、Python 的 dict，它们逻辑上都是键值对，所以可以把 map 看作一种 key→value 的映射。实现上一般有两种：</p><ul><li>哈希表：Go 的 map 以及 Python 的 dict 底层是哈希表。最差查找效率是 O(n)，平均查找效率是 O(1)，遍历哈希表得到的是乱序序列。</li><li>搜索树：一般是 AVL 树和红黑树，如 Java1.8 之后 HashMap 的底层就是数组 + 链表 + 红黑树。自平衡搜索树法的最差搜索效率是 O(lgn)，遍历自平衡搜索树，返回的 key 序列，一般会按照从小到大的顺序。</li></ul><hr><br><br><h2 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h2><p>map 支持增删改查这些基础操作，里面也有一些需要注意的点。</p><h3 id="2-1-声明与初始化"><a href="#2-1-声明与初始化" class="headerlink" title="2.1 声明与初始化"></a>2.1 声明与初始化</h3><p>需要注意的是 map 只有在初始化之后才能插入 k-v 对。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 声明之后插入数据</span><span class="token keyword">var</span> m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span>m<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">// panic: assignment to entry in nil map</span><span class="token comment" spellcheck="true">// 初始化之后插入数据</span>m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>m<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// map[x:1]</span><span class="token comment" spellcheck="true">// 字面量初始化</span>m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>    <span class="token string">"x"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">"y"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// map[x:1 y:2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难理解，声明时并没有给 map 分配内存空间，只有在通过 make 初始化 map(或使用字面量初始化) 后给其分配内存空间才能插入数据，下面来验证一下。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 声明的 map 没有实际的地址</span><span class="token keyword">var</span> m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%p, %v\n"</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0x0, map[]</span><span class="token comment" spellcheck="true">// 初始化之后的 map 才有实际的地址</span>m <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token comment" spellcheck="true">// m = make(map[int]string, 10) 初始化时可以设置长度，降低扩容的成本</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%p, %v\n"</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0xc000100d20, map[]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="2-2-增-插入键值对"><a href="#2-2-增-插入键值对" class="headerlink" title="2.2 增 - 插入键值对"></a>2.2 增 - 插入键值对</h3><p>给不存在的数据赋值即为插入操作，插入键值很简单，按照 map 的类型将 key 和 value 绑定起来。</p><pre class="line-numbers language-go"><code class="language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>m<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>m<span class="token punctuation">[</span><span class="token string">"y"</span><span class="token punctuation">]</span><span class="token operator">++</span> <span class="token comment" spellcheck="true">// 在 int 零值的基础上 + 1，在统计个数时很方便</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// map[x:1 y:1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="2-3-删-删除键值对"><a href="#2-3-删-删除键值对" class="headerlink" title="2.3 删 - 删除键值对"></a>2.3 删 - 删除键值对</h3><p>使用 <code>delete(mapName, keyName)</code> 即可根据键删除 map 中相应的键值对。</p><pre class="line-numbers language-go"><code class="language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>m<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>m<span class="token punctuation">[</span><span class="token string">"y"</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token function">delete</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">)</span><span class="token function">delete</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 删除不存在的 kv 相当于不做任何操作</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// map[y:1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="2-4-改-修改值"><a href="#2-4-改-修改值" class="headerlink" title="2.4 改 - 修改值"></a>2.4 改 - 修改值</h3><p>给存在的数据赋值即为修改操作。</p><pre class="line-numbers language-go"><code class="language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>m<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span><span class="token operator">++</span>m<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment" spellcheck="true">// 修改 value</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// map[x:10]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="2-5-查-查询值"><a href="#2-5-查-查询值" class="headerlink" title="2.5 查 - 查询值"></a>2.5 查 - 查询值</h3><p>根据 key 查询值，可以得到 value 以及 key 是否存在的 bool 值，若 key 不存在则返回零值</p><pre class="line-numbers language-go"><code class="language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>m<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span><span class="token operator">++</span>v <span class="token operator">:=</span> m<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> m<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> ok<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1 true</span>v<span class="token punctuation">,</span> ok <span class="token operator">=</span> m<span class="token punctuation">[</span><span class="token string">"y"</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// y 不存在</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> ok<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0 false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><br><br><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><p>注：源码在 <code>src/runtime/map.go</code> 中</p><h3 id="3-1-map-结构体"><a href="#3-1-map-结构体" class="headerlink" title="3.1 map 结构体"></a>3.1 map 结构体</h3><h4 id="3-1-1-hmap"><a href="#3-1-1-hmap" class="headerlink" title="3.1.1 hmap"></a>3.1.1 hmap</h4><img src="/images/20211228/hmap.png" alt="hmap" style="zoom:50%;"><ul><li>count：元素个数</li><li>flags：代表当前 map 的状态（是否处于正在写入的状态等）</li><li>B：桶的数量: 2^B</li><li>noverflow：溢出桶的数量，当溢出的桶太多时，map 会进行 same-size map growth，其实质是避免溢出桶过大导致内存泄露</li><li>hash0：计算 key hash 时的种子</li><li>buckets：指向新桶</li><li>oldbuckets：指向旧桶，扩容时会用到，所有旧桶中的数据都已经转移到了新桶中时，则清空</li><li>nevacuate：指示扩容进度，小于此地址的 buckets 迁移完成</li><li>extra：存储 map 中的溢出桶</li></ul><h4 id="3-1-2-bmap"><a href="#3-1-2-bmap" class="headerlink" title="3.1.2 bmap"></a>3.1.2 bmap</h4><p>map 的核心是” 桶 “，这也是真正存储 key-value 的数据结构，buckets 和 oldbuckets 是一个指针，最终它指向的是桶的结构体 bmap。</p><img src="/images/20211228/bmap.png" alt="bmap" style="zoom: 50%;"><p>bmap 里存放 tophash 字段，即长度为 8 的数组，存储着 key 的 hash 值的前 8 位。但这只是表面 <code>src/runtime/map.go</code> 的结构，编译期间会给它加料，动态地创建一个新的结构：</p><img src="/images/20211228/bmap-gc.png" alt="bmap-gc" style="zoom:50%;"><p>bmap 桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是 “一类” 的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有 8 个位置）。</p><p><img src="/images/20211228/hmap%E7%BB%93%E6%9E%84.png" alt="hmap 结构"></p><p>Go 语言选择将 key 与 value 分开存储而不是以 key/value/key/value 的形式存储，是为了在字节对齐时压缩空间。在根据 key 找 value 的过程中，首先计算 key 的 hash 值从而找到桶的 index(hash%array_size), 找到桶的位置后遍历 tophash 数组，如果在数组中找到了相同的 hash，那么可以接着通过指针的寻址操作找到对应的 key 与 value。</p><p><img src="/images/20211228/map%E7%BB%93%E6%9E%84.png" alt="map 结构"></p><h4 id="3-1-3-mapextra"><a href="#3-1-3-mapextra" class="headerlink" title="3.1.3 mapextra"></a>3.1.3 mapextra</h4><p>在 Go 语言中还有一个溢出桶的概念，在执行 hash[key]=value 赋值操作时，当指定桶中的数据超过 8 个时，并不会直接开辟一个新桶，而是将数据放置到溢出桶中，每个桶的最后都存储了 overflow，即溢出桶的指针。在正常情况下，数据是很少会跑到溢出桶里面去的。</p><img src="/images/20211228/mapextra.png" alt="mapextra" style="zoom:50%;"><img src="/images/20211228/hmap-buckets.png" alt="hmap-buckets" style="zoom:50%;"><p>当发生以下两种情况之一时，map 会进行重建：</p><ul><li>map 超过了负载因子大小。</li><li>溢出桶的数量过多。</li></ul><p>在哈希表中有经典的负载因子的概念：<strong>负载因子 = 哈希表中的元素数量 / 桶的数量。</strong>负载因子的增大，意味着更多的元素会被分配到同一个桶中，此时效率会减慢。Go 语言中的负载因子为 6.5，当超过其大小后，map 会进行扩容，增大到旧表 2 倍的大小，旧桶的数据会存到 oldbuckets 字段中，并想办法分散转移到新桶中。当旧桶中的数据全部转移到新桶中后，旧桶就会被清空。</p><p>溢出桶的数量太多，这时 map 只会新建和原来相同大小的桶，目的是防止溢出桶的数量缓慢增长导致的内存泄露。</p><br><h3 id="3-2-初始化"><a href="#3-2-初始化" class="headerlink" title="3.2 初始化"></a>3.2 初始化</h3><p>Go 初始化 map 主要通过两种方式 — <strong>字面量</strong> &amp; <strong>运行时</strong></p><h4 id="3-2-1-字面量初始化"><a href="#3-2-1-字面量初始化" class="headerlink" title="3.2.1 字面量初始化"></a>3.2.1 字面量初始化</h4><pre class="line-numbers language-go"><code class="language-go">m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>    <span class="token string">"x"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token string">"y"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// map[x:1 y:2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 map 采取了字面量初始化的方式，那么它最终仍然需要转换为 make 操作。map 的长度被自动推断为字面量的长度，其核心逻辑位于 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/sinit.go#L753">gc/sinit.go</a> 中，该函数专门用于处理各种类型的字面量。</p><p>若 <code>len(map) ≤ 25</code>，则会将字面量初始化的结构体转为以下代码，将 key-value 一次加入 map。</p><pre class="line-numbers language-go"><code class="language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>m<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>m<span class="token punctuation">[</span><span class="token string">"y"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若 <code>len(map) &gt; 25</code>，编译器会构建两个数组专门存储 key 与 value，在运行时循环添加数据。</p><pre class="line-numbers language-go"><code class="language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span>vstatk <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">}</span>vstatv <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>vstak<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>    m<span class="token punctuation">[</span>vstatk<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> vstatv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-2-运行时初始化"><a href="#3-2-2-运行时初始化" class="headerlink" title="3.2.2 运行时初始化"></a>3.2.2 运行时初始化</h4><p><strong>小容量 hash 优化</strong>：当创建的哈希被分配到栈上并且其容量小于&nbsp;<code>BUCKETSIZE = 8</code>&nbsp;时，Go 语言在编译阶段会使用如下方式快速初始化哈希，这也是编译器对小容量的哈希做的优化。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> h <span class="token operator">*</span>hmap<span class="token keyword">var</span> hv hmap<span class="token keyword">var</span> bv bmaph <span class="token operator">:=</span> <span class="token operator">&amp;</span>hvb <span class="token operator">:=</span> <span class="token operator">&amp;</span>bvh<span class="token punctuation">.</span>buckets <span class="token operator">=</span> bh<span class="token punctuation">.</span>hash0 <span class="token operator">=</span> <span class="token function">fashtrand0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>makemap</strong></p><p>初始化 map 最后调用的都是 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L303">makemap 函数</a></p><ol><li>计算哈希占用的内存是否溢出或者超出能分配的最大值；</li><li>调用&nbsp;<a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/stubs.go#L109">runtime.fastrand</a>&nbsp;获取一个随机的哈希种子；</li><li>根据传入的&nbsp;<code>hint</code>&nbsp;计算出需要的最小需要的桶的数量；</li><li>使用&nbsp;<a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L344">runtime.makeBucketArray</a> 创建用于保存桶的数组；</li></ol><img src="/images/20211228/makemap.png" alt="makemap" style="zoom:50%;"><p>makemap 函数会计算出需要的桶的数量，即 ${log_2N}$ ，并调用 makeBucketArray 函数生成桶和溢出桶。如果初始化时生成了溢出桶，则会放置到 map 的 extra 字段里去。</p><p><strong>makeBucketArray</strong></p><p><a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L344">runtime.makeBucketArray</a> 会根据传入的&nbsp;<code>B</code>&nbsp;计算出的需要创建的桶数量并在内存中分配一片连续的空间用于存储数据：</p><img src="/images/20211228/makeBucketArray.png" alt="makeBucketArray" style="zoom:50%;"><ul><li>当桶的数量小于 2^4 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</li><li>当桶的数量多于 2^4 时，会额外创建&nbsp;2^(B-4)&nbsp;个溢出桶；</li></ul><br><h3 id="3-3-查-查询值"><a href="#3-3-查-查询值" class="headerlink" title="3.3 查 - 查询值"></a>3.3 查 - 查询值</h3><p>根据 key 查询 value 时有两种方式，因为 Go 没有函数重载所以会调用两个函数名不同的函数，但是内部逻辑基本相同。</p><pre class="line-numbers language-go"><code class="language-go">v     <span class="token operator">:=</span> hash<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// => v     := *mapaccess1(maptype, hash, &amp;key)</span>v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> hash<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// => v, ok := mapaccess2(maptype, hash, &amp;key)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>mapaccess1</strong></p><p><a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L394">mapaccess1</a> 会先算出 key 的 hash 值，再通过 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L189">bucketMask</a> 和 <a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/stubs.go#L11">add</a> 拿到该键值对所在的桶序号和 hash 值高位的 8 位数字。之后会依次遍历正常桶和溢出桶中的数据，它会先比较 hash 值的高 8 位和桶中存储的&nbsp;<code>tophash</code>，后比较传入的和桶中的值以加速数据的读写。</p><p>用于选择桶序号的是哈希的最低几位，而用于加速访问的是哈希的高 8 位，这种设计能够减少同一个桶中有大量相等&nbsp;<code>tophash</code>&nbsp;的概率影响性能。</p><img src="/images/20211228/mapaccess.png" alt="mapaccess" style="zoom:50%;"><p>如上图所示，每一个桶都是一整片的内存空间，当发现桶中的&nbsp;<code>tophash</code>&nbsp;与传入键的&nbsp;<code>tophash</code>&nbsp;匹配之后，我们会通过指针和偏移量获取哈希中存储的键&nbsp;<code>keys[0]</code>&nbsp;并与&nbsp;<code>key</code>&nbsp;比较，如果两者相同就会获取目标值的指针&nbsp;<code>values[0]</code>&nbsp;并返回。</p><p><strong>mapaccess2</strong></p><p><a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L452">mapaccess2</a> 在 mapaccess1 的基础上多返回了一个标识键值对是否存在的&nbsp;<code>bool</code>&nbsp;值，使用&nbsp;<code>v, ok := hash[k]</code>&nbsp;的形式访问哈希表中元素时，我们能够通过这个布尔值更准确地知道当&nbsp;<code>v == nil</code>&nbsp;时，<code>v</code>&nbsp;到底是哈希中存储的元素还是表示该键对应的元素不存在，所以在访问哈希时，更推荐使用这种方式判断元素是否存在。</p><br><h3 id="3-4-增-改-写入-修改键值对"><a href="#3-4-增-改-写入-修改键值对" class="headerlink" title="3.4 增 / 改 - 写入 / 修改键值对"></a>3.4 增 / 改 - 写入 / 修改键值对</h3><h4 id="3-4-1-操作流程"><a href="#3-4-1-操作流程" class="headerlink" title="3.4.1 操作流程"></a>3.4.1 操作流程</h4><p>当形如&nbsp;<code>hash[k]</code>&nbsp;的表达式出现在赋值符号左侧时，该表达式也会在编译期间转换成&nbsp;<a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L571">runtime.mapassign</a>&nbsp;函数的调用。</p><img src="/images/20211228/overflow.png" alt="overflow" style="zoom:50%;"><ol><li>首先是函数会根据传入的键拿到对应的哈希和桶。</li><li>然后通过遍历比较桶中存储的&nbsp;<code>tophash</code>&nbsp;和键的哈希，如果找到了相同结果就会返回目标位置的地址。其中&nbsp;<code>inserti</code>&nbsp;表示目标元素的在桶中的索引，<code>insertk</code>&nbsp;和&nbsp;<code>val</code>&nbsp;分别表示键值对的地址，获得目标地址之后会通过算术计算寻址获得键值对&nbsp;<code>k</code>&nbsp;和&nbsp;<code>val</code>。</li><li>如果当前桶已经满了，哈希会调用&nbsp;<a href="https://draveness.me/golang/tree/runtime.hmap.newoverflow">runtime.hmap.newoverflow</a>&nbsp;创建新桶或者使用&nbsp;<a href="https://draveness.me/golang/tree/runtime.hmap">runtime.hmap</a>&nbsp;预先在&nbsp;<code>noverflow</code>&nbsp;中创建好的桶来保存数据，新创建的桶不仅会被追加到已有桶的末尾，还会增加哈希表的&nbsp;<code>noverflow</code>&nbsp;计数器。</li><li>如果当前键值对在哈希中不存在，哈希会为新键值对规划存储的内存地址，通过&nbsp;<a href="https://draveness.me/golang/tree/runtime.typedmemmove">runtime.typedmemmove</a>&nbsp;将键移动到对应的内存空间中并返回键对应值的地址&nbsp;<code>val</code>。如果当前键值对在哈希中存在，那么就会直接返回目标区域的内存地址，哈希并不会在&nbsp;<a href="https://draveness.me/golang/tree/runtime.mapassign">runtime.mapassign</a>&nbsp;这个运行时函数中将值拷贝到桶中，该函数只会返回内存地址，真正的赋值操作是在编译期间插入的。</li></ol><h4 id="3-4-2-扩容"><a href="#3-4-2-扩容" class="headerlink" title="3.4.2 扩容"></a>3.4.2 扩容</h4><p>随着哈希表中元素的逐渐增加，哈希的性能会逐渐恶化，所以我们需要更多的桶和更大的内存保证哈希的读写性能。</p><p>以下两种情况发生时触发哈希的扩容：</p><ol><li>装载因子已经超过 6.5；</li><li>哈希使用了太多溢出桶；</li></ol><p>不过因为 Go 语言哈希的扩容不是一个原子的过程，所以&nbsp;<a href="https://draveness.me/golang/tree/runtime.mapassign">runtime.mapassign</a>&nbsp;还需要判断当前哈希是否已经处于扩容状态，避免二次扩容造成混乱。</p><p>根据触发的条件不同扩容的方式分成两种，如果这次扩容是溢出的桶太多导致的，那么这次扩容就是等量扩容&nbsp;<code>sameSizeGrow</code>，<code>sameSizeGrow</code>&nbsp;是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏 <a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:4">4</a>。<a href="https://github.com/golang/go/commit/9980b70cb460f27907a003674ab1b9bea24a847c">runtime: limit the number of map overflow buckets</a>&nbsp;引入了&nbsp;<code>sameSizeGrow</code>&nbsp;通过复用已有的哈希扩容机制解决该问题，一旦哈希中出现了过多的溢出桶，它会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存。</p><p>扩容的入口是&nbsp;<a href="https://draveness.me/golang/tree/runtime.hashGrow">runtime.hashGrow</a> ，哈希在扩容的过程中会通过&nbsp;<a href="https://draveness.me/golang/tree/runtime.makeBucketArray">runtime.makeBucketArray</a>&nbsp;创建一组新桶和预创建的溢出桶，随后将原有的桶数组设置到&nbsp;<code>oldbuckets</code>&nbsp;上并将新的空桶设置到&nbsp;<code>buckets</code>&nbsp;上，溢出桶也使用了相同的逻辑更新，下图展示了触发扩容后的哈希：</p><img src="/images/20211228/hashgrow.png" alt="hashgrow" style="zoom:50%;"><p>我们在&nbsp;<a href="https://draveness.me/golang/tree/runtime.hashGrow">runtime.hashGrow</a>&nbsp;中还看不出来等量扩容和翻倍扩容的太多区别，等量扩容创建的新桶数量只是和旧桶一样，该函数中只是创建了新的桶，并没有对数据进行拷贝和转移。哈希表的数据迁移的过程在是&nbsp;<a href="https://draveness.me/golang/tree/runtime.evacuate">runtime.evacuate</a>&nbsp;中完成的，它会对传入桶中的元素进行再分配。</p><p><a href="https://draveness.me/golang/tree/runtime.evacuate">runtime.evacuate</a>&nbsp;会将一个旧桶中的数据分流到两个新桶，所以它会创建两个用于保存分配上下文的&nbsp;<a href="https://draveness.me/golang/tree/runtime.evacDst">runtime.evacDst</a>&nbsp;结构体，这两个结构体分别指向了一个新桶。</p><img src="/images/20211228/evacuate.png" alt="evacuate" style="zoom:50%;"><p>我们简单总结一下哈希表扩容的设计和原理，哈希在存储元素过多时会触发扩容操作，每次都会将桶的数量翻倍，扩容过程不是原子的，而是通过&nbsp;<a href="https://draveness.me/golang/tree/runtime.growWork">runtime.growWork</a>&nbsp;增量触发的，在扩容期间访问哈希表时会使用旧桶，向哈希表写入数据时会触发旧桶元素的分流。除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄漏问题，哈希引入了&nbsp;<code>sameSizeGrow</code>&nbsp;这一机制，在出现较多溢出桶时会整理哈希的内存减少空间的占用。</p><br><h3 id="3-5-删-删除键值对"><a href="#3-5-删-删除键值对" class="headerlink" title="3.5 删 - 删除键值对"></a>3.5 删 - 删除键值对</h3><p>如果想要删除哈希中的元素，就需要使用 Go 语言中的&nbsp;<code>delete</code>&nbsp;关键字，这个关键字的唯一作用就是将某一个键对应的元素从哈希表中删除，无论是该键对应的值是否存在，这个内建的函数都不会返回任何的结果。</p><p>哈希表的删除逻辑与写入逻辑很相似，只是触发哈希的删除需要使用关键字，如果在删除期间遇到了哈希表的扩容，就会分流桶中的元素，分流结束之后会找到桶中的目标元素完成键值对的删除工作。</p><hr><br><br><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>Go 语言使用拉链法来解决哈希碰撞的问题实现了哈希表，它的访问、写入和删除等操作都在编译期间转换成了运行时的函数或者方法。哈希在每一个桶中存储键对应哈希的前 8 位，当对哈希进行操作时，这些&nbsp;<code>tophash</code>&nbsp;就成为可以帮助哈希快速遍历桶中元素的缓存。</p><p>哈希表的每个桶都只能存储 8 个键值对，一旦当前哈希的某个桶超出 8 个，新的键值对就会存储到哈希的溢出桶中。随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动。</p><br><br>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go数据类型-数组&amp;切片</title>
      <link href="/posts/7f74b491.html"/>
      <url>/posts/7f74b491.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go数据类型-数组-amp-切片"><a href="#Go数据类型-数组-amp-切片" class="headerlink" title="Go数据类型-数组&amp;切片"></a>Go数据类型-数组&amp;切片</h1><blockquote><p>参考<br>  《Go语言底层原理剖析》第6、7章<br>  《Go专家编程》第1章<br>  《Go语言学习笔记》第5章<br>  《Go语言高级编程》第1章<br>  <a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/">《Go语言设计与实现》第3章</a></p></blockquote><p>数组和切片作为Go中的基础数据类型，使用十分频繁。一般在处理函数参数时，切片用的比较多，因为Go是值传递，如果参数是数组那么会把数组复制一遍，开销比较大，如果参数是切片只会把切片结构体复制一遍，开销就很小了。</p><p>切片的底层是数组，只不过增加了<code>容量</code>和<code>长度</code>两个属性。下面分别介绍数组以及切片的使用方法以及底层实现原理。</p><hr><br><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h2><h3 id="1-1-声明方式"><a href="#1-1-声明方式" class="headerlink" title="1.1 声明方式"></a>1.1 声明方式</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"unsafe"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 两种声明方式</span>    <span class="token keyword">var</span> arr1 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment" spellcheck="true">// 指定长度</span>    <span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 指定长度</span>    arr3 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 推断长度</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr1: %p %T -> %v\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr1<span class="token punctuation">,</span> arr1<span class="token punctuation">,</span> arr1<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr2: %p %T -> %v\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr2<span class="token punctuation">,</span> arr2<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr3: %p %T -> %v\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr3<span class="token punctuation">,</span> arr3<span class="token punctuation">,</span> arr3<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span><span class="token function">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 可以通过len得到数组的长度</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// arr1: 0xc0000180c0 [3]int -> [0 0 0]</span><span class="token comment" spellcheck="true">// arr2: 0xc0000180d8 [3]int -> [1 2 3]</span><span class="token comment" spellcheck="true">// arr3: 0xc0000180f0 [3]int -> [4 5 6]</span><span class="token comment" spellcheck="true">// 24 24 24</span><span class="token comment" spellcheck="true">// 8</span><span class="token comment" spellcheck="true">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组的声明方式主要有两种，都会产生一个固定长度的相同元素排列，且每一个元素的物理地址都是相邻的。</p><p>如上述例子中，每个数组的长度是 3，所占用的空间都是连续的 24 个字节。这是因为<code>int</code>类型本质上是<code>int64</code>，占用<code>64/8=8</code>个字节，三个<code>int</code>就是 24 字节。</p><p>可以通过<code>len</code>得到数组的长度，关于len的细节参考这篇blog:<a href="https://tpaschalis.github.io/golang-len/">https://tpaschalis.github.io/golang-len/</a></p><br><h3 id="1-2-数组复制"><a href="#1-2-数组复制" class="headerlink" title="1.2 数组复制"></a>1.2 数组复制</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr1: %p %T -> %v\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr1<span class="token punctuation">,</span> arr1<span class="token punctuation">,</span> arr1<span class="token punctuation">)</span><span class="token function">copyArray</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"arr1: %p %T -> %v\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr1<span class="token punctuation">,</span> arr1<span class="token punctuation">,</span> arr1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// arr1: 0xc0000b6000 [3]int -> [1 2 3]</span><span class="token comment" spellcheck="true">// a: 0xc0000b6060 [3]int -> [1 123 3] 与arr1地址不同</span><span class="token comment" spellcheck="true">// arr1: 0xc0000b6000 [3]int -> [1 2 3]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go语言中的数组在赋值和函数调用时的形参都是<code>值复制</code>，在函数中修改数组实际上是修改数组副本。</p><br><h3 id="1-3-实现原理"><a href="#1-3-实现原理" class="headerlink" title="1.3 实现原理"></a>1.3 实现原理</h3><h4 id="1-3-1-创建数组"><a href="#1-3-1-创建数组" class="headerlink" title="1.3.1 创建数组"></a>1.3.1 创建数组</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewArray</span><span class="token punctuation">(</span>elem <span class="token operator">*</span>Type<span class="token punctuation">,</span> bound <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token operator">*</span>Type <span class="token punctuation">{</span>    <span class="token keyword">if</span> bound <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"NewArray: invalid bound %v"</span><span class="token punctuation">,</span> bound<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    t <span class="token operator">:=</span> <span class="token function">New</span><span class="token punctuation">(</span>TARRAY<span class="token punctuation">)</span>    t<span class="token punctuation">.</span>Extra <span class="token operator">=</span> <span class="token operator">&amp;</span>Array<span class="token punctuation">{</span>Elem<span class="token punctuation">:</span> elem<span class="token punctuation">,</span> Bound<span class="token punctuation">:</span> bound<span class="token punctuation">}</span>    t<span class="token punctuation">.</span><span class="token function">SetNotInHeap</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span><span class="token function">NotInHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> t<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译期间的数组类型是由上述的<a href="https://github.com/golang/go/blob/da54dfb6a1f3bef827b9ec3780c98fde77a97d11/src/cmd/compile/internal/types/type.go#L482">/src/cmd/compile/internal/types.NewArray</a>&nbsp;函数生成的，该类型包含两个字段，分别是元素类型&nbsp;<code>Elem</code>&nbsp;和数组的大小&nbsp;<code>Bound</code>，这两个字段共同构成了数组类型，而当前数组是否应该在堆栈中初始化也在编译期就确定了。</p><h4 id="1-3-2-数组初始化"><a href="#1-3-2-数组初始化" class="headerlink" title="1.3.2 数组初始化"></a>1.3.2 数组初始化</h4><p>Go 语言的数组有两种不同的创建方式，一种是显式的指定数组大小，另一种是使用&nbsp;<code>[...]T</code>&nbsp;声明数组，Go 语言会在编译期间通过源代码推导数组的大小，将后一种转换为前一种。</p><ol><li><strong>指定数组大小</strong>：使用上面提到的 <code>NewArray</code> 进行初始化。</li><li><strong>不指定数组大小</strong>：编译器会在对该数组的大小进行推导，通过遍历元素的方式来计算数组中元素的数量。</li></ol><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">typecheckcomplit</span><span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">(</span>res <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    <span class="token keyword">if</span> n<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Op <span class="token operator">==</span> OTARRAY <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Op <span class="token operator">==</span> ODDD <span class="token punctuation">{</span>        n<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Right <span class="token operator">=</span> <span class="token function">typecheck</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Right<span class="token punctuation">,</span> ctxType<span class="token punctuation">)</span>        <span class="token keyword">if</span> n<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Type <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            n<span class="token punctuation">.</span>Type <span class="token operator">=</span> <span class="token boolean">nil</span>            <span class="token keyword">return</span> n        <span class="token punctuation">}</span>        elemType <span class="token operator">:=</span> n<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Type        <span class="token comment" spellcheck="true">// 通过遍历元素的方式来计算数组中元素的数量</span>        length <span class="token operator">:=</span> <span class="token operator">*</span><span class="token operator">*</span>typecheckarraylit<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">(</span>elemType<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"array literal"</span><span class="token punctuation">)</span>        n<span class="token punctuation">.</span>Op <span class="token operator">=</span> OARRAYLIT        n<span class="token punctuation">.</span>Type <span class="token operator">=</span> types<span class="token punctuation">.</span><span class="token function">NewArray</span><span class="token punctuation">(</span>elemType<span class="token punctuation">,</span> length<span class="token punctuation">)</span>        n<span class="token punctuation">.</span>Right <span class="token operator">=</span> <span class="token boolean">nil</span>        <span class="token keyword">return</span> n    <span class="token punctuation">}</span>    <span class="token operator">...</span>    <span class="token keyword">switch</span> t<span class="token punctuation">.</span>Etype <span class="token punctuation">{</span>    <span class="token keyword">case</span> TARRAY<span class="token punctuation">:</span>        <span class="token function">typecheckarraylit</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">NumElem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">.</span>List<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"array literal"</span><span class="token punctuation">)</span>        n<span class="token punctuation">.</span>Op <span class="token operator">=</span> OARRAYLIT        n<span class="token punctuation">.</span>Right <span class="token operator">=</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个删减后的&nbsp;<a href="https://github.com/golang/go/blob/5b0ec1a6ac0e644c89940e0fe5f79863ad2eafaa/src/cmd/compile/internal/gc/typecheck.go#L2793">cmd/compile/internal/gc.typecheckcomplit</a>&nbsp;会调用&nbsp;<a href="https://github.com/golang/go/blob/5b0ec1a6ac0e644c89940e0fe5f79863ad2eafaa/src/cmd/compile/internal/gc/typecheck.go#L3004">cmd/compile/internal/gc.typecheckarraylit</a> 通过遍历元素的方式来计算数组中元素的数量。</p><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <a href="https://github.com/golang/go/blob/da54dfb6a1f3bef827b9ec3780c98fde77a97d11/src/cmd/compile/internal/gc/sinit.go#L860">cmd/compile/internal/gc.anylit</a> 函数中做两种不同的优化：</p><ol><li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li><li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li></ol><h4 id="1-3-3-越界检查"><a href="#1-3-3-越界检查" class="headerlink" title="1.3.3 越界检查"></a>1.3.3 越界检查</h4><p>数组访问越界是非常严重的错误，Go语言中对越界的判断有一部分是在编译期间类型检查阶段完成的，typecheck1函数会对访问数组的索引进行验证。</p><p>具体的验证逻辑如下：</p><ul><li>访问数组的索引是非整数时报错为<code>non-integer array index%v</code>。</li><li>访问数组的索引是负数时报错为<code>invalid array index%v（index must be non-negative）</code>。</li><li>访问数组的索引越界时报错为<code>invalid array index%v（out of bounds for%d-element array）</code>。</li></ul><hr><br><br><h2 id="2-切片"><a href="#2-切片" class="headerlink" title="2 切片"></a>2 切片</h2><p>Go语言程序中很少使用数组，基本上都是用的切片<code>slice</code>。slice的底层还是数组，但是slice的长度是可变的，下面对slice进行介绍。</p><h3 id="2-1-声明方式"><a href="#2-1-声明方式" class="headerlink" title="2.1 声明方式"></a>2.1 声明方式</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> slice1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment" spellcheck="true">// 类似与数组声明，只不过不设定长度</span>slice2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>slice3 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// make(type, len, cap)</span>slice4 <span class="token operator">:=</span> slice3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice1<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice1<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice3<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice3<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice4<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice4<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// [] 0 0</span><span class="token comment" spellcheck="true">// [0 0 0 0 0] 5 5</span><span class="token comment" spellcheck="true">// [0 0 0 0 0] 5 7</span><span class="token comment" spellcheck="true">// [0 0] 2 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>slice声明有两种方式：</p><ol><li><code>[]int</code> 类似与数组声明，只不过不设定长度</li><li><code>make(type, len, cap)</code> 设定slice的长度和容量，为了减少后面扩容带来的损耗通常一次分配内存。需要注意的是，当长度不等0时会给slice的前len个元素分配默认值，如slice3的前5个元素都是0。</li></ol><p>也可以从已有的slice或数组中通过截取 <code>[left:right]</code>的方式获得新的切片(左闭右开)，后面详细介绍。</p><p><code>Slice数据结构</code></p><p>slice的结构体定义在 <a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/reflect/value.go#L1994">/src/reflect/value.go#L1994</a> 中，包含三个字段：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// SliceHeader is the runtime representation of a slice.</span><span class="token comment" spellcheck="true">// It cannot be used safely or portably and its representation may</span><span class="token comment" spellcheck="true">// change in a later release.</span><span class="token comment" spellcheck="true">// Moreover, the Data field is not sufficient to guarantee the data</span><span class="token comment" spellcheck="true">// it references will not be garbage collected, so programs must keep</span><span class="token comment" spellcheck="true">// a separate, correctly typed pointer to the underlying data.</span><span class="token keyword">type</span> SliceHeader <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Data <span class="token builtin">uintptr</span>    Len  <span class="token builtin">int</span>    Cap  <span class="token builtin">int</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Data</code>指向底层的数组，<code>Len</code>为切片长度，<code>Cap</code>为切片容量。</p><p><img src="/images/20211222/Slice.png" alt="Slice"></p><br><h3 id="2-2-切片截取"><a href="#2-2-切片截取" class="headerlink" title="2.2 切片截取"></a>2.2 切片截取</h3><pre class="line-numbers language-go"><code class="language-go">slice1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// slice</span>array <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// array</span>slice2 <span class="token operator">:=</span> slice1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">]</span>slice3 <span class="token operator">:=</span> array<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice3<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// [5 6] 2 5</span><span class="token comment" spellcheck="true">// [5 6] 2 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切片截取可以从切片里截也可以从数组里截，截取的规则遵循左闭右开，例如上面 <code>[5:7]</code> 表示从下标为 5 到 下标为6，不包括下标为 7 的元素。</p><p>不难理解截取出来的 slice 长度为 2，但是为什么容量 cap 等于 5 呢？这是因为截取的 slice 依然是指向被截取的 slice 或 array，二者底层共用一个数组。</p><p><img src="/images/20211222/%E5%88%87%E7%89%87%E6%88%AA%E5%8F%96.png" alt="切片截取"></p><pre class="line-numbers language-go"><code class="language-go">slice1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>slice2 <span class="token operator">:=</span> slice1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token punctuation">)</span>slice1<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>slice1 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>slice1<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice1<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice1<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// [5 6]</span><span class="token comment" spellcheck="true">// [0 1 2 3 4 5 10 7 8 9 10] 11 20</span><span class="token comment" spellcheck="true">// [5 10] 2 5</span>slice1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>slice2 <span class="token operator">:=</span> slice1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// [start:end:cap] 设置切片的容量</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// [5 6] 2 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上修改原切片里的元素，截取出来的切片能够感知到该切片的改动，说明二者共用一个底层。可以观察到 slice1 在 append 一个元素后其 cap 变成了 20，而 slice2 的 cap 还是 5。</p><p>这就涉及到 slice 的扩容机制了，在这种情况下， slice 的 cap 翻倍并且指向一个新的底层数组，但是 slice2 还是指向原来的底层数组。</p><br><h3 id="2-3-扩容"><a href="#2-3-扩容" class="headerlink" title="2.3 扩容"></a>2.3 扩容</h3><p>slice的扩容机制其实很简单，对于一个 slice ，如果其<code>len&lt;cap</code>说明还有空间可以存放新的元素，直接放进 slice 即可。但是如果<code>len==cap</code>，则说明没有空间了即需要扩充容量。</p><p><img src="/images/20211222/%E6%89%A9%E5%AE%B9.png" alt="扩容"></p><p><a href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/slice.go#L125">src/runtime/slice.go#L125</a> 中实现了扩容机制：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> slice <span class="token punctuation">{</span>    <span class="token operator">...</span>    newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>    doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap    <span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">></span> doublecap <span class="token punctuation">{</span>        newcap <span class="token operator">=</span> <span class="token builtin">cap</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">{</span>            newcap <span class="token operator">=</span> doublecap        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">{</span>                newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>                newcap <span class="token operator">=</span> <span class="token builtin">cap</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩容操作只关心容量，会把原Slice数据拷贝到新 Slice，追加数据由 append 在扩容结束后完成。上图可见，扩容后新的 Slice 长度仍然是 5，但容量由 5 提升到了 10，原 Slice 的数据也都拷贝到了新 Slice 指向的数组中。<br>扩容容量的选择遵循以下规则：</p><ul><li>如果原Slice容量小于 1024，则新Slice容量将扩大为原来的 2 倍；</li><li>如果原Slice容量大于等于 1024，则新Slice容量将扩大为原来的 1.25 倍；</li></ul><p>使用append()向Slice添加一个元素的实现步骤如下：</p><ol><li>假如 Slice容量够用，则将新元素追加进去，Slice.len++，返回原 Slice</li><li>原 Slice 容量不够，则将 Slice 先扩容，扩容后得到新 Slice</li><li>将新元素追加进新 Slice，Slice.len++，返回新的 Slice</li></ol><p>上述代码片段仅会确定切片的大致容量，下面还需要根据切片中的元素大小对齐内存，当数组中元素所占的字节大小为 1、8 或者 2 的倍数时，运行时会对齐内存。</p><br><h3 id="2-4-深拷贝"><a href="#2-4-深拷贝" class="headerlink" title="2.4 深拷贝"></a>2.4 深拷贝</h3><p>复制的切片不会改变指向底层的数据源，但有些时候我们希望建一个新的数组，并且与旧数组不共享相同的数据源，这时可以使用<code>copy</code>函数。</p><pre class="line-numbers language-go"><code class="language-go">slice1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>slice2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice1<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token function">copy</span><span class="token punctuation">(</span>slice2<span class="token punctuation">,</span> slice1<span class="token punctuation">)</span>slice1<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slice2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// [0 0 0 0 0 0 0 0 0 0]</span><span class="token comment" spellcheck="true">// [0 1 2 3 4 5 6 7 8 9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 数组 </tag>
            
            <tag> 切片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go如何构建CLI工具</title>
      <link href="/posts/74de10fc.html"/>
      <url>/posts/74de10fc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go如何构建CLI工具"><a href="#Go如何构建CLI工具" class="headerlink" title="Go如何构建CLI工具"></a>Go如何构建CLI工具</h1><blockquote><p>参考<br>  <a href="https://pkg.go.dev/flag#hdr-Usage">flag官方文档</a><br>  <a href="https://cobra.dev/">cobra官方文档</a><br>  <a href="https://github.com/spf13/cobra">cobra github</a><br>  《Go语言编程之旅》第一章命令行应用</p></blockquote><p>很多Go的应用程序是通过命令行进行交互，即<code>CLI(command-line interface)</code>命令行接口，go的标准库<code>flag</code>提供了命令行参数解析的能力，让我们在开发过程中能够非常方便地解析和处理命令行参数。目前也有许多开源项目提供了快速构建CLI应用程序的能力，如<code>Cobra</code>，下面介绍如何使用这些库构建CLI工具。</p><hr><h2 id="1-flag包"><a href="#1-flag包" class="headerlink" title="1 flag包"></a>1 flag包</h2><h3 id="1-1-使用方式"><a href="#1-1-使用方式" class="headerlink" title="1.1 使用方式"></a>1.1 使用方式</h3><h4 id="1-1-1-基本使用"><a href="#1-1-1-基本使用" class="headerlink" title="1.1.1 基本使用"></a>1.1.1 基本使用</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"flag"</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">var</span> <span class="token punctuation">(</span>    intFlag    <span class="token builtin">int</span>    boolFlag   <span class="token builtin">bool</span>    stringFlag <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    flag<span class="token punctuation">.</span><span class="token function">IntVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>intFlag<span class="token punctuation">,</span> <span class="token string">"intFlag"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"int flag"</span><span class="token punctuation">)</span>    flag<span class="token punctuation">.</span><span class="token function">BoolVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>boolFlag<span class="token punctuation">,</span> <span class="token string">"boolFlag"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"bool flag"</span><span class="token punctuation">)</span>    flag<span class="token punctuation">.</span><span class="token function">StringVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stringFlag<span class="token punctuation">,</span> <span class="token string">"stringFlag"</span><span class="token punctuation">,</span> <span class="token string">"default"</span><span class="token punctuation">,</span> <span class="token string">"string flag"</span><span class="token punctuation">)</span>    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>intFlag<span class="token punctuation">,</span> boolFlag<span class="token punctuation">,</span> stringFlag<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>flag</code>提供了<code>intVar</code>、<code>StringVar</code>等方法，可以对命令行参数进行解析和绑定，函数签名如下：</p><img src="/images/20211221/flag.IntVar.png" alt="flag.IntVar" style="zoom: 50%;"><p>各个形参的含义分别为命令行标识位的名称、默认值和帮助信息。</p><p>命令行参数支持如下三种命令行标志语法：</p><ul><li><code>-flag</code>：仅支持布尔类型。</li><li><code>-flag x</code>：仅支持非布尔类型。</li><li><code>-flag=x</code>：都支持。</li></ul><pre class="line-numbers language-bash"><code class="language-bash">$ go run main.go -intFlag 10 -boolFlag -stringFlag xxfoutput: 10 <span class="token boolean">true</span> xxf该例子中使用了-flag 和 -flag x，其中-boolFlag表示该布尔值为True$ go run main.go -intFlag 10 -stringFlag xxfoutput: 10 <span class="token boolean">false</span> xxf该例子中使用了-flag 和 -flag x，其中没有-boolFlag则默认该布尔值为False$ go run main.go -intFlag<span class="token operator">=</span>10 -boolFlag<span class="token operator">=</span>true -stringFlag<span class="token operator">=</span>xxfoutput: 10 <span class="token boolean">true</span> xxf该例子中使用了-flag<span class="token operator">=</span>x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="1-1-2-长短选项"><a href="#1-1-2-长短选项" class="headerlink" title="1.1.2 长短选项"></a>1.1.2 长短选项</h4><pre class="line-numbers language-go"><code class="language-go">flag<span class="token punctuation">.</span><span class="token function">IntVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>intFlag<span class="token punctuation">,</span> <span class="token string">"intFlag"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"int flag"</span><span class="token punctuation">)</span>flag<span class="token punctuation">.</span><span class="token function">IntVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>intFlag<span class="token punctuation">,</span> <span class="token string">"i"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"int flag"</span><span class="token punctuation">)</span>$ <span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span> <span class="token operator">-</span>i <span class="token number">10</span> <span class="token operator">-</span>boolFlag<span class="token operator">=</span><span class="token boolean">true</span> <span class="token operator">-</span>stringFlag<span class="token operator">=</span>xxfoutput<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token boolean">true</span> xxf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个命令行参数的标志位有长短选项是常规需求，使用flag的话可以调用两次绑定操作。</p><br><h4 id="1-1-3-子命令"><a href="#1-1-3-子命令" class="headerlink" title="1.1.3 子命令"></a>1.1.3 子命令</h4><p>在日常使用的CLI应用程序中，最常见的功能是子命令的使用。一个工具可能包含了大量相关联的功能命令，以此形成工具集，可以说是刚需，那么这个功能在标准库flag中是如何实现的呢？</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"flag"</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">var</span> <span class="token punctuation">(</span>    intFlag    <span class="token builtin">int</span>    boolFlag   <span class="token builtin">bool</span>    stringFlag <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    gocmd <span class="token operator">:=</span> flag<span class="token punctuation">.</span><span class="token function">NewFlagSet</span><span class="token punctuation">(</span><span class="token string">"go"</span><span class="token punctuation">,</span> flag<span class="token punctuation">.</span>ExitOnError<span class="token punctuation">)</span>    gocmd<span class="token punctuation">.</span><span class="token function">IntVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>intFlag<span class="token punctuation">,</span> <span class="token string">"intFlag"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"int flag"</span><span class="token punctuation">)</span>    gocmd<span class="token punctuation">.</span><span class="token function">BoolVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>boolFlag<span class="token punctuation">,</span> <span class="token string">"boolFlag"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"bool flag"</span><span class="token punctuation">)</span>    phpcmd <span class="token operator">:=</span> flag<span class="token punctuation">.</span><span class="token function">NewFlagSet</span><span class="token punctuation">(</span><span class="token string">"php"</span><span class="token punctuation">,</span> flag<span class="token punctuation">.</span>ExitOnError<span class="token punctuation">)</span>    phpcmd<span class="token punctuation">.</span><span class="token function">StringVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stringFlag<span class="token punctuation">,</span> <span class="token string">"stringFlag"</span><span class="token punctuation">,</span> <span class="token string">"default"</span><span class="token punctuation">,</span> <span class="token string">"string flag"</span><span class="token punctuation">)</span>    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    args <span class="token operator">:=</span> flag<span class="token punctuation">.</span><span class="token function">Args</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">switch</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">"go"</span><span class="token punctuation">:</span>        <span class="token boolean">_</span> <span class="token operator">=</span> gocmd<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token string">"php"</span><span class="token punctuation">:</span>        <span class="token boolean">_</span> <span class="token operator">=</span> phpcmd<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>intFlag<span class="token punctuation">,</span> boolFlag<span class="token punctuation">,</span> stringFlag<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">$ go run main.go go -intFlag<span class="token operator">=</span>10 -boolFlag<span class="token operator">=</span>true10 <span class="token boolean">true</span> default$ go run main.go php -stringFlag<span class="token operator">=</span>xxf0 <span class="token boolean">false</span> xxf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于需要处理子命令，因此调用了<code>flag.NewFlagSet</code>方法。该方法会返回带有指定名称和错误处理属性的空命令集，相当于创建一个新的命令集去支持子命令。</p><br><h3 id="1-2-实现原理"><a href="#1-2-实现原理" class="headerlink" title="1.2 实现原理"></a>1.2 实现原理</h3><h4 id="1-2-1-参数解析流"><a href="#1-2-1-参数解析流" class="headerlink" title="1.2.1 参数解析流"></a>1.2.1 参数解析流</h4><img src="/images/20211221/参数解析流.png" alt="参数解析流" style="zoom: 50%;"><p>还是以命令 <code>go run main.go -intFlag=10 -boolFlag -stringFlag xxf</code> 为例介绍参数解析流。</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// [/var/folders/95/d2xwj_5n4l94l392w1p6tsv00000gn/T/go-build2398467023/b001/exe/main -intFlag=10 -boolFlag -stringFlag xxf]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="1-2-1-1-flag-Parse"><a href="#1-2-1-1-flag-Parse" class="headerlink" title="1.2.1.1 flag.Parse"></a>1.2.1.1 flag.Parse</h5><p>命令行输入参数后，首先会调用<code>flag.Parse</code>，其功能是解析并绑定命令行参数。</p><img src="/images/20211221/flag.Parse.png" alt="flag.Parse" style="zoom:50%;"><img src="/images/20211221/CommandLine.png" alt="CommandLine" style="zoom:50%;"><p><code>flag</code>包中存在一个全局变量<code>CommandLine</code>即一个空的命令集，后续命令的添加都是对这个命令集合的扩展。 </p><p><code>os.Args[1:] = [-intFlag=10 -boolFlag -stringFlag xxf]</code></p><h5 id="1-2-1-2-FlagSet-Parse"><a href="#1-2-1-2-FlagSet-Parse" class="headerlink" title="1.2.1.2 FlagSet.Parse"></a>1.2.1.2 FlagSet.Parse</h5><p><code>FlagSet.Parse</code>是对解析方法的进一步封装，实际上解析逻辑放在了<code>parseOne</code>中，而解析过程中遇到的一些特殊情况，如重复解析、异常处理等，均直接由<code>FlagSet.Parse</code>进行处理。实际上，这是一个分层明显、结构清晰的方法设计，值得我们参考。</p><img src="/images/20211221/FlagSet.Parse.png" alt="FlagSet.Parse" style="zoom:50%;"><h5 id="1-2-1-3-FlagSet-parseOne"><a href="#1-2-1-3-FlagSet-parseOne" class="headerlink" title="1.2.1.3 FlagSet.parseOne"></a>1.2.1.3 FlagSet.parseOne</h5><p><code>FlagSet.parseOne </code>是命令行解析的核心方法，所有的命令最后都会流转到<code> FlagSet.parseOne</code>中进行处理，这个函数有 73 行，这里只放部分代码。</p><img src="/images/20211221/FlagSet.parseOne.png" alt="FlagSet.parseOne" style="zoom:50%;"><p>在上述代码中，主要是针对一些不符合命令行参数绑定规则的校验进行处理，大致分为以下四种情况：</p><ul><li>命令行参数长度为 0。</li><li>长度小于 2 或不满足 flag 标识符“-”。</li><li>如果flag标志位为“–”，则中断处理，并跳过该字符，也就是后续会以“-”进行处理。</li><li>在处理flag标志位后，如果取到的参数名不符合规则，则也将中断处理。</li></ul><p>在定位命令行参数节点上，采用的依据是根据“-”的索引定位解析出上下参数的名（name）和参数的值（value）。在设置参数值时，会对值类型进行判断。若是布尔类型，则调用定制的boolFlag类型进行判断和处理。最后，通过该flag提供的Value.Set方法将参数值设置到对应的flag中。</p><br><h4 id="1-2-2-flag定义流"><a href="#1-2-2-flag定义流" class="headerlink" title="1.2.2 flag定义流"></a>1.2.2 flag定义流</h4><p>这部分比较简单，以IntVar为例。</p><img src="/images/20211221/IntVar.png" alt="IntVar" style="zoom:50%;"><img src="/images/20211221/newIntValue.png" alt="newIntValue" style="zoom:50%;"><img src="/images/20211221/Var.png" alt="Var" style="zoom:50%;"><p>首先调用<code>newIntValue</code>将<code>value</code>与指针联系起来，然后创建一个<code>Flag</code>对象并将其绑定到FlagSet对象中，通过<code>map</code>存储与去重。</p><p><code>FlagSet</code>结构体定义</p><img src="/images/20211221/FlagSet.png" alt="FlagSet" style="zoom:50%;"><hr><br><h2 id="2-cobra框架"><a href="#2-cobra框架" class="headerlink" title="2 cobra框架"></a>2 cobra框架</h2><p><code>flag</code>作为官方命令行工具用起来很方便，但是也存在功能上的不足，如不支持长短选项，得重复定义比较繁琐。</p><p><code>Cobra</code>是Go的CLI框架。它包含一个用于创建强大的现代CLI应用程序的库，以及一个快速生成基于Cobra的应用程序和命令文件的工具。用起来十分简单方便，有很多著名的框架都是基于cobra的，截止 2021-12-21 在github上已经有 24k 个star了。</p><p><a href="https://cobra.dev/">Cobra.Dev</a></p><p><a href="https://github.com/spf13/cobra">https://github.com/spf13/cobra</a></p><p><strong>安装</strong></p><p><code>go get -u github.com/spf13/cobra/cobra</code></p><p><code>import "github.com/spf13/cobra"</code></p><br><h3 id="2-1-使用方式"><a href="#2-1-使用方式" class="headerlink" title="2.1 使用方式"></a>2.1 使用方式</h3><h4 id="2-1-1-组织结构"><a href="#2-1-1-组织结构" class="headerlink" title="2.1.1 组织结构"></a>2.1.1 组织结构</h4><p>一般在项目中，会将命令行指令封装在<code>cmd</code> 目录下，然后在<code>main.go</code>中初始化</p><pre class="line-numbers language-go"><code class="language-go">▾ appName<span class="token operator">/</span>    ▾ cmd<span class="token operator">/</span>        commands<span class="token punctuation">.</span><span class="token keyword">go</span>        here<span class="token punctuation">.</span><span class="token keyword">go</span>      main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"{pathToYourApp}/cmd"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  cmd<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-1-2-example"><a href="#2-1-2-example" class="headerlink" title="2.1.2 example"></a>2.1.2 example</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"os"</span>    <span class="token string">"github.com/spf13/cobra"</span><span class="token punctuation">)</span><span class="token keyword">var</span> <span class="token punctuation">(</span>    version  <span class="token builtin">string</span>    boolFlag <span class="token builtin">bool</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// flag在init函数中调用，可以设置长短命令</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    rootCmd<span class="token punctuation">.</span><span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">BoolVarP</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>boolFlag<span class="token punctuation">,</span> <span class="token string">"boolFlag"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"The bool flag"</span><span class="token punctuation">)</span>    rootCmd<span class="token punctuation">.</span><span class="token function">Flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">StringVarP</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>version<span class="token punctuation">,</span> <span class="token string">"version"</span><span class="token punctuation">,</span> <span class="token string">"v"</span><span class="token punctuation">,</span> <span class="token string">"1.0.1"</span><span class="token punctuation">,</span> <span class="token string">"The tool version"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 创建cobra实例</span><span class="token keyword">var</span> rootCmd <span class="token operator">=</span> <span class="token operator">&amp;</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">{</span>    Use<span class="token punctuation">:</span>   <span class="token string">"hugo"</span><span class="token punctuation">,</span>    Short<span class="token punctuation">:</span> <span class="token string">"Hugo is a very fast static site generator"</span><span class="token punctuation">,</span>    Long<span class="token punctuation">:</span> <span class="token string">`A Fast and Flexible Static Site Generator built with                love by spf13 and friends in Go.                Complete documentation is available at http://hugo.spf13.com`</span><span class="token punctuation">,</span>    Run<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span>cmd <span class="token operator">*</span>cobra<span class="token punctuation">.</span>Command<span class="token punctuation">,</span> args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"boolFlag"</span><span class="token punctuation">,</span> boolFlag<span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"version"</span><span class="token punctuation">,</span> version<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> err <span class="token operator">:=</span> rootCmd<span class="token punctuation">.</span><span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> CLI </tag>
            
            <tag> Cobra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go如何处理时间</title>
      <link href="/posts/8dce6245.html"/>
      <url>/posts/8dce6245.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go如何处理时间"><a href="#Go如何处理时间" class="headerlink" title="Go如何处理时间"></a>Go如何处理时间</h1><blockquote><p>参考<br>  《Go语言入门经典》23章 Go语言时间编程<br>  <a href="https://zhuanlan.zhihu.com/p/47754783">理解Golang的Time结构</a><br>  <a href="https://studygolang.com/articles/11975">深入理解GO时间处理(time.Time)</a><br>  <a href="https://blog.csdn.net/Star_CSU/article/details/86650684">golang 定时任务方面time.Sleep和time.Tick的优劣对比</a><br>  <a href="https://pkg.go.dev/time">官方文档time包</a> </p></blockquote><p>开发中经常会使用时间函数，如测试程序的运行时间。<code>Golang</code>提供了标准库 <code>time</code>，提供了一系列时间处理的方法。</p><br><h2 id="0-从一个例子开始"><a href="#0-从一个例子开始" class="headerlink" title="0 从一个例子开始"></a>0 从一个例子开始</h2><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 2021-12-16 21:02:30.094398 +0800 CST m=+0.000321334</span><span class="token comment" spellcheck="true">// 2021 December 16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常见时间单位换算：<br>1秒=1000毫秒(ms)<br>1秒=1,000,000 微秒(μs)<br>1秒=1,000,000,000 纳秒(ns)</p><p>上述代码利用 <code>time</code> 打印了当前时间和日期，其中打印日期还用到了类似链式编程的方法，打印出来的时间是什么意思呢？内部是如何实现的呢？下面对此进行分析。</p><br><br><h2 id="1-基础篇-时间对象"><a href="#1-基础篇-时间对象" class="headerlink" title="1 基础篇-时间对象"></a>1 基础篇-时间对象</h2><h3 id="1-1-Time结构体"><a href="#1-1-Time结构体" class="headerlink" title="1.1 Time结构体"></a>1.1 Time结构体</h3><h4 id="1-1-1-before-go-1-9"><a href="#1-1-1-before-go-1-9" class="headerlink" title="1.1.1 before go 1.9"></a>1.1.1 before go 1.9</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Time <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// sec gives the number of seconds elapsed since</span>    <span class="token comment" spellcheck="true">// January 1, year 1 00:00:00 UTC.</span>    sec <span class="token builtin">int64</span>    <span class="token comment" spellcheck="true">// nsec specifies a non-negative nanosecond</span>    <span class="token comment" spellcheck="true">// offset within the second named by Seconds.</span>    <span class="token comment" spellcheck="true">// It must be in the range [0, 999999999].</span>    nsec <span class="token builtin">int32</span>    <span class="token comment" spellcheck="true">// loc specifies the Location that should be used to</span>    <span class="token comment" spellcheck="true">// determine the minute, hour, month, day, and year</span>    <span class="token comment" spellcheck="true">// that correspond to this Time.</span>    <span class="token comment" spellcheck="true">// The nil location means UTC.</span>    <span class="token comment" spellcheck="true">// All UTC times are represented with loc==nil, never loc==&amp;utcLoc.</span>    loc <span class="token operator">*</span>Location<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sec</code> 表示从公元 <code>1年1月1日00:00:00 UTC</code>到要表示的整数秒数，<code>nsec</code>表示余下的纳秒数，<code>loc</code>表示时区。<code>sec</code>和<code>nsec</code>处理没有歧义的时间值， <code>loc</code>处理偏移量</p><br><h4 id="1-1-2-after-go-1-9"><a href="#1-1-2-after-go-1-9" class="headerlink" title="1.1.2 after go 1.9"></a>1.1.2 after go 1.9</h4><p>因为 2017 年闰一秒, 国际时钟调整,  Go 程序两次取<code>time.Now()</code>相减的时间差得到了意料之外的负数, 导致 cloudFlare 的 CDN 服务中断, 详见**<a href="https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/">https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/</a>**,  go1.9 在不影响已有应用代码的情况下修改了time.Time的实现。go1.9 的 time.Time 定义为</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Time <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// wall and ext encode the wall time seconds, wall time nanoseconds,</span>    <span class="token comment" spellcheck="true">// and optional monotonic clock reading in nanoseconds.</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),</span>    <span class="token comment" spellcheck="true">// a 33-bit seconds field, and a 30-bit wall time nanoseconds field.</span>    <span class="token comment" spellcheck="true">// The nanoseconds field is in the range [0, 999999999].</span>    <span class="token comment" spellcheck="true">// If the hasMonotonic bit is 0, then the 33-bit field must be zero</span>    <span class="token comment" spellcheck="true">// and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.</span>    <span class="token comment" spellcheck="true">// If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit</span>    <span class="token comment" spellcheck="true">// unsigned wall seconds since Jan 1 year 1885, and ext holds a</span>    <span class="token comment" spellcheck="true">// signed 64-bit monotonic clock reading, nanoseconds since process start.</span>    wall <span class="token builtin">uint64</span>    ext  <span class="token builtin">int64</span>    <span class="token comment" spellcheck="true">// loc specifies the Location that should be used to</span>    <span class="token comment" spellcheck="true">// determine the minute, hour, month, day, and year</span>    <span class="token comment" spellcheck="true">// that correspond to this Time.</span>    <span class="token comment" spellcheck="true">// The nil location means UTC.</span>    <span class="token comment" spellcheck="true">// All UTC times are represented with loc==nil, never loc==&amp;utcLoc.</span>    loc <span class="token operator">*</span>Location<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Time</code> 结构体主要包含三个字段：</p><ul><li>wall</li><li>ext</li><li>loc</li></ul><img src="/images/20211218/Time.png" alt="Time" style="zoom: 67%;"><p>Go语言的Time中存储了两种时钟：</p><ol><li><strong>Wall Clocks</strong> 用来报时，表示墙上挂的钟，即我们平时理解的时间，存储的形式是自 1885 年 1 月 1 日 0 时 0 分 0 秒以来的时间戳(不像很多语言保存的是Unix时间戳即表示到 1970 年 1 月 1 日)。关于这个 1885 年怎么来的，因为 Go 是可以表示超过 int32 的 unixtimestamp 的时间的，1885 应该是扩展出来的能表示的最小值。</li><li><strong>Monotonic Clocks</strong> 用来测量时间，单调时间，这个时间是自进程启动以来的时间戳，只会增长</li></ol><pre class="line-numbers language-go"><code class="language-go">tick <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token keyword">range</span> tick <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 2021-12-17 16:57:45.84885 +0800 CST m=+1.007167459</span><span class="token comment" spellcheck="true">// 2021-12-17 16:57:46.848403 +0800 CST m=+2.006741001</span><span class="token comment" spellcheck="true">// 2021-12-17 16:57:47.846837 +0800 CST m=+3.005196626</span><span class="token comment" spellcheck="true">// 2021-12-17 16:57:48.847365 +0800 CST m=+4.005746209</span><span class="token comment" spellcheck="true">// 2021-12-17 16:57:49.848387 +0800 CST m=+5.006789584</span><span class="token comment" spellcheck="true">// 2021-12-17 16:57:50.848322 +0800 CST m=+6.006746042</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="1-2-Location结构体"><a href="#1-2-Location结构体" class="headerlink" title="1.2 Location结构体"></a>1.2 Location结构体</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// A Location maps time instants to the zone in use at that time.</span><span class="token comment" spellcheck="true">// Typically, the Location represents the collection of time offsets</span><span class="token comment" spellcheck="true">// in use in a geographical area. For many Locations the time offset varies</span><span class="token comment" spellcheck="true">// depending on whether daylight savings time is in use at the time instant.</span><span class="token keyword">type</span> Location <span class="token keyword">struct</span> <span class="token punctuation">{</span>    name <span class="token builtin">string</span>    zone <span class="token punctuation">[</span><span class="token punctuation">]</span>zone    tx   <span class="token punctuation">[</span><span class="token punctuation">]</span>zoneTrans    <span class="token comment" spellcheck="true">// The tzdata information can be followed by a string that describes</span>    <span class="token comment" spellcheck="true">// how to handle DST transitions not recorded in zoneTrans.</span>    <span class="token comment" spellcheck="true">// The format is the TZ environment variable without a colon; see</span>    <span class="token comment" spellcheck="true">// https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html.</span>    <span class="token comment" spellcheck="true">// Example string, for America/Los_Angeles: PST8PDT,M3.2.0,M11.1.0</span>    extend <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// Most lookups will be for the current time.</span>    <span class="token comment" spellcheck="true">// To avoid the binary search through tx, keep a</span>    <span class="token comment" spellcheck="true">// static one-element cache that gives the correct</span>    <span class="token comment" spellcheck="true">// zone for the time when the Location was created.</span>    <span class="token comment" spellcheck="true">// if cacheStart &lt;= t &lt; cacheEnd,</span>    <span class="token comment" spellcheck="true">// lookup can return cacheZone.</span>    <span class="token comment" spellcheck="true">// The units for cacheStart and cacheEnd are seconds</span>    <span class="token comment" spellcheck="true">// since January 1, 1970 UTC, to match the argument</span>    <span class="token comment" spellcheck="true">// to lookup.</span>    cacheStart <span class="token builtin">int64</span>    cacheEnd   <span class="token builtin">int64</span>    cacheZone  <span class="token operator">*</span>zone<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要消除时区的影响，可参照世界标准时间<code>（Coordinated Universal Time，UTC）</code>。UTC是时间标准而非时区，它让不同地区的计算机有相同的参照物，而不用考虑相对时区。</p><p>如果本地时间比 UTC 时间快，例如中国的时间比 UTC 快 8 小时，就会写作 UTC+8，俗称东八区。相反，如果本地时间比 UTC 时间慢，例如夏威夷的时间比 UTC 时间慢 10 小时，就会写作 UTC-10，俗称西十区。中国虽然横跨 5 个时区(东五～东九)，但是按照北京时间进行统一(东八)。</p><hr><br><br><h2 id="2-入门篇-时间操作"><a href="#2-入门篇-时间操作" class="headerlink" title="2 入门篇-时间操作"></a>2 入门篇-时间操作</h2><p>时间操作的方法非常多，建议参考官方文档<a href="https://pkg.go.dev/time#pkg-index">time</a></p><p>下面主要针对经常使用的时间操作进行介绍：</p><h3 id="2-1-time-Now-获取当前时间"><a href="#2-1-time-Now-获取当前时间" class="headerlink" title="2.1 time.Now()获取当前时间"></a>2.1 time.Now()获取当前时间</h3><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 2021-12-18 14:21:15.653623 +0800 CST m=+0.000057626</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>time.Now()</code>返回本地时间，以上结果看出：<code>time.Now()</code>输出默认<code>CST</code>时区时间，<code>Local</code>是东八区的时间所以是<code>+0800</code>，<code>CST</code>是中部标准时间在中国是以东八区为标准，<code>m=+0.000057626</code>表示在当前进程的运行时间。</p><img src="/images/20211218/time.Now.png" alt="time.Now" style="zoom:50%;"><br><h3 id="2-2-设置时区"><a href="#2-2-设置时区" class="headerlink" title="2.2 设置时区"></a>2.2 设置时区</h3><pre class="line-numbers language-go"><code class="language-go">loc<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">LoadLocation</span><span class="token punctuation">(</span><span class="token string">"America/New_York"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>loc<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">In</span><span class="token punctuation">(</span>loc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// America/New_York</span><span class="token comment" spellcheck="true">// 2021-12-18 02:25:26.68076 -0500 EST</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LoadLocation(name string) (*Location, error)</code>可以设置时区，获得一个时区对象。</p><p><code>In(loc *Location) Time</code>可以传入一个时区对象返回该时区的时间。</p><br><h3 id="2-3-时间运算"><a href="#2-3-时间运算" class="headerlink" title="2.3 时间运算"></a>2.3 时间运算</h3><p>时间运算的前提是两个时间属于同一时区。</p><pre class="line-numbers language-go"><code class="language-go">a<span class="token punctuation">,</span> b <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 时间加减</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// a是否在b之后</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">Before</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// a是否在b之后前</span><span class="token comment" spellcheck="true">// 2021-12-18 15:38:29.399566 +0800 CST m=+0.000076168</span><span class="token comment" spellcheck="true">// 2021-12-18 15:38:31.399567 +0800 CST m=+2.000076334</span><span class="token comment" spellcheck="true">// false</span><span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="2-4-序列化与反序列化"><a href="#2-4-序列化与反序列化" class="headerlink" title="2.4 序列化与反序列化"></a>2.4 序列化与反序列化</h3><pre class="line-numbers language-go"><code class="language-go">format <span class="token operator">:=</span> <span class="token string">"20060102150405"</span>t1 <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2021-12-18 15:57:42.834868 +0800 CST m=+0.000058543</span>t2 <span class="token operator">:=</span> t1<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 20211218155742</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span>t3<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> t2<span class="token punctuation">)</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2021-12-18 15:57:42 +0000 UTC</span><span class="token comment" spellcheck="true">// format := "2006-01-02 15:04:05"</span><span class="token comment" spellcheck="true">// 2021-12-18 15:58:38.113167 +0800 CST m=+0.000058292</span><span class="token comment" spellcheck="true">// 2021-12-18 15:58:38</span><span class="token comment" spellcheck="true">// 2021-12-18 15:58:38 +0000 UTC</span><span class="token comment" spellcheck="true">// format := "2006/01/02 Monday January 03:04:05"</span><span class="token comment" spellcheck="true">// 2021-12-18 16:03:15.01808 +0800 CST m=+0.000077043</span><span class="token comment" spellcheck="true">// 2021/12/18 Saturday December 04:03:15</span><span class="token comment" spellcheck="true">// 2021-12-18 04:03:15 +0000 UTC</span><span class="token comment" spellcheck="true">// format := "2006年1月2日15点4分5秒 Mon Jan"</span><span class="token comment" spellcheck="true">// 2021-12-18 16:09:02.987355 +0800 CST m=+0.000073418</span><span class="token comment" spellcheck="true">// 2021年12月18日16点9分2秒 Sat Dec</span><span class="token comment" spellcheck="true">// 2021-12-18 16:09:02 +0000 UTC</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在按照指定格式打印时间时，首先需要记住一个时间 <code>Mon Jan 2 15:04:05 -0700 MST 2006</code> 即<code>2006年1月2日下午3点4分5秒 星期一</code>，这实际上是凑出来的时间，可能是为了方便记忆，但是为什不直接用<code>yyyy-MM-dd HH:mm:ss</code>呢？</p><p>有博客说这是golang开源的时间，这是错的，golang 的生日是 2009 年 11 月 10 日。</p><hr><br><br><h2 id="3-提升篇-定时器"><a href="#3-提升篇-定时器" class="headerlink" title="3 提升篇-定时器"></a>3 提升篇-定时器</h2><p>定时器在开发中用的很多，尤其是并发编程中，context 包中也有用到(超时控制)。</p><h3 id="3-1-time-After"><a href="#3-1-time-After" class="headerlink" title="3.1 time.After()"></a>3.1 time.After()</h3><p><code>After(d Duration) &lt;-chan Time</code>一般用来控制超时，开一个协程如果运行时间超过 1 秒，select 就会收到 After 通道的数据，将不再接收该协程的结果。</p><pre class="line-numbers language-go"><code class="language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>    ch <span class="token operator">&lt;-</span> <span class="token string">"result"</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">select</span> <span class="token punctuation">{</span><span class="token keyword">case</span> res <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Timeout!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="3-2-time-Tick-d-time-Duration"><a href="#3-2-time-Tick-d-time-Duration" class="headerlink" title="3.2 time.Tick(d time.Duration)"></a>3.2 time.Tick(d time.Duration)</h3><h4 id="3-2-1-Tick"><a href="#3-2-1-Tick" class="headerlink" title="3.2.1 Tick"></a>3.2.1 Tick</h4><p>使用<code>ticker</code>可让代码每隔特定的时间就重复执行一次。需要在很长的时间内定期执行任务时，这么做很有用，调用<code>Tick</code>函数会返回一个时间类型的<code>channel</code>。</p><pre class="line-numbers language-go"><code class="language-go">ticker <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">for</span> t <span class="token operator">:=</span> <span class="token keyword">range</span> ticker <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 2021-12-18 16:36:00.083872 +0800 CST m=+1.001646043</span><span class="token comment" spellcheck="true">// 2021-12-18 16:36:01.08731 +0800 CST m=+2.005127543</span><span class="token comment" spellcheck="true">// 2021-12-18 16:36:02.087241 +0800 CST m=+3.005102168</span><span class="token comment" spellcheck="true">// 2021-12-18 16:36:03.087233 +0800 CST m=+4.005137335</span><span class="token comment" spellcheck="true">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>time.Tick</code>是对<code>NewTicker</code>的封装，也可以直接使用<code>NewTicker</code>。</p><img src="/images/20211218/time.Tick.png" alt="time.Tick" style="zoom:50%;"><br><h4 id="3-2-2-Sleep"><a href="#3-2-2-Sleep" class="headerlink" title="3.2.2 Sleep"></a>3.2.2 Sleep</h4><p>实际上也可以使用<code>time.Sleep(d time.Duration)</code>来实现循环执行的定时任务：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">for</span> <span class="token punctuation">{</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那么两种实现方式之间有什么区别呢？哪种效率更高？</p><br><h4 id="3-2-3-Tick-vs-Sleep"><a href="#3-2-3-Tick-vs-Sleep" class="headerlink" title="3.2.3 Tick vs Sleep"></a>3.2.3 Tick vs Sleep</h4><p><strong>先说结论</strong></p><p>调用<code>Tick</code>函数会返回一个时间类型的<code>channel</code>，如果对<code>channel</code>稍微有些了解的话，我们首先会想到，既然是返回一个<code>channel</code>，在调用 <code>Tick</code>方法的过程中，必然创建了<code>goroutine</code>,该<code>goroutine</code>负责发送数据，唤醒被阻塞的定时任务。</p><p><code>Tick</code>，<code>Sleep</code>，包括<code>time.After</code>函数，都使用的<code>timer</code>结构体，都会被放在同一个协程中统一处理，这样看起来使用<code>Tick</code>，<code>Sleep</code>并没有什么区别。实际上是有区别的，<code>Sleep</code>是使用睡眠完成定时任务，需要被调度唤醒。<code>Tick</code>函数是使用<code>channel</code>阻塞当前协程，完成定时任务的执行。当前并不清楚<code>golang </code>阻塞和睡眠对资源的消耗会有什么区别，这方面不能给出建议。</p><p>但是使用<code>channel</code>阻塞协程完成定时任务比较灵活，可以结合<code>select</code>设置超时时间以及默认执行方法，而且可以设置<code>timer</code>的主动关闭，以及不需要每次都生成一个<code>timer</code>(这方面节省系统内存，垃圾收回也需要时间)。</p><p>所以，建议使用<code>time.Tick</code>完成定时任务。</p><p><strong>实现原理对比</strong></p><p>有空再补，先参考</p><p><a href="https://www.cyhone.com/articles/analysis-of-golang-timer/#Timer-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">https://www.cyhone.com/articles/analysis-of-golang-timer/#Timer-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0</a></p><br><br><br>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 时间处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go如何处理文件</title>
      <link href="/posts/27de4de0.html"/>
      <url>/posts/27de4de0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go如何处理文件"><a href="#Go如何处理文件" class="headerlink" title="Go如何处理文件"></a>Go如何处理文件</h1><ul><li><p>参考<br>《Go语言入门经典》21章 处理文件</p><p>  <a href="https://segmentfault.com/a/1190000017918542">Golang读写文件</a></p></li></ul><p>开发过程中经常会涉及到文件处理，如读取配置文件、写日志文件。下面归纳总结一下Go处理文件的方式，包括文件创建、读取、写入、删除等，对比不同的文件操作包如： <code>ioutil</code>、 <code>os</code>、 <code>bufio</code></p><hr><br><h2 id="1-使用-io-ioutil包"><a href="#1-使用-io-ioutil包" class="headerlink" title="1 使用 io/ioutil包"></a>1 使用 <code>io/ioutil</code>包</h2><p><code>io/ioutil</code>是标准库，但是其底层用的还是 <code>os</code> 包，提供的方法本质上是对 <code>os</code> 的封装。</p><ul><li>创建文件</li><li>写入文件</li><li>读取文件</li><li>读取目录内容</li></ul><h3 id="1-1-创建-amp-写入文件-WriteFile"><a href="#1-1-创建-amp-写入文件-WriteFile" class="headerlink" title="1.1 创建&amp;写入文件 WriteFile"></a>1.1 创建&amp;写入文件 <code>WriteFile</code></h3><p><code>WriteFile</code> 方法在写入文件时，如果文件不存在则会自动创建文件，如果文件存在则会覆盖写入。方法有三个参数：</p><ul><li>文件名(文件路径)</li><li>写入的数据(字节数组 <code>[]byte</code>)</li><li>文件模式(读写执行权限)</li></ul><p>当写入数据为 <code>nil</code> 时，创建的文件为空文件；</p><img src="/images/20211215/文件模式.png" alt="文件模式" style="zoom:50%;"><p>文件模式用四位数字表达如 0644 分别代表文件类型(普通文件)、文件所有者的权限、文件同组用户的权限、其他用户的权限。rwx分别代表读权限(4)、写权限(2)、执行权限(1)，如0644中的6代表文件所有者有文件的读写(4+2)权限。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"io/ioutil"</span>    <span class="token string">"log"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">WriteFile</span><span class="token punctuation">(</span><span class="token string">"./example.txt"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 创建空文件</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    data <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello golang! ！！"</span><span class="token punctuation">)</span>    err <span class="token operator">=</span> ioutil<span class="token punctuation">.</span><span class="token function">WriteFile</span><span class="token punctuation">(</span><span class="token string">"./example.txt"</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 创建文件并写入数据</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20211215/os.WiteFile.png" alt="os.WiteFile" style="zoom: 33%;"><p>内部调用的是 <code>os.WriteFile</code></p><br><br><h3 id="1-2-读取文件-ReadFile"><a href="#1-2-读取文件-ReadFile" class="headerlink" title="1.2 读取文件 ReadFile"></a>1.2 读取文件 <code>ReadFile</code></h3><p><code>ReadFile</code> 方法的参数是文件名(文件路径)，返回一个字节数组，将文件一次性读入内存。</p><pre class="line-numbers language-go"><code class="language-go">data<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"./example.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [104 101 108 108 111 32 103 111 108 97 110 103 33 32 239 188 129 239 188 129]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// hello golang! ！！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20211215/os.ReadFile.png" alt="os.ReadFile" style="zoom:33%;"><p>内部调用的是 <code>os.ReadFile</code></p><br><br><h3 id="1-3-读取目录内容-ReadDir"><a href="#1-3-读取目录内容-ReadDir" class="headerlink" title="1.3 读取目录内容 ReadDir"></a>1.3 读取目录内容 <code>ReadDir</code></h3><p><code>ReadDir</code> 方法的参数是目录路径，返回值是目录下的文件信息，实际上目录也是一种文件。</p><pre class="line-numbers language-go"><code class="language-go">dirData<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadDir</span><span class="token punctuation">(</span><span class="token string">"./"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> file <span class="token operator">:=</span> <span class="token keyword">range</span> dirData <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">.</span><span class="token function">Mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// example.txt -rw-r--r-- 20</span><span class="token comment" spellcheck="true">// float.go -rw-r--r-- 1257</span><span class="token comment" spellcheck="true">// go.mod -rw-r--r-- 46</span><span class="token comment" spellcheck="true">// json.go -rw-r--r-- 706</span><span class="token comment" spellcheck="true">// main.go -rw-r--r-- 233</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20211215/os.ReadDir.png" alt="os.ReadDir" style="zoom:33%;"><p>首先读目录文件，然后调用os的Readdir方法读取子文件信息，最后按文件名对文件进行排序。</p><p><code>FileInfo</code> 的定义如下：</p><img src="/images/20211215/FileInfo.png" alt="FileInfo" style="zoom:33%;"><p>实际上 <code>ioutil</code> 包的源码一共就83行(go 1.6)，也就封装了5个函数，除了上面的三个还有 <code>ReadAll(r io.Reader)</code> 和 <code>NopCloser(r io.Reader)</code> ，后面再说。</p><hr><br><br><br><h2 id="2-使用-os包"><a href="#2-使用-os包" class="headerlink" title="2 使用 os包"></a>2 使用 <code>os</code>包</h2><p>上面的<code>io/ioutil</code> 都是基于 <code>os</code> 包的封装，下面看看如何使用 <code>os</code> 包处理文件。源文件有 706 行(go 1.6)，支持的文件操作不胜枚举，举几个基础的操作。关键是要理解这些方法操作的对象是文件结构体 <code>File</code></p><ul><li>创建文件</li><li>读取文件</li><li>写入文件</li></ul><br><h3 id="2-1-创建文件"><a href="#2-1-创建文件" class="headerlink" title="2.1 创建文件"></a>2.1 创建文件</h3><p>创建文件可以通过以下方法：</p><ul><li><code>Create(name string)</code></li><li><code>OpenFile(name string, flag int, perm FileMode)</code></li></ul><br><h4 id="2-1-1-Create"><a href="#2-1-1-Create" class="headerlink" title="2.1.1 Create"></a>2.1.1 <code>Create</code></h4><p><code>Create(name string)</code> 是创建文件的专用方法，参数是方法名(路径)，返回值是文件结构体。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"log"</span>    <span class="token string">"os"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token string">"./test.txt"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span><span class="token function">Fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ./test.txt 3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20211215/os.Create.png" alt="os.Create" style="zoom:33%;"><p>实际上是对 <code>OpenFile(name string, flag int, perm FileMode)</code> 的封装。</p><p>返回的 <code>File</code> 的定义如下，其中FD是指文件描述符。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// /usr/local/go/src/os/types.go</span><span class="token comment" spellcheck="true">// File represents an open file descriptor.</span><span class="token keyword">type</span> File <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>file <span class="token comment" spellcheck="true">// os specific</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// /usr/local/go/src/os/file_unix.go</span><span class="token comment" spellcheck="true">// file is the real representation of *File.</span><span class="token comment" spellcheck="true">// The extra level of indirection ensures that no clients of os</span><span class="token comment" spellcheck="true">// can overwrite this data, which could cause the finalizer</span><span class="token comment" spellcheck="true">// to close the wrong file descriptor.</span><span class="token keyword">type</span> file <span class="token keyword">struct</span> <span class="token punctuation">{</span>    pfd         poll<span class="token punctuation">.</span>FD    name        <span class="token builtin">string</span>    dirinfo     <span class="token operator">*</span>dirInfo <span class="token comment" spellcheck="true">// nil unless directory being read</span>    nonblock    <span class="token builtin">bool</span>     <span class="token comment" spellcheck="true">// whether we set nonblocking mode</span>    stdoutOrErr <span class="token builtin">bool</span>     <span class="token comment" spellcheck="true">// whether this is stdout or stderr</span>    appendMode  <span class="token builtin">bool</span>     <span class="token comment" spellcheck="true">// whether file is opened for appending</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-1-2-OpenFile"><a href="#2-1-2-OpenFile" class="headerlink" title="2.1.2 OpenFile"></a>2.1.2 <code>OpenFile</code></h4><p><code>OpenFile(name string, flag int, perm FileMode)</code>方法返回值也是文件结构体，有三个参数：</p><ul><li>文件路径</li><li>文件的打开方式</li><li>文件模式</li></ul><p>文件的打开方式有：</p><img src="/images/20211215/打开方式.png" alt="打开方式" style="zoom:33%;"><p>上面的 <code>Create</code> 方法就使用了可读可写｜创建文件｜缩短文件，表示创建了文件后了文件结构体，可以通过该文件结构体对文件进行读写操作。</p><img src="/images/20211215/os.OpenFile.png" alt="os.OpenFile" style="zoom:33%;"><pre class="line-numbers language-go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"./test.txt"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_CREATE<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span><span class="token function">Fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ./test.txt 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><h3 id="2-2-读取文件"><a href="#2-2-读取文件" class="headerlink" title="2.2 读取文件"></a>2.2 读取文件</h3><p>读取文件实际上是对文件结构体 <code>File</code> 进行操作，首先 <code>Open</code>打开文件(记得手动关闭)，然后以返回的 <code>File</code> 对象为入口读取数据。</p><p>读文件又可以分成 <code>带缓冲的读取</code> 和<code>不带缓冲的读取</code></p><br><h4 id="2-2-1-不带缓冲的读取"><a href="#2-2-1-不带缓冲的读取" class="headerlink" title="2.2.1 不带缓冲的读取"></a>2.2.1 不带缓冲的读取</h4><p><strong>方法一：使用 <code>ioutil.ReadAll(r io.Reader)</code> 读取</strong></p><p><code>io.Reader</code> 是一个声明了 <code>Read</code> 方法的接口，因为<code>File</code> 结构体实现了<code>Read</code> 所以可以直接作为参数(鸭子模型)。</p><pre class="line-numbers language-go"><code class="language-go">file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./example.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>content<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// hello golang! ！！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法二：使用<code>os.ReadFile(name string)</code> 读取</strong></p><p><code>os</code> 本身也将上述逻辑封装成了 <code>ReadFile(name string) ([]byte, error)</code> 方法，这是不带缓冲的读取，即将数据一次性读入内存，其中循环将数据写入字节数组，还是看不太懂为什么得这样做(留个坑～～～)</p><pre class="line-numbers language-go"><code class="language-go">content<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"./example.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// hello golang! ！！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// ReadFile reads the named file and returns the contents.</span><span class="token comment" spellcheck="true">// A successful call returns err == nil, not err == EOF.</span><span class="token comment" spellcheck="true">// Because ReadFile reads the whole file, it does not treat an EOF from Read</span><span class="token comment" spellcheck="true">// as an error to be reported.</span><span class="token keyword">func</span> <span class="token function">ReadFile</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">Open</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> size <span class="token builtin">int</span>    <span class="token keyword">if</span> info<span class="token punctuation">,</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Stat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        size64 <span class="token operator">:=</span> info<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">int</span><span class="token punctuation">(</span>size64<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> size64 <span class="token punctuation">{</span>            size <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>size64<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    size<span class="token operator">++</span> <span class="token comment" spellcheck="true">// one byte for final read at EOF</span>    <span class="token comment" spellcheck="true">// If a file claims a small size, read at least 512 bytes.</span>    <span class="token comment" spellcheck="true">// In particular, files in Linux's /proc claim size 0 but</span>    <span class="token comment" spellcheck="true">// then do not work right if read in small pieces,</span>    <span class="token comment" spellcheck="true">// so an initial read of 1 byte would not work correctly.</span>    <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">512</span> <span class="token punctuation">{</span>        size <span class="token operator">=</span> <span class="token number">512</span>    <span class="token punctuation">}</span>    data <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token function">cap</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            d <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">cap</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            data <span class="token operator">=</span> d<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>        n<span class="token punctuation">,</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token function">cap</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        data <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">+</span>n<span class="token punctuation">]</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>                err <span class="token operator">=</span> <span class="token boolean">nil</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> data<span class="token punctuation">,</span> err        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h4 id="2-2-2-带缓冲的读取"><a href="#2-2-2-带缓冲的读取" class="headerlink" title="2.2.2 带缓冲的读取"></a>2.2.2 带缓冲的读取</h4><p>一次性读入内存，系统可能会因为文件过大而卡死，此时可以采用类似于流的形式，每次读一部分。</p><pre class="line-numbers language-go"><code class="language-go">file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./example.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>chunks <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 每次读5个字节</span><span class="token keyword">for</span> <span class="token punctuation">{</span>    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> err <span class="token operator">!=</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    chunks <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>chunks<span class="token punctuation">,</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>chunks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// hello</span><span class="token comment" spellcheck="true">//  gola</span><span class="token comment" spellcheck="true">// ng!!!</span><span class="token comment" spellcheck="true">// hello golang!!!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对带缓存的读写， <code>bufio</code> 包中封装了很多好用的函数，可以按字节读也可以按行读，上面的代码可以进行如下改写：</p><pre class="line-numbers language-go"><code class="language-go">file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./example.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>r <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>chunks <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 每次读五个字节</span><span class="token keyword">for</span> <span class="token punctuation">{</span>    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> err <span class="token operator">!=</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    chunks <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>chunks<span class="token punctuation">,</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>chunks<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按行读文件</p><pre class="line-numbers language-go"><code class="language-go">file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./example.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>r <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>    line<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>    line <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">TrimSpace</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"File read ok!"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Read file error!"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">break</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// hello golang!!!</span><span class="token comment" spellcheck="true">// hello bufio!!!</span><span class="token comment" spellcheck="true">// File read ok!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><br><h3 id="2-3-写入文件"><a href="#2-3-写入文件" class="headerlink" title="2.3 写入文件"></a>2.3 写入文件</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"log"</span>    <span class="token string">"os"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">checkFileIsExist</span><span class="token punctuation">(</span>filename <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Stat</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span> os<span class="token punctuation">.</span><span class="token function">IsNotExist</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> filename <span class="token operator">=</span> <span class="token string">"./example.txt"</span>    <span class="token keyword">var</span> f <span class="token operator">*</span>os<span class="token punctuation">.</span>File    <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"hello os!!!\n"</span>    <span class="token keyword">var</span> err <span class="token builtin">error</span>    <span class="token keyword">if</span> <span class="token function">checkFileIsExist</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果文件存在</span>        f<span class="token punctuation">,</span> err <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_WRONLY<span class="token operator">|</span>os<span class="token punctuation">.</span>O_APPEND<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//打开文件</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件存在"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        f<span class="token punctuation">,</span> err <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//创建文件</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件不存在"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    n<span class="token punctuation">,</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//写入字节数组</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"[]byte写入%d个字节\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>    n<span class="token punctuation">,</span> err <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//写入文件字符串</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"string写入%d个字节\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// f.Sync() // 将文件扇入磁盘</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以使用 <code>bufio.WriteFile</code> 改写</p><hr><br><br><h2 id="3-性能对比"><a href="#3-性能对比" class="headerlink" title="3 性能对比"></a>3 性能对比</h2><p>留个坑 有时间再写吧</p><br><br><br>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go如何处理JSON</title>
      <link href="/posts/1a5d8f5c.html"/>
      <url>/posts/1a5d8f5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go如何处理JSON"><a href="#Go如何处理JSON" class="headerlink" title="Go如何处理JSON"></a>Go如何处理JSON</h1><blockquote><p>参考《Go语言入门经典》第20章 处理JSON</p></blockquote><p>JSON作为前后端交互的通用格式，在日常开发中经常会使用到，尤其对于后端开发者要弄清楚如何完成JSON的编码与解码，以及如何通过HTTP请求的读写JSON数据。</p><h2 id="1-JSON简介"><a href="#1-JSON简介" class="headerlink" title="1 JSON简介"></a>1 JSON简介</h2><p>JSON(JavaScript Object Notion)即JavaScript对象表示法，类似于txt是一种数据存储格式。最初是JavaScript的一个子集，JavaScript天然支持JSON。</p><p>JSON数据主要以key-value的形式进行组织，包含在一个JSON对象中，支持7种数据类型(6种基本类型+1种空类型)</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"zhangsan"</span><span class="token punctuation">,</span> // String    <span class="token property">"sex"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> // Boolean    <span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span> // Number    <span class="token property">"height"</span><span class="token operator">:</span> <span class="token number">176.5</span><span class="token punctuation">,</span> // Number    <span class="token property">"hobby"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"pingpon"</span><span class="token punctuation">,</span> <span class="token string">"basketball"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> // Array    <span class="token property">"father"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"lisi"</span><span class="token punctuation">,</span> <span class="token property">"age"</span><span class="token operator">:</span> <span class="token number">48</span><span class="token punctuation">}</span><span class="token punctuation">,</span> // Object    <span class="token property">"grilfriend"</span><span class="token operator">:</span> <span class="token null">null</span> // <span class="token null">NULL</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：整数和浮点数都是Number</p><hr><h2 id="2-Go处理JSON"><a href="#2-Go处理JSON" class="headerlink" title="2 Go处理JSON"></a>2 Go处理JSON</h2><p>Go语言十分适合服务端开发，提供了 <code>encoding/json</code> 包用于JSON数据的编码和解码。</p><h3 id="2-1-编码"><a href="#2-1-编码" class="headerlink" title="2.1 编码"></a>2.1 编码</h3><p>encoding/json包提供了函数 <code>Marshal</code>，返回编码后的字节数组，用于将Go数据编码为JSON。</p><p>需要注意的是struct字段的首字母需要大写，不然无法编码。比如下面Person对象中的age和hobby无法导出。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name  <span class="token builtin">string</span>    age   <span class="token builtin">int</span>    hobby <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    hobby <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"pingpon"</span><span class="token punctuation">,</span> <span class="token string">"basketball"</span><span class="token punctuation">}</span>    p <span class="token operator">:=</span> Person<span class="token punctuation">{</span>        Name<span class="token punctuation">:</span>  <span class="token string">"zhangsan"</span><span class="token punctuation">,</span>        age<span class="token punctuation">:</span>   <span class="token number">18</span><span class="token punctuation">,</span>        hobby<span class="token punctuation">:</span> hobby<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>    jsonByteData<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>jsonByteData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// {Name:zhangsan age:18 hobby:[pingpon basketball]}</span><span class="token comment" spellcheck="true">// {"Name":"zhangsan"}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-1-struct字段设置可导出"><a href="#2-1-1-struct字段设置可导出" class="headerlink" title="2.1.1 struct字段设置可导出"></a>2.1.1 struct字段设置可导出</h4><p>把Person的定义改成如下形式，即可全部导出。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name  <span class="token builtin">string</span>    Age   <span class="token builtin">int</span>    Hobby <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// {Name:zhangsan Age:18 Hobby:[pingpon basketball]}</span><span class="token comment" spellcheck="true">// {"Name":"zhangsan","Age":18,"Hobby":["pingpon","basketball"]}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这样有个问题，导出json数据的key是首字母大写，如果需要小写怎么办呢？</p><h4 id="2-1-2-自定义导出的key"><a href="#2-1-2-自定义导出的key" class="headerlink" title="2.1.2 自定义导出的key"></a>2.1.2 自定义导出的key</h4><p>给字段加上标签tag即可自定义导出的key</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name  <span class="token builtin">string</span>   <span class="token string">`json:"name"`</span>    Age   <span class="token builtin">int</span>      <span class="token string">`json:"age"`</span>    Hobby <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`json:"hobbies"`</span> <span class="token comment" spellcheck="true">// 自定义</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// {Name:zhangsan Age:18 Hobby:[pingpon basketball]}</span><span class="token comment" spellcheck="true">// {"name":"zhangsan","age":18,"hobbies":["pingpon","basketball"]}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-3-空类型"><a href="#2-1-3-空类型" class="headerlink" title="2.1.3 空类型"></a>2.1.3 空类型</h4><p>如果go数据为nil，那么编码出来的JSON也是空类型, 想要忽略空类型的话，在struct的tag里添加omitempty即可</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 不忽略空类型</span><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name  <span class="token builtin">string</span>   <span class="token string">`json:"name"`</span>    Age   <span class="token builtin">int</span>      <span class="token string">`json:"age"`</span>    Hobby <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`json:"hobbies"`</span><span class="token punctuation">}</span>p <span class="token operator">:=</span> Person<span class="token punctuation">{</span>        Name<span class="token punctuation">:</span>  <span class="token string">"zhangsan"</span><span class="token punctuation">,</span>        Age<span class="token punctuation">:</span>   <span class="token number">18</span><span class="token punctuation">,</span>        Hobby<span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>    jsonByteData<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>jsonByteData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// {Name:zhangsan Age:18 Hobby:[]}</span><span class="token comment" spellcheck="true">// {"name":"zhangsan","age":18,"hobbies":null}</span><span class="token comment" spellcheck="true">// -----------------------------------------------------</span><span class="token comment" spellcheck="true">// 忽略空类型 omitempty</span><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name  <span class="token builtin">string</span>   <span class="token string">`json:"name,omitempty"`</span>    Age   <span class="token builtin">int</span>      <span class="token string">`json:"age,omitempty"`</span>    Hobby <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`json:"hobbies,omitempty"`</span><span class="token punctuation">}</span>p <span class="token operator">:=</span> Person<span class="token punctuation">{</span>        Name<span class="token punctuation">:</span>  <span class="token string">"zhangsan"</span><span class="token punctuation">,</span>        Age<span class="token punctuation">:</span>   <span class="token number">18</span><span class="token punctuation">,</span>        Hobby<span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>    jsonByteData<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>jsonByteData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// {Name:zhangsan Age:18 Hobby:[]}</span><span class="token comment" spellcheck="true">// {"name":"zhangsan","age":18}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-解码"><a href="#2-2-解码" class="headerlink" title="2.2 解码"></a>2.2 解码</h3><p>encoding/json包提供了函数 <code>Unmarshal</code>，接受一个字节切片以及一个指定要将数据解码为何种格式的接口，用于将JSON解码为Go数据。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name  <span class="token builtin">string</span>   <span class="token string">`json:"name,omitempty"`</span>    Age   <span class="token builtin">int</span>      <span class="token string">`json:"age,omitempty"`</span>    Hobby <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`json:"hobbies,omitempty"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    jsonString <span class="token operator">:=</span> <span class="token string">`{"name":"zhangsan","age":18,"hobbies":["pingpon","basketball"]}`</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>    p <span class="token operator">:=</span> Person<span class="token punctuation">{</span><span class="token punctuation">}</span>    err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// {"name":"zhangsan","age":18,"hobbies":["pingpon","basketball"]}</span><span class="token comment" spellcheck="true">// {Name:zhangsan Age:18 Hobby:[pingpon basketball]}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20211213/Untitled.png" alt="JSON和Go之间映射数据类型" style="zoom: 50%;"><hr><h2 id="3-通过HTTP读写JSON"><a href="#3-通过HTTP读写JSON" class="headerlink" title="3 通过HTTP读写JSON"></a>3 通过HTTP读写JSON</h2><h3 id="3-1-读出JSON"><a href="#3-1-读出JSON" class="headerlink" title="3.1 读出JSON"></a>3.1 读出JSON</h3><p>在Go语言中，通过HTTP请求获取JSON时，收到的数据为流而不是字符串或字节切片。在这种情况下，应使用encoding/json包中的另一个方法 <code>NewDecoder</code>。</p><p><code>NewDecoder</code>函数接受一个io.Reader（这正是http.Get返回的类型），并返回一个Decoder。通过对返回的Decoder调用方法Decode，可将数据解码为结构体。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Id        <span class="token builtin">int64</span>  <span class="token string">`json:"id,omitempty"`</span>    Name      <span class="token builtin">string</span> <span class="token string">`json:"name,omitempty"`</span>    CreatedAt <span class="token builtin">string</span> <span class="token string">`json:"created_at,omitempty"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"https://api.github.com/users/xxf0512"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> res<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> u User    err <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>u<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// {Id:49829039 Name:xxf CreatedAt:2019-04-21T06:14:00Z}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-写入JSON"><a href="#3-2-写入JSON" class="headerlink" title="3.2 写入JSON"></a>3.2 写入JSON</h3><p>模拟发送一个post请求，其中写入JSON</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"encoding/json"</span>    <span class="token string">"fmt"</span>    <span class="token string">"io/ioutil"</span>    <span class="token string">"log"</span>    <span class="token string">"net/http"</span>    <span class="token string">"strings"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Weather <span class="token keyword">struct</span> <span class="token punctuation">{</span>    UserId <span class="token builtin">int</span>    <span class="token string">`json:"userId"`</span>    Body   <span class="token builtin">string</span> <span class="token string">`json:"body"`</span>    Title  <span class="token builtin">string</span> <span class="token string">`json:"title"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    w <span class="token operator">:=</span> Weather<span class="token punctuation">{</span>        UserId<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>        Body<span class="token punctuation">:</span>   <span class="token string">"This is body"</span><span class="token punctuation">,</span>        Title<span class="token punctuation">:</span>  <span class="token string">"This is title"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    str<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>    postData <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"postData: "</span><span class="token punctuation">,</span> postData<span class="token punctuation">)</span>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Post</span><span class="token punctuation">(</span><span class="token string">"https://jsonplaceholder.typicode.com/posts"</span><span class="token punctuation">,</span> <span class="token string">"application/x-www-form-urlencoded"</span><span class="token punctuation">,</span> strings<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>postData<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> res<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    body<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里Content-Type是application/x-www-form-urlencoded，关于Content-Type可以参考下面的文章，后面再就Content-Type写一篇博客。</p><p><a href="https://www.cnblogs.com/fighter007/p/10917026.html">Content-Type四种常见取值</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浮点数设计原理</title>
      <link href="/posts/fc8b6575.html"/>
      <url>/posts/fc8b6575.html</url>
      
        <content type="html"><![CDATA[<h1 id="浮点数设计原理"><a href="#浮点数设计原理" class="headerlink" title="浮点数设计原理"></a>浮点数设计原理</h1><blockquote><p>参考</p><p>《Go语言底层原理剖析》第2章 浮点数设计原理与使用方法 </p><p><a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">浮点数的二进制表示 - 阮一峰的网络日志</a></p></blockquote><h2 id="1-从一个例子说起"><a href="#1-从一个例子说起" class="headerlink" title="1 从一个例子说起"></a>1 从一个例子说起</h2><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> d1<span class="token punctuation">,</span> d2 <span class="token builtin">float64</span>  d1 <span class="token operator">=</span> <span class="token number">0.3</span>  d2 <span class="token operator">=</span> <span class="token number">0.6</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>d1 <span class="token operator">+</span> d2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0.8999999999999999</span>  <span class="token keyword">var</span> f1 f2 <span class="token builtin">float32</span>  f1 <span class="token operator">=</span> <span class="token number">0.3</span>  f2 <span class="token operator">=</span> <span class="token number">0.6</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f1 <span class="token operator">+</span> f2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0.90000004</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的浮点数计算的结果与我们想象的好像不太一样，<strong>为什么0.3+0.6的结果不是0.9呢？</strong></p><p>下面将展开讲解浮点数在计算机中的 <strong>存储方式</strong> 以及 精度损失 的概念，最后对这个🌰进行解释。</p><hr><h2 id="2-存储方式"><a href="#2-存储方式" class="headerlink" title="2 存储方式"></a>2 存储方式</h2><p>众所周知，所有数据在计算机中都是以二进制的形式进行存储的。整数比较简单，转换为二进制数即可，而小数怎么转换呢？尤其是3.141592…这种无限小数如何利用有限的二进制位进行存储呢？</p><p>小数目前有两种存储方式：定点数 &amp; 浮点数。计算机中采用的是浮点数。</p><h3 id="2-1-定点数"><a href="#2-1-定点数" class="headerlink" title="2.1 定点数"></a>2.1 定点数</h3><p>定点数比较简单，<strong>固定小数点的位置</strong>，小数点前的二进制数表示整数部分 &amp; 小数点后的二进制数表示小数部分。</p><p>但是对于0.1234…这种整数部分很小或者…12345.1这种整数小数部分精度很低的数据，定点数就不适合了，它的扩展性很差。</p><h3 id="2-2-浮点数"><a href="#2-2-浮点数" class="headerlink" title="2.2 浮点数"></a>2.2 浮点数</h3><p>浮点数小数点的位置是浮动的(不固定)，采用科学计数法来表示：<br>$$<br>V = (-1)^S \times M \times R^E<br>$$<br>S表示符号位、M表示尾数、R表示基数、E表示指数</p><p>例如十进制3.1415小数用科学计数法可以表示为：<br>$$<br>3.1415 = 3.1415 * 10^0<br>$$<br>$$<br>3.1415 = 31.415 * 10^{-1}<br>$$<br>$$<br>3.1415 = 314.15 * 10^{-2}<br>$$<br>那么采用哪种方式来表示？指数位和尾数位各应该是多少？这就得引入 <strong>IEEE754 浮点数标准</strong></p><h3 id="2-3-IEEE754浮点数标准"><a href="#2-3-IEEE754浮点数标准" class="headerlink" title="2.3 IEEE754浮点数标准"></a>2.3 IEEE754浮点数标准</h3><p>该标准规定科学计数法底数R=2：<br>$$<br>V = (-1)^S \times M \times 2^E<br>$$<br>还规定<strong>对于32位浮点数。最高1位是符号位S，中间8位是指数E，最后23位是尾数M</strong></p><img src="/images/20211212/floa32.png" alt="float32" style="zoom:50%;"><p><strong>对于64位浮点数。最高1位是符号位S，中间11位是指数E，最后52位是尾数M</strong></p><img src="/images/20211212/float64.png" alt="float64" style="zoom: 50%;"><img src="/images/20211212/2to10.png" alt="2to10" style="zoom: 50%;"><p>需要注意的是，转化为二进制后M是一个01串，可以将其向左平移至整数位为1，此时M的第一位始终为1，为了节省空间从而增大精度可以直接把1去掉。</p><p>举个🌰：0.75的二进制为0.11000…，向左平移后：1.100…，再把整数位的1去掉：0.100…，于是0.75的尾数为1000…</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"math"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">calfloat</span><span class="token punctuation">(</span><span class="token number">0.75</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">calfloat</span><span class="token punctuation">(</span>x <span class="token builtin">float32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  f <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">Float32bits</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  bits <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.32b"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"float32:"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bits:"</span><span class="token punctuation">,</span> bits<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"S:"</span><span class="token punctuation">,</span> bits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"E:"</span><span class="token punctuation">,</span> bits<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"M:"</span><span class="token punctuation">,</span> bits<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  bias <span class="token operator">:=</span> <span class="token number">127</span> <span class="token comment" spellcheck="true">// 偏移量</span>  sign <span class="token operator">:=</span> f <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span>  exponentRaw <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>f <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span>  exponent <span class="token operator">:=</span> exponentRaw <span class="token operator">-</span> bias  <span class="token keyword">var</span> mantissa <span class="token builtin">float32</span>  <span class="token keyword">for</span> index<span class="token punctuation">,</span> bit <span class="token operator">:=</span> <span class="token keyword">range</span> bits<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> bit <span class="token operator">==</span> <span class="token string">'1'</span> <span class="token punctuation">{</span>      bitValue <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">Pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      mantissa <span class="token operator">+=</span> <span class="token function">float32</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> bitValue<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  value <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> mantissa<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">float32</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>exponent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"sign: %d,  Exponent: %d(%d)  Mantissa: %f  Value: %f \n"</span><span class="token punctuation">,</span> sign<span class="token punctuation">,</span> exponentRaw<span class="token punctuation">,</span> exponent<span class="token punctuation">,</span> mantissa<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20211212/075.png" alt="0.75" style="zoom: 50%;"><p>其中bias表示偏移量，这是为了表达负数，对于32位浮点数，把[0, 2^8-1]即[0, 255]偏移到[-127, 128]需要减去127。对于64位浮点数bias=1023</p><hr><h2 id="3-浮点数精度"><a href="#3-浮点数精度" class="headerlink" title="3 浮点数精度"></a>3 浮点数精度</h2><p>一般讨论浮点数精度针对的是十进制下的浮点数，实际上浮点数的精度是不固定的，单精度浮点数float32的精度为6～8位，双精度浮点数float64的精度为15～17位。</p><p>浮点数的定义：在一个范围内，将d位十进制数（按照科学计数法表达）转换为二进制数，再将二进制数转换为d位十进制数，如果数据转换不发生损失，则意味着在此范围内有d位精度。</p><img src="/images/20211212/jingdu.png" alt="精度" style="zoom:50%;"><p>精度存在的原因在于，数据在进制之间相互转换时，不是精准匹配的，而是匹配到一个最接近的值。</p><p>如图(a)所示，十进制数转换为二进制数，二进制数又转换为十进制数，如果能够还原为最初的值，那么转换精度是无损的，说明在当前范围内浮点数是有d位精度的。反之，如图(b)所示，d位十进制数转换为二进制数，二进制数又转换为d位十进制数，得到的并不是原来的值，那么说明在该范围内浮点数没有d位精度。</p><hr><h2 id="4-回到最初的例子"><a href="#4-回到最初的例子" class="headerlink" title="4 回到最初的例子"></a>4 回到最初的例子</h2><p>为什么单精度浮点数&amp;多精度浮点数表达0.3+0.6会有不同的结果呢？</p><p>首先需要明确的是<code>fmt.Println</code> <code>fmt.Printf</code> 内部对浮点数进行了复杂的运算，将其转换为了最接近的十进制数。</p><pre class="line-numbers language-go"><code class="language-go">  x <span class="token operator">:=</span> <span class="token function">float32</span><span class="token punctuation">(</span><span class="token number">0.90000000</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0.900000</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%.7f\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0.9000000</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%.8f\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0.89999998</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%.9f\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0.899999976</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认打印小数点后6位，单精度浮点数在存储和表示0.9时精度为7，小数点后八位开始就有精度问题了。</p><p>实际上，除了浮点数表示会丢失精度，浮点数计算也会丢失精度，那么例子里是什么原因导致精度丢失到呢？下面再做个实验</p><pre class="line-numbers language-go"><code class="language-go">  <span class="token keyword">var</span> d1<span class="token punctuation">,</span> d2 <span class="token builtin">float64</span>  d1 <span class="token operator">=</span> <span class="token number">0.4</span>  d2 <span class="token operator">=</span> <span class="token number">0.5</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>d1 <span class="token operator">+</span> d2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0.9</span>  <span class="token keyword">var</span> f1<span class="token punctuation">,</span> f2 <span class="token builtin">float32</span>  f1 <span class="token operator">=</span> <span class="token number">0.4</span>  f2 <span class="token operator">=</span> <span class="token number">0.5</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f1 <span class="token operator">+</span> f2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0.9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>0.4+0.5并没有丢失精度，那么可以基本判断例子中是因为浮点数计算导致的精度丢失。</p><p><strong>对于单精度浮点数</strong></p><img src="/images/20211212/float32_03.png" alt="float32-0.3" style="zoom:50%;"><img src="/images/20211212/float32_06.png" alt="float32-0.6" style="zoom:50%;"><p>0.3的二进制：(1.00110011001100110011010x2^-2) -&gt; 0.0100110011001100110011010 -&gt; (0.30000001192092896)实际上不等于0.3<br>0.6的二进制：(1.00110011001100110011010x2^-1)  -&gt; 0.10110011001100110011010 -&gt; (0.7000000476837158) 实际上不等于0.6<br>0.3+0.6=     ：0.1110011001100110011001110<br>转为十进制为 <strong>0.90000004</strong></p><p><strong>对于双精度浮点数</strong></p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">calfloat</span><span class="token punctuation">(</span>x <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  f <span class="token operator">:=</span> math<span class="token punctuation">.</span><span class="token function">Float64bits</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  bits <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%.64b"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"float64:"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bits:"</span><span class="token punctuation">,</span> bits<span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"S:"</span><span class="token punctuation">,</span> bits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"E:"</span><span class="token punctuation">,</span> bits<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"M:"</span><span class="token punctuation">,</span> bits<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  bias <span class="token operator">:=</span> <span class="token number">1023</span>  sign <span class="token operator">:=</span> f <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">63</span><span class="token punctuation">)</span>  exponentRaw <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>f <span class="token operator">>></span> <span class="token number">52</span><span class="token punctuation">)</span>  exponent <span class="token operator">:=</span> exponentRaw <span class="token operator">-</span> bias  <span class="token keyword">var</span> mantissa <span class="token builtin">float64</span>  <span class="token keyword">for</span> index<span class="token punctuation">,</span> bit <span class="token operator">:=</span> <span class="token keyword">range</span> bits<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> bit <span class="token operator">==</span> <span class="token string">'1'</span> <span class="token punctuation">{</span>      mantissa <span class="token operator">+=</span> math<span class="token punctuation">.</span><span class="token function">Pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">*</span><span class="token function">float64</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  value <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> mantissa<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">float64</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>exponent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"sign: %d,  Exponent: %d(%d)  Mantissa: %f  Value: %f \n"</span><span class="token punctuation">,</span> sign<span class="token punctuation">,</span> exponentRaw<span class="token punctuation">,</span> exponent<span class="token punctuation">,</span> mantissa<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/images/20211212/float64_03.png" alt="float64-0.3" style="zoom:50%;"><img src="/images/20211212/float64_06.png" alt="float64-0.6" style="zoom:50%;"><p>0.3的二进制：0.010011001100110011001100110011001100110011001100110011 实际上!=0.3<br>0.6的二进制：0.10011001100110011001100110011001100110011001100110011 实际上!=0.6<br>0.3+0.6=     ：0.111001100110011001100110011001100110011001100110011001<br>转为十进制为 <strong>0.8999999999999999</strong></p><p>由上可知，因为0.3和0.6都不能无损存储为二进制数，最后的计算结果也有精度的损失。</p><hr><h2 id="5-大数运算库"><a href="#5-大数运算库" class="headerlink" title="5 大数运算库"></a>5 大数运算库</h2><p>当float64的精度无法满足需求时，可以考虑使用math/big库,著名区块链项目以太坊即用该库来实现货币的存储和计算。虽然实测0.3+0.6还是有精度损失。</p><pre class="line-numbers language-go"><code class="language-go">  d1<span class="token punctuation">,</span> d2 <span class="token operator">:=</span> big<span class="token punctuation">.</span><span class="token function">NewFloat</span><span class="token punctuation">(</span><span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> big<span class="token punctuation">.</span><span class="token function">NewFloat</span><span class="token punctuation">(</span><span class="token number">0.6</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>d1<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>d1<span class="token punctuation">,</span> d2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0.8999999999999999</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是该库对于大整数运算还是很好用的</p><pre class="line-numbers language-go"><code class="language-go">  a<span class="token punctuation">,</span> b <span class="token operator">:=</span> big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  limit <span class="token operator">:=</span> a<span class="token punctuation">.</span><span class="token function">Exp</span><span class="token punctuation">(</span>big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> a<span class="token punctuation">.</span><span class="token function">Cmp</span><span class="token punctuation">(</span>limit<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>    a<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>    a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a  <span class="token punctuation">}</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker部署项目</title>
      <link href="/posts/5a44d267.html"/>
      <url>/posts/5a44d267.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用Docker部署项目"><a href="#使用Docker部署项目" class="headerlink" title="使用Docker部署项目"></a>使用Docker部署项目</h1><blockquote><p>参考资料<br><a href="https://www.liwenzhou.com/posts/Go/how_to_deploy_go_app_using_docker/">如何使用Docker部署Go Web应用</a></p></blockquote><h2 id="1-Why-Docker"><a href="#1-Why-Docker" class="headerlink" title="1. Why Docker"></a>1. Why Docker</h2><p>之前部署项目都比较直接，本地编译好然后把可执行文件丢到服务器上跑。</p><ul><li>对于后端，先把服务器数据库环境配好<ul><li>Java项目用maven打个Jar包</li><li>Golang项目交叉编译个Linux平台的可执行文件</li></ul></li><li>对于前端，先把服务器nignx环境配好<ul><li>把项目打包成静态资源，一般是放到dist目录下</li></ul></li></ul><p>但是这样有个问题，在多台服务器上部署相同项目时都得先去配好环境，非常麻烦。在微服务架构中，一个应用可能会拆成几十个微服务，每个服务都有开发、测试、生产几套环境需要搭建，如果采用传统的部署方式，工作量就太大了。</p><img src="/images/20211121/why_docker.png" alt="docker能做什么" style="zoom: 33%;"><p>使用Docker部署的话，可以将应用程序打包封装到一个容器中，容器包含了应用程序的代码、运行环境、依赖库、配置文件等必须的资源。容器之前相互隔离，互不影响。</p><p>用上Docker后，可以实现开发、测试和生产环境的统一化和标准化。镜像作为标准的交付件，可在开发、测试和生产环境上以容器来运行，最终实现三套环境上的应用以及运行所依赖内容的完全一致。</p><p>下面用一个例子记录一下如何用Docker部署项目</p><hr><h2 id="2-使用Docker部署Go-Web应用"><a href="#2-使用Docker部署Go-Web应用" class="headerlink" title="2. 使用Docker部署Go Web应用"></a>2. 使用Docker部署Go Web应用</h2><h3 id="2-1-编写Dockerfile"><a href="#2-1-编写Dockerfile" class="headerlink" title="2.1 编写Dockerfile"></a>2.1 编写Dockerfile</h3><p>先在项目根目录新建一个 <code>Dockerfile</code></p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM golang:alpine AS builder# 为我们的镜像设置必要的环境变量ENV GO111MODULE=on \    CGO_ENABLED=0 \    GOOS=linux \    GOARCH=amd64# 移动到工作目录：/buildWORKDIR /build# 将代码复制到容器中COPY . .# 将我们的代码编译成二进制可执行文件 appRUN go build -o app .# 接下来创建一个小镜像FROM scratch# 将项目的配置文件移动到配置文件中COPY ./configs /configs# 从builder镜像中把/dist/app 拷贝到当前目录COPY --from=builder /build/app /# 声明服务端口EXPOSE 3344# 需要运行的命令ENTRYPOINT ["/app", "configs/config.yaml"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-构建镜像"><a href="#2-2-构建镜像" class="headerlink" title="2.2 构建镜像"></a>2.2 构建镜像</h3><p>创建镜像并名为为 <code>goweb_app</code></p><pre class="line-numbers language-shell"><code class="language-shell">docker build . -t goweb_app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-运行镜像"><a href="#2-3-运行镜像" class="headerlink" title="2.3 运行镜像"></a>2.3 运行镜像</h3><pre class="line-numbers language-shell"><code class="language-shell">docker run -d -p 8080:3344 goweb_app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-d</code> 表示在后台运行、 <code>-p 3344:3344</code> 表示将宿主机的3344端口(前)绑定到容器的3344端口(后)。</p><h3 id="2-4-分阶段构建"><a href="#2-4-分阶段构建" class="headerlink" title="2.4 分阶段构建"></a>2.4 分阶段构建</h3><p>Docker的最佳实践之一是通过仅保留二进制文件来减小镜像大小，为此，我们将使用一种称为多阶段构建的技术，这意味着我们将通过多个步骤构建镜像。</p><p>使用这种技术，我们剥离了使用<code>golang:alpine</code>作为编译镜像来编译得到二进制可执行文件的过程，并基于<code>scratch</code>生成一个简单的、非常小的新镜像。我们将二进制文件从命名为<code>builder</code>的第一个镜像中复制到新创建的<code>scratch</code>镜像中。</p><hr><h2 id="3-使用Docker部署MySQL"><a href="#3-使用Docker部署MySQL" class="headerlink" title="3. 使用Docker部署MySQL"></a>3. 使用Docker部署MySQL</h2><p>直接启动mysql容器</p><pre class="line-numbers language-shell"><code class="language-shell">docker run --name mysqlxk -p 13306:3306 -e MYSQL_ROOT_PASSWORD=xxf -v /Users/xxf/docker/mysql:/var/lib/mysql -d mysql:8.0.19<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>--name mysqlxk</code> 设置容器名称为mysqlxk</p><p><code>-e MYSQL_ROOT_PASSWORD=xxf</code> 设置root用户密码为xxf</p><p><code>-v /Users/xxf/docker/mysql:/var/lib/mysql</code> 挂载容器中的<code>/var/lib/mysql</code> 到本地的<code>/Users/xxf/docker/mysql</code> </p><p>之前go web里的配置也要改改，其中Host要改成mysql容器的名称</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">Database</span><span class="token punctuation">:</span>  <span class="token key atrule">DBType</span><span class="token punctuation">:</span> mysql  <span class="token key atrule">Username</span><span class="token punctuation">:</span> root  <span class="token key atrule">Password</span><span class="token punctuation">:</span> xxf  <span class="token key atrule">Host</span><span class="token punctuation">:</span> mysqlxk<span class="token punctuation">:</span><span class="token number">3306</span>  <span class="token key atrule">DBName</span><span class="token punctuation">:</span> xk  <span class="token key atrule">Charset</span><span class="token punctuation">:</span> utf8  <span class="token key atrule">ParseTime</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">MaxIdleConns</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">MaxOpenConns</span><span class="token punctuation">:</span> <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新构建go web镜像后再运行，使用 <code>—-link</code> 与mysqlxk容器关联起来</p><pre class="line-numbers language-shell"><code class="language-shell">docker run -d --link=mysqlxk:mysqlxk -p 3344:3344 goweb_app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="4-使用Docker部署Vue项目"><a href="#4-使用Docker部署Vue项目" class="headerlink" title="4. 使用Docker部署Vue项目"></a>4. 使用Docker部署Vue项目</h2><p>部署前端就更简单了，首先本地编译项目生成静态文件<code>vue build</code> ，然后创建 <code>Dockerfile</code></p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM nginxCOPY dist/ /usr/share/nginx/html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后构建镜像</p><pre class="line-numbers language-shell"><code class="language-shell">docker build --platform linux/amd64 . -t xxf0512/xkfrontend:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>--platform linux/amd64</code> 是指目标主机的系统</p><hr><p>上面说了几种构建镜像的方式，构建完成后将镜像直接传到服务器上。或者先在本地push到镜像仓库，然后在服务器上拉取镜像运行即可。</p><p>直接传到话先把镜像打个包：</p><pre class="line-numbers language-shell"><code class="language-shell">docker save -o goweb_app.tar goweb_appdocker save -o xkfrontend.tar xxf0512/xkfrontend:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
            <tag> 项目部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-访问者模式</title>
      <link href="/posts/b07c35a8.html"/>
      <url>/posts/b07c35a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-访问者模式"><a href="#设计模式-访问者模式" class="headerlink" title="设计模式-访问者模式"></a>设计模式-访问者模式</h1><blockquote><p>参考资料<br><a href="https://refactoringguru.cn/design-patterns/visitor">访问者设计模式</a><br><a href="https://refactoringguru.cn/design-patterns/visitor/go/example">Go 访问者模式讲解和代码示例</a></p></blockquote><p>最近学习AST(abstract static tree抽象语法树)和阅读<a href="https://github.com/sivachokkapu/revive-cc/blob/master/rule/blank-imports.go#L41">revive-cc</a>源码时发现，在对AST进行遍历&amp;对每个node进行操作时，使用了访问者模式。每个节点都是不同类的对象，在对这些属于不同类的一组对象进行同一操作时，访问者模式会使相关实现变得更加优雅。<br>下面对访问者模式进行介绍，然后实现一个小demo，最后看看<a href="https://github.com/mgechev/revive">revive</a>和<a href="https://github.com/sivachokkapu/revive-cc">revive-cc</a>这两个针对golang的静态分析库是如何使用访问者模式的。</p><h2 id="1-访问者模式"><a href="#1-访问者模式" class="headerlink" title="1 访问者模式"></a>1 访问者模式</h2><h3 id="1-1-概念介绍"><a href="#1-1-概念介绍" class="headerlink" title="1.1 概念介绍"></a>1.1 概念介绍</h3><blockquote><p>访问者模式是一种行为设计模式，它能将<strong>算法</strong>与其所作用的<strong>对象</strong>隔离开来。</p></blockquote><img src="/images/20211105/访问者模式结构.png" alt="访问者模式结构" style="zoom: 40%;"><p>乍一看上去很难懂～</p><img src="/images/20211105/举个栗子.png" alt="举个栗子" style="zoom:60%;"><p>某个小区里有若干个住户，物业需要进住户家里查水表、查电表、查煤气表。。。但是住户家里可不是谁都能进的，怎么验证身份呢。<br>一种方法是让业主来验证，先带水工挨个给业主认识一下，再带电工挨个给业主认识一下，过了几天需要查煤气表了，再带煤气工给挨个业主认识一下。实在是太麻烦了<br>其实有一种更简单的办法，怎么做呢？业主家门上有密码锁，物业把密码表给各个值得信赖的工人看一下，他们自己进去就行了。</p><p>在这里：<br>访问者接口(<code>Visitor interface</code>)声明了访问方法(<code>visit</code>)，即拿到每个住户房门的密码；<br>访问者实体(<code>ConcreteVistors</code>)就是工人，他们拿到了密码表就相当于实现了访问方法；<br>元素接口(<code>Element interface</code>)是住户密码锁的抽象，接受拥有访问能力的人来访问(实现了访问者接口的工人)；<br>各个用户的密码锁是元素实体(<code>ElementA、ElementB</code>)，他们有各自的特征，即密码不一致。拥有访问能力的工人可通过该实体的visit方法进行访问。</p><h3 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a>1.2 应用场景</h3><ul><li><strong>如果你需要对一个复杂对象结构（例如对象树）中的所有元素执行某些操作，可使用访问者模式。</strong><br>访问者模式通过在访问者对象中为多个目标类提供相同操作的变体， 让你能在属于不同类的一组对象上执行同一操作。</li><li><strong>可使用访问者模式来清理辅助行为的业务逻辑。</strong><br>该模式会将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作。</li><li><strong>当某个行为仅在类层次结构中的一些类中有意义，而在其他类中没有意义时，可使用该模式。</strong><br>你可将该行为抽取到单独的访问者类中， 只需实现接收相关类的对象作为参数的访问者方法并将其他方法留空即可。</li></ul><h3 id="1-3-优点-amp-缺点"><a href="#1-3-优点-amp-缺点" class="headerlink" title="1.3 优点&amp;缺点"></a>1.3 优点&amp;缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>开闭原则。 你可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。</td><td>每次在元素层次结构中添加或移除一个类时， 你都要更新所有的访问者。</td></tr><tr><td>单一职责原则。 可将同一行为的不同版本移到同一个类中。</td><td>在访问者同某个元素进行交互时， 它们可能没有访问元素私有成员变量和方法的必要权限。</td></tr><tr><td>访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助。</td><td></td></tr></tbody></table><hr><h2 id="2-Demo-如何使用访问者模式"><a href="#2-Demo-如何使用访问者模式" class="headerlink" title="2 Demo-如何使用访问者模式"></a>2 Demo-如何使用访问者模式</h2><p>访问者模式允许你在结构体中添加行为，而又不会对结构体造成实际变更。下面用一个Demo来说明如何使用访问者模式。</p><h3 id="2-1-初始状态"><a href="#2-1-初始状态" class="headerlink" title="2.1 初始状态"></a>2.1 初始状态</h3><p>现在有一个Shape接口和三个形状结构体，三个结构体实现了接口的Name()函数，在golang中可以认为结构体implement了接口。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"math"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Shape <span class="token keyword">interface</span> <span class="token punctuation">{</span>  <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">type</span> Square <span class="token keyword">struct</span> <span class="token punctuation">{</span>  side <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s Square<span class="token punctuation">)</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">"square"</span><span class="token punctuation">}</span><span class="token keyword">type</span> Circle <span class="token keyword">struct</span> <span class="token punctuation">{</span>  radius <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c Circle<span class="token punctuation">)</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">"circle"</span><span class="token punctuation">}</span><span class="token keyword">type</span> Triangle <span class="token keyword">struct</span> <span class="token punctuation">{</span>  sideA<span class="token punctuation">,</span> sideB<span class="token punctuation">,</span> sideC <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t Triangle<span class="token punctuation">)</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">"triangle"</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> shapes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Shape<span class="token punctuation">{</span>    Square<span class="token punctuation">{</span><span class="token number">1.2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    Circle<span class="token punctuation">{</span><span class="token number">1.5</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    Triangle<span class="token punctuation">{</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> shape <span class="token operator">:=</span> <span class="token keyword">range</span> shapes <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>shape<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>现在来了个新需求，需要计算每个图形的面积</strong>。一种直接的方式就是向Name()方法一样，在<code>interface Shape</code>中定义<code>getArea()</code>，然后每个struct实现getArea()。</p><h3 id="2-2-每个结构体都实现一遍新方法"><a href="#2-2-每个结构体都实现一遍新方法" class="headerlink" title="2.2 每个结构体都实现一遍新方法"></a>2.2 每个结构体都实现一遍新方法</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Shape <span class="token keyword">interface</span> <span class="token punctuation">{</span>  <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>  <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s Square<span class="token punctuation">)</span> <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> s<span class="token punctuation">.</span>side <span class="token operator">*</span> s<span class="token punctuation">.</span>side<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c Circle<span class="token punctuation">)</span> <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> math<span class="token punctuation">.</span>Pi <span class="token operator">*</span> c<span class="token punctuation">.</span>radius <span class="token operator">*</span> c<span class="token punctuation">.</span>radius<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t Triangle<span class="token punctuation">)</span> <span class="token function">getArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  s <span class="token operator">:=</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>sideA <span class="token operator">+</span> t<span class="token punctuation">.</span>sideB <span class="token operator">+</span> t<span class="token punctuation">.</span>sideC<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>  <span class="token keyword">return</span> math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>s <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> t<span class="token punctuation">.</span>sideA<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> t<span class="token punctuation">.</span>sideB<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> t<span class="token punctuation">.</span>sideC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式比较直观，也比较简单，但是可扩展性不高。之后如果再有新需求，比如求个周长之类的，还得再把相关方法实现一遍，同时需要修改现有的interface，还可能会引入安全风险。在版本迭代时，应当确定一个原则：<strong>不要改之前的代码，要在之前的基础上进行扩展。</strong><br>在这种情况下，访问者模式可以很优雅地解决问题。</p><h3 id="2-3-用访问者模式进行改造"><a href="#2-3-用访问者模式进行改造" class="headerlink" title="2.3 用访问者模式进行改造"></a>2.3 用访问者模式进行改造</h3><img src="/images/20211105/demo结构.png" alt="demo结构" style="zoom:40%;"><p>图是白嫖的，基本意思差不多</p><ol><li><strong>定义一个访问者接口，声明访问者需要有访问哪些对象的能力</strong><br>接口声明了一系列以以对象结构的具体元素为参数的访问者方法<strong>，</strong>这些方法可以理解为访问不同对象的入口，由于golang不支持重载，所以方法名都不一样。在Java这些支持重载的语言中，可以统一用一个方法名。</li></ol><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Visitor <span class="token keyword">interface</span> <span class="token punctuation">{</span>  <span class="token function">visitForSquare</span><span class="token punctuation">(</span><span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token builtin">float64</span>  <span class="token function">visitForCircle</span><span class="token punctuation">(</span><span class="token operator">*</span>Circle<span class="token punctuation">)</span> <span class="token builtin">float64</span>  <span class="token function">visitForTriangle</span><span class="token punctuation">(</span><span class="token operator">*</span>Triangle<span class="token punctuation">)</span> <span class="token builtin">float64</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>Shape接口声明一个方法来接收访问者，相当于对象给访问者开了个门</strong><br>如果访问者有访问该对象的能力(访问者实现了对该对象操作的方法)，就可以进行访问。<br>所有继承该Shape接口的类去实现这个方法<strong>。</strong>需要注意，访问者模式必须修改原interface，但是这种修改只需要一次，后面的扩展比如求面积、求周长都可以通过这一个方法进行。</li></ol><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Shape <span class="token keyword">interface</span> <span class="token punctuation">{</span>  <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>  <span class="token function">Accept</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">)</span> <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token function">Accept</span><span class="token punctuation">(</span>v Visitor<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">visitForSquare</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Circle<span class="token punctuation">)</span> <span class="token function">Accept</span><span class="token punctuation">(</span>v Visitor<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">visitForCircle</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>Triangle<span class="token punctuation">)</span> <span class="token function">Accept</span><span class="token punctuation">(</span>v Visitor<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">visitForTriangle</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>实现具体访问者，同时教会这个访问者如何去访问各个对象</strong><br>可以定义一个struct/class作为访问者，然后这个访问者去实现访问者接口定义的方法，他就有了访问对象的能力。</li></ol><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> areaCalculator <span class="token keyword">struct</span> <span class="token punctuation">{</span>  area <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>areaCalculator<span class="token punctuation">)</span> <span class="token function">visitForSquare</span><span class="token punctuation">(</span>s <span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> s<span class="token punctuation">.</span>side <span class="token operator">*</span> s<span class="token punctuation">.</span>side<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>areaCalculator<span class="token punctuation">)</span> <span class="token function">visitForCircle</span><span class="token punctuation">(</span>c <span class="token operator">*</span>Circle<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> math<span class="token punctuation">.</span>Pi <span class="token operator">*</span> c<span class="token punctuation">.</span>radius <span class="token operator">*</span> c<span class="token punctuation">.</span>radius<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>areaCalculator<span class="token punctuation">)</span> <span class="token function">visitForTriangle</span><span class="token punctuation">(</span>t <span class="token operator">*</span>Triangle<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  s <span class="token operator">:=</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>sideA <span class="token operator">+</span> t<span class="token punctuation">.</span>sideB <span class="token operator">+</span> t<span class="token punctuation">.</span>sideC<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>  <span class="token keyword">return</span> math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>s <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> t<span class="token punctuation">.</span>sideA<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> t<span class="token punctuation">.</span>sideB<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> t<span class="token punctuation">.</span>sideC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>访问者从对象的门里进去，完成访问操作</strong></li></ol><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  areaCalculator <span class="token operator">:=</span> <span class="token operator">&amp;</span>areaCalculator<span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">var</span> shapes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Shape<span class="token punctuation">{</span>    <span class="token operator">&amp;</span>Square<span class="token punctuation">{</span><span class="token number">1.2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>Circle<span class="token punctuation">{</span><span class="token number">1.5</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>Triangle<span class="token punctuation">{</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> shape <span class="token operator">:=</span> <span class="token keyword">range</span> shapes <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>shape<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shape<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span>areaCalculator<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后再扩展就非常方便了，只需要定义一个struct/class，然后实现访问者interface声明的所有方法，他就成了一个访问者。<strong>不同的是每个访问者实现的方法体具体做什么操作可以定制化。</strong><br>下面是整体代码</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"math"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Shape <span class="token keyword">interface</span> <span class="token punctuation">{</span>  <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>  <span class="token function">Accept</span><span class="token punctuation">(</span>Visitor<span class="token punctuation">)</span> <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">type</span> Square <span class="token keyword">struct</span> <span class="token punctuation">{</span>  side <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">"square"</span><span class="token punctuation">}</span><span class="token keyword">type</span> Circle <span class="token keyword">struct</span> <span class="token punctuation">{</span>  radius <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Circle<span class="token punctuation">)</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">"circle"</span><span class="token punctuation">}</span><span class="token keyword">type</span> Triangle <span class="token keyword">struct</span> <span class="token punctuation">{</span>  sideA<span class="token punctuation">,</span> sideB<span class="token punctuation">,</span> sideC <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>Triangle<span class="token punctuation">)</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">"triangle"</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token function">Accept</span><span class="token punctuation">(</span>v Visitor<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">visitForSquare</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Circle<span class="token punctuation">)</span> <span class="token function">Accept</span><span class="token punctuation">(</span>v Visitor<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">visitForCircle</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>Triangle<span class="token punctuation">)</span> <span class="token function">Accept</span><span class="token punctuation">(</span>v Visitor<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">visitForTriangle</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> Visitor <span class="token keyword">interface</span> <span class="token punctuation">{</span>  <span class="token function">visitForSquare</span><span class="token punctuation">(</span><span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token builtin">float64</span>  <span class="token function">visitForCircle</span><span class="token punctuation">(</span><span class="token operator">*</span>Circle<span class="token punctuation">)</span> <span class="token builtin">float64</span>  <span class="token function">visitForTriangle</span><span class="token punctuation">(</span><span class="token operator">*</span>Triangle<span class="token punctuation">)</span> <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">type</span> areaCalculator <span class="token keyword">struct</span> <span class="token punctuation">{</span>  area <span class="token builtin">float64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>areaCalculator<span class="token punctuation">)</span> <span class="token function">visitForSquare</span><span class="token punctuation">(</span>s <span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> s<span class="token punctuation">.</span>side <span class="token operator">*</span> s<span class="token punctuation">.</span>side<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>areaCalculator<span class="token punctuation">)</span> <span class="token function">visitForCircle</span><span class="token punctuation">(</span>c <span class="token operator">*</span>Circle<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> math<span class="token punctuation">.</span>Pi <span class="token operator">*</span> c<span class="token punctuation">.</span>radius <span class="token operator">*</span> c<span class="token punctuation">.</span>radius<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>areaCalculator<span class="token punctuation">)</span> <span class="token function">visitForTriangle</span><span class="token punctuation">(</span>t <span class="token operator">*</span>Triangle<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">{</span>  s <span class="token operator">:=</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>sideA <span class="token operator">+</span> t<span class="token punctuation">.</span>sideB <span class="token operator">+</span> t<span class="token punctuation">.</span>sideC<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>  <span class="token keyword">return</span> math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span>s <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> t<span class="token punctuation">.</span>sideA<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> t<span class="token punctuation">.</span>sideB<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s <span class="token operator">-</span> t<span class="token punctuation">.</span>sideC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  areaCalculator <span class="token operator">:=</span> <span class="token operator">&amp;</span>areaCalculator<span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">var</span> shapes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Shape<span class="token punctuation">{</span>    <span class="token operator">&amp;</span>Square<span class="token punctuation">{</span><span class="token number">1.2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>Circle<span class="token punctuation">{</span><span class="token number">1.5</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>Triangle<span class="token punctuation">{</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> shape <span class="token operator">:=</span> <span class="token keyword">range</span> shapes <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>shape<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shape<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span>areaCalculator<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="3-revive和revive-cc中的访问者模式"><a href="#3-revive和revive-cc中的访问者模式" class="headerlink" title="3 revive和revive-cc中的访问者模式"></a>3 revive和revive-cc中的访问者模式</h2><h3 id="3-1-Visitor-interface"><a href="#3-1-Visitor-interface" class="headerlink" title="3.1 Visitor interface"></a>3.1 Visitor interface</h3><p>在<code>go/ast/walk.go:12</code>定义了<code>Visitor interface</code>，声明了方法<code>Visit(node Node)</code>，其中Node也是一个interface。<strong>该方法提供了访问Node节点的能力，</strong>会被Walk函数用来访问节点。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// go/ast/walk.go:12</span><span class="token comment" spellcheck="true">// A Visitor's Visit method is invoked for each node encountered by Walk.</span><span class="token comment" spellcheck="true">// If the result visitor w is not nil, Walk visits each of the children</span><span class="token comment" spellcheck="true">// of node with the visitor w, followed by a call of w.Visit(nil).</span><span class="token keyword">type</span> Visitor <span class="token keyword">interface</span> <span class="token punctuation">{</span>  <span class="token function">Visit</span><span class="token punctuation">(</span>node Node<span class="token punctuation">)</span> <span class="token punctuation">(</span>w Visitor<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Walk函数</strong><br>walk函数通过dfs对ast进行遍历，通过visit方法访问ast上的node。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// go/ast/walk.go</span><span class="token comment" spellcheck="true">// Walk traverses an AST in depth-first order: It starts by calling</span><span class="token comment" spellcheck="true">// v.Visit(node); node must not be nil. If the visitor w returned by</span><span class="token comment" spellcheck="true">// v.Visit(node) is not nil, Walk is invoked recursively with visitor</span><span class="token comment" spellcheck="true">// w for each of the non-nil children of node, followed by a call of</span><span class="token comment" spellcheck="true">// w.Visit(nil).</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">func</span> <span class="token function">Walk</span><span class="token punctuation">(</span>v Visitor<span class="token punctuation">,</span> node Node<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> v <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">Visit</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> v <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// walk children</span>  <span class="token comment" spellcheck="true">// (the order of the cases matches the order</span>  <span class="token comment" spellcheck="true">// of the corresponding node types in ast.go)</span>  <span class="token keyword">switch</span> n <span class="token operator">:=</span> node<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Comments and fields</span>  <span class="token keyword">case</span> <span class="token operator">*</span>Comment<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">// nothing to do</span>  <span class="token keyword">case</span> <span class="token operator">*</span>CommentGroup<span class="token punctuation">:</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> c <span class="token operator">:=</span> <span class="token keyword">range</span> n<span class="token punctuation">.</span>List <span class="token punctuation">{</span>      <span class="token function">Walk</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> c<span class="token punctuation">)</span>    <span class="token punctuation">}</span>      <span class="token operator">...</span>   <span class="token operator">...</span>   <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-Concrete-Visitor"><a href="#3-2-Concrete-Visitor" class="headerlink" title="3.2 Concrete Visitor"></a>3.2 Concrete Visitor</h3><p>revive-cc这个项目是利用<code>revive</code>做静态分析和缺陷检测的。主要实现的就是<code>Concrete Visitor</code>，在rule目录下定义了一系列规则，在规则文件中实现了访问者实体。<br>如<code>rule/imports-blacklist.go</code>中实现了接口中声明的visit函数</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> blacklistedImports <span class="token keyword">struct</span> <span class="token punctuation">{</span>  file      <span class="token operator">*</span>lint<span class="token punctuation">.</span>File  fileAst   <span class="token operator">*</span>ast<span class="token punctuation">.</span>File  onFailure <span class="token keyword">func</span><span class="token punctuation">(</span>lint<span class="token punctuation">.</span>Failure<span class="token punctuation">)</span>  blacklist <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>w blacklistedImports<span class="token punctuation">)</span> <span class="token function">Visit</span><span class="token punctuation">(</span><span class="token boolean">_</span> ast<span class="token punctuation">.</span>Node<span class="token punctuation">)</span> ast<span class="token punctuation">.</span>Visitor <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> is <span class="token operator">:=</span> <span class="token keyword">range</span> w<span class="token punctuation">.</span>fileAst<span class="token punctuation">.</span>Imports <span class="token punctuation">{</span>    <span class="token keyword">if</span> is<span class="token punctuation">.</span>Path <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>w<span class="token punctuation">.</span>file<span class="token punctuation">.</span><span class="token function">IsTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> w<span class="token punctuation">.</span>blacklist<span class="token punctuation">[</span>is<span class="token punctuation">.</span>Path<span class="token punctuation">.</span>Value<span class="token punctuation">]</span> <span class="token punctuation">{</span>      w<span class="token punctuation">.</span><span class="token function">onFailure</span><span class="token punctuation">(</span>lint<span class="token punctuation">.</span>Failure<span class="token punctuation">{</span>        Confidence<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        Failure<span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"should not use the following blacklisted import: %s"</span><span class="token punctuation">,</span> is<span class="token punctuation">.</span>Path<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">,</span>        Node<span class="token punctuation">:</span>       is<span class="token punctuation">,</span>        Category<span class="token punctuation">:</span>   <span class="token string">"imports"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-Element"><a href="#3-3-Element" class="headerlink" title="3.3 Element"></a>3.3 Element</h3><p>被访问的对象元素就是前面提到的Node，他们定义的方法不是之前的<code>accept</code>。但也只是名字不同，本质应该还是一样的。<br>Todo：目前还有个问题没搞清楚，为什么interface中声明的函数没有参数，安装之前所学，应该有个Visitor来接收访问者。还在思考，后续补上</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// go/ast/ast.go</span><span class="token comment" spellcheck="true">// All node types implement the Node interface.</span><span class="token keyword">type</span> Node <span class="token keyword">interface</span> <span class="token punctuation">{</span>  <span class="token function">Pos</span><span class="token punctuation">(</span><span class="token punctuation">)</span> token<span class="token punctuation">.</span>Pos <span class="token comment" spellcheck="true">// position of first character belonging to the node</span>  <span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span> token<span class="token punctuation">.</span>Pos <span class="token comment" spellcheck="true">// position of first character immediately after the node</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// All expression nodes implement the Expr interface. 表达式：expression</span><span class="token keyword">type</span> Expr <span class="token keyword">interface</span> <span class="token punctuation">{</span>  Node  <span class="token function">exprNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// All statement nodes implement the Stmt interface. 语句：statement</span><span class="token keyword">type</span> Stmt <span class="token keyword">interface</span> <span class="token punctuation">{</span>  Node  <span class="token function">stmtNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// All declaration nodes implement the Decl interface. 声明：declaration</span><span class="token keyword">type</span> Decl <span class="token keyword">interface</span> <span class="token punctuation">{</span>  Node  <span class="token function">declNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Pos and End implementations for expression/type nodes.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>x <span class="token operator">*</span>BadExpr<span class="token punctuation">)</span> <span class="token function">Pos</span><span class="token punctuation">(</span><span class="token punctuation">)</span> token<span class="token punctuation">.</span>Pos  <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span>From <span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>x <span class="token operator">*</span>Ident<span class="token punctuation">)</span> <span class="token function">Pos</span><span class="token punctuation">(</span><span class="token punctuation">)</span> token<span class="token punctuation">.</span>Pos    <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span>NamePos <span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>x <span class="token operator">*</span>Ellipsis<span class="token punctuation">)</span> <span class="token function">Pos</span><span class="token punctuation">(</span><span class="token punctuation">)</span> token<span class="token punctuation">.</span>Pos <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span>Ellipsis <span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>x <span class="token operator">*</span>BasicLit<span class="token punctuation">)</span> <span class="token function">Pos</span><span class="token punctuation">(</span><span class="token punctuation">)</span> token<span class="token punctuation">.</span>Pos <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span>ValuePos <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// exprNode() ensures that only expression/type nodes can be</span><span class="token comment" spellcheck="true">// assigned to an Expr.</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>BadExpr<span class="token punctuation">)</span> <span class="token function">exprNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>Ident<span class="token punctuation">)</span> <span class="token function">exprNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>Ellipsis<span class="token punctuation">)</span> <span class="token function">exprNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>BasicLit<span class="token punctuation">)</span> <span class="token function">exprNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 静态分析 </tag>
            
            <tag> 缺陷检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS弹性盒子布局</title>
      <link href="/posts/ca5c401d.html"/>
      <url>/posts/ca5c401d.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSS布局-弹性盒子"><a href="#CSS布局-弹性盒子" class="headerlink" title="CSS布局-弹性盒子"></a>CSS布局-弹性盒子</h1><blockquote><p>参考：</p><ol><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">css-tricks 弹性盒子</a></li><li><a href="https://juejin.cn/post/6867413038371667976">最详细完整的flex弹性布局</a></li></ol></blockquote><img src="/images/20211016/flexbox02.jpg" alt="flexbox" style="zoom:20%;"><p> flex 是flexible box的缩写，意为弹性布局，用来为盒装模型提供最大的灵活性，任何一个容器都可以指定为flex布局。</p><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><img src="/images/20211016/layout.jpg" alt="layout" style="zoom:50%;"><p>主轴(<code>main axis</code>)：默认是水平轴，方向自左向右。<br>交叉轴(<code>cross axis</code>)：默认是垂直轴，方向自上向下。<br>容器中的子元素叫做<code>flex item</code>，其占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="2-弹性容器属性"><a href="#2-弹性容器属性" class="headerlink" title="2. 弹性容器属性"></a>2. 弹性容器属性</h2><h3 id="2-1-flex-direction"><a href="#2-1-flex-direction" class="headerlink" title="2.1 flex-direction"></a>2.1 flex-direction</h3><img src="/images/20211016/flex-direction.png" alt="flex-direction" style="zoom: 50%;"><p><code>flex-direction</code>决定了主轴的方向。一般不写也行，默认为水平方向，自左向右。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-direction</span><span class="token punctuation">:</span> row | row-reverse | column | column-reverse<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-justify-content"><a href="#2-2-justify-content" class="headerlink" title="2.2 justify-content"></a>2.2 justify-content</h3><img src="/images/20211016/justify-content.png" alt="justify-content" style="zoom: 33%;"><p><code>justify-content</code>决定了flex item在main axis上的对齐方式，默认flex-start，与main start对齐。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right <span class="token number">...</span> + safe | unsafe<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-3-align-items"><a href="#2-3-align-items" class="headerlink" title="2.3 align-items"></a>2.3 align-items</h3><img src="/images/20211016/align-items.png" alt="align-items" style="zoom:33%;"><p><code>align-items</code>决定flex items在cross axis上的对齐方式，</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + <span class="token number">...</span> safe | unsafe<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-4-flex-wrap"><a href="#2-4-flex-wrap" class="headerlink" title="2.4 flex-wrap"></a>2.4 flex-wrap</h3><img src="/images/20211016/flex-wrap.png" alt="flex-wrap" style="zoom: 50%;"><p><code>flex-wrap</code>决定了flex container 是单行还是多行。默认nowrap是在一行上，不换行。<br>nowrap：所有flex items在一行<br>wrap：所有flex items在多行，方向从上到下<br>wrap-reverse：所有flex items在多行，方向从下到上</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> nowrap | wrap | wrap-reverse<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-5-align-content"><a href="#2-5-align-content" class="headerlink" title="2.5 align-content"></a>2.5 align-content</h3><img src="/images/20211016/align-content.png" alt="align-content" style="zoom: 33%;"><p><code>align-content</code>决定了多行flex items在cross axis的对齐方式，用法与justify-content相似，一个是横轴，一个控制竖轴。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">align-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + <span class="token number">...</span> safe | unsafe<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-6-flew-flow"><a href="#2-6-flew-flow" class="headerlink" title="2.6 flew-flow"></a>2.6 flew-flow</h3><p><code>flew-flow</code>是flex-direction与flex-wrap的简写。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-flow</span><span class="token punctuation">:</span> column wrap<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-子元素-flex-item-属性"><a href="#3-子元素-flex-item-属性" class="headerlink" title="3. 子元素(flex item)属性"></a>3. 子元素(flex item)属性</h2><p>注意⚠️：<code>float</code>, <code>clear</code> and <code>vertical-align</code>对flex item无效。</p><h3 id="3-1-order"><a href="#3-1-order" class="headerlink" title="3.1 order"></a>3.1 order</h3><img src="/images/20211016/order.png" alt="order" style="zoom:33%;"><p><code>order</code>决定flex items的排布顺序  (用的不多)，可以设置为任意整数（正整数、负整数、0），值越小越排在前面。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">order</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* default is 0 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-align-self"><a href="#3-2-align-self" class="headerlink" title="3.2 align-self"></a>3.2 align-self</h3><img src="/images/20211016/align-self.png" alt="align-self" style="zoom:50%;"><p><code>align-self</code>相当于继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">align-self</span><span class="token punctuation">:</span> auto | flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-3-flex-grow"><a href="#3-3-flex-grow" class="headerlink" title="3.3 flex-grow"></a>3.3 flex-grow</h3><img src="/images/20211016/flex-grow.png" alt="flex-grow" style="zoom:50%;"><p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-grow</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* default 0 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Negative numbers are invalid.</p><h3 id="3-4-flex-shrink"><a href="#3-4-flex-shrink" class="headerlink" title="3.4 flex-shrink"></a>3.4 flex-shrink</h3><p><code>flex-shrink</code> (shrink收缩)与flex-grow相似，一个扩展，一个伸缩 </p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-shrink</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* default 1 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Negative numbers are invalid.</p><h3 id="3-5-flex-basis"><a href="#3-5-flex-basis" class="headerlink" title="3.5 flex-basis"></a>3.5 flex-basis</h3><p><code>flex-basis</code>用来设置flex items 在 main axis方向上的base size。默认为auto，可以设置具体的宽度数值。flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目(item)的本来大小。也可以设置跟width，height一样的宽高，表示item将占据固定的空间！</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-basis</span><span class="token punctuation">:</span>  | auto<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* default auto */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-6-flex"><a href="#3-6-flex" class="headerlink" title="3.6 flex"></a>3.6 flex</h3><p><code>flex</code> 是flex-grow || flex-shink || flex-basis的简写。可以指定1 2 3个值 依次按照上述顺序！默认值为 0 1 auto。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex</span><span class="token punctuation">:</span> none | [ &lt;<span class="token string">'flex-grow'</span>> &lt;<span class="token string">'flex-shrink'</span>>? || &lt;<span class="token string">'flex-basis'</span>> ]<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础语法</title>
      <link href="/posts/e0886ac8.html"/>
      <url>/posts/e0886ac8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue基础语法"><a href="#Vue基础语法" class="headerlink" title="Vue基础语法"></a>Vue基础语法</h1><h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h2><h3 id="1-1-methods方法绑定this"><a href="#1-1-methods方法绑定this" class="headerlink" title="1.1 methods方法绑定this"></a>1.1 methods方法绑定this</h3><ol><li>method函数不能使用箭头函数<br>this != window；<br>而箭头函数中的this就是window，因为箭头函数中不绑定this，箭头函数会在自己的<strong>上层作用域</strong>中查找this，即script作用域中的this，所以就是window；</li><li>this指向什么内容<br>Vue源码对methods中的所有函数进行了遍历，并且通过bind绑定了this</li></ol><h3 id="1-2-VSCode创建代码片段"><a href="#1-2-VSCode创建代码片段" class="headerlink" title="1.2 VSCode创建代码片段"></a>1.2 VSCode创建代码片段</h3><ol><li>先在网站<a href="https://snippet-generator.app/%E4%B8%AD%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%82">https://snippet-generator.app/中生成代码片段。</a></li><li>VSCode配置：<code>code -&gt; 首选项 -&gt; 用户配置 -&gt; 选择html</code>，把代码片段粘进去即可。</li></ol><h2 id="2-模版语法"><a href="#2-模版语法" class="headerlink" title="2. 模版语法"></a>2. 模版语法</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{ value }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类似于上述代码中将DOM和底层组件实例的数据绑定在一起的语法，Vue大多数基于模版语法</p><h3 id="2-1-插值语法"><a href="#2-1-插值语法" class="headerlink" title="2.1 插值语法"></a>2.1 插值语法</h3><h4 id="2-1-1-mustache语法"><a href="#2-1-1-mustache语法" class="headerlink" title="2.1.1 mustache语法"></a>2.1.1 mustache语法</h4><p>把数据显示到模板（template）中，使用最多的语法是 <code>Mustache语法 (双大括号)</code> 的文本插值</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{ value }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>// value可以是数值、表达式但不能是赋值语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-1-2-v-once"><a href="#2-1-2-v-once" class="headerlink" title="2.1.2 v-once"></a>2.1.2 v-once</h4><p>单例模式，只在加载的时候渲染一次，无视数据的更新</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>my-app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-once</span><span class="token punctuation">></span></span>{{value}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../js/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span>  const App = {    template: "#my-app",    data() {      return {        value: 0,      };    },    methods: {      add() {        this.value++;      },    },  };  Vue.createApp(App).mount("#app");  // value会+1, 但渲染出的value一直为0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue &amp; Vue3</title>
      <link href="/posts/b13042be.html"/>
      <url>/posts/b13042be.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-amp-Vue3"><a href="#Vue-amp-Vue3" class="headerlink" title="Vue &amp; Vue3"></a>Vue &amp; Vue3</h1><p>**<a href="https://v3.cn.vuejs.org/">Vue</a>**一套用于构建用户界面的<code>渐进式框架</code>: 在项目中可以一点点来引入和使用Vue，不一定需要全部使用Vue来开发整个项目。</p><p><code>Vue3</code> <strong>更好的性能、更小的包体积、更好的TypeScript集成、更优秀的API设计</strong></p><p>变化</p><ol><li>源代码采用MonoRepo来进行管理，将许多项目的代码存储在同一个repository</li><li>源码使用TypeScript重写</li><li>使用Proxy进行数据劫持</li><li>删除了一些不必要的API，移除了$on.$off和$once以及内联模版等</li><li>编译优化：生成BlockTree、Slot编译优化、diff算法优化</li><li><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 新的API，Options API -&gt; Composition API</li></ol><h2 id="如何使用Vue3"><a href="#如何使用Vue3" class="headerlink" title="如何使用Vue3"></a>如何使用Vue3</h2><h3 id="1-页面中通过CDN引入"><a href="#1-页面中通过CDN引入" class="headerlink" title="1. 页面中通过CDN引入"></a>1. 页面中通过CDN引入</h3><p><code>CDN</code> Content Delivery/Distribution Network(内容分发网络) 从最近的服务器里获取数据提高效率</p><p>HTML中引入</p><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- cdn引入 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/vue@next<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">      <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>        template<span class="token punctuation">:</span> <span class="token string">"&lt;h1>Hello Vue!&lt;/h1>"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 调用cdn脚本中的函数 -> 根据一个对象创建app -> 挂载到#app</span>      Vue<span class="token punctuation">.</span><span class="token function">createApp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-下载Vue的JavaScript文件，手动引入"><a href="#2-下载Vue的JavaScript文件，手动引入" class="headerlink" title="2. 下载Vue的JavaScript文件，手动引入"></a>2. 下载Vue的JavaScript文件，手动引入</h3><p>类似于cdn，不过是将Vue脚本存储到本地再调用函数创建app对象</p><h3 id="3-通过npm安装使用"><a href="#3-通过npm安装使用" class="headerlink" title="3. 通过npm安装使用"></a>3. 通过npm安装使用</h3><p>Todo：后续补上</p><h3 id="4-通过Vue-CLI创建项目"><a href="#4-通过Vue-CLI创建项目" class="headerlink" title="4. 通过Vue CLI创建项目"></a>4. 通过Vue CLI创建项目</h3><p>Todo：后续补上</p><h2 id="声明式-amp-命令式"><a href="#声明式-amp-命令式" class="headerlink" title="声明式 &amp; 命令式"></a>声明式 &amp; 命令式</h2><p>两种不同的编程范式，声明式关注“What to do”，命令式关注“How to do”。</p><p>Vue属于声明式编程，框架封装了相关函数完成相应操作。声明数据，声明函数，声明模版，框架会自己将数据渲染到模版中。<br>命令式编程由指令流组成，面向过程进行相关指令操作</p><h2 id="MVC-amp-MVVM"><a href="#MVC-amp-MVVM" class="headerlink" title="MVC &amp; MVVM"></a>MVC &amp; MVVM</h2><p><code>MVC</code>和<code>MVVM</code>是不同的软件体系结构<br><code>MVC</code> Model-View-Controller，前期主流架构模式如IOS、前端<br>对于一个简单的HTML页面，有HTML代码、有JS代码。<br>其中HTML语义化代码就是<code>View</code>;JS代码是<code>Controller</code>；在两者之间起到渲染载体的变量是<code>Model</code>（与后端的定义有差异）</p><p><code>MVVM</code> Model-View-ViewModel，目前主流架构模式<br>Vue的设计受到<code>MVVM</code>的启发</p><p><img src="/images/20210927/Vue_MVVM.jpg" alt="Vue MVCC"></p><h2 id="data属性"><a href="#data属性" class="headerlink" title="data属性"></a>data属性</h2><p>data属性是传入一个函数，并且该函数需要返回一个对象<br>Vue2.x中，也可以传入一个对象；在Vue3.x中，必须传入一个函数，否则报错<br>data函数返回的对象会被Vue的响应式系统劫持</p><h2 id="methods属性"><a href="#methods属性" class="headerlink" title="methods属性"></a>methods属性</h2><p>methods属性是一个对象，通常会在这个对象中定义很多方法，且<strong>这些方法不能使用箭头函数</strong><br>这些方法可以被绑定到template模版中；在该方法中，可以使用this关键字直接访问data中返回对象的属性</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript入门</title>
      <link href="/posts/48922786.html"/>
      <url>/posts/48922786.html</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript入门"><a href="#TypeScript入门" class="headerlink" title="TypeScript入门"></a>TypeScript入门</h1><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ca61cc160c417c8497a00defdca5f0~tplv-k3u1fbpfcp-watermark.image" alt="TS与JS.png" style="zoom:67%;"><p><strong>TypeScript 是 JavaScript 的一个超集</strong>，主要提供了<strong>类型系统</strong>和<strong>对 ES6+ 的支持</strong>，它由 Microsoft 开发，代码开源于<a href="https://github.com/Microsoft/TypeScript">GitHub</a>上<br>始于JavaScript，归于JavaScript ｜强大的类型系统 ｜流行且适用于大型项目和基础库 ｜极大提高开发效率<br>现在主流的框架都推荐使用<code>typescript</code>如<code>Vue3</code>、<code>React</code>，其中<code>React</code>与<code>typescript</code>配合的更好一些（现在我也没感受出来，记个TODO）</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>全局安装 &amp; 查看版本</p><pre class="line-numbers language-sh"><code class="language-sh">npm install -g typescripttsc -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="VSCode-自动编译配置"><a href="#VSCode-自动编译配置" class="headerlink" title="VSCode 自动编译配置"></a>VSCode 自动编译配置</h3><pre><code>1). 生成配置文件tsconfig.json    tsc --init2). 修改tsconfig.json配置    "outDir": "./js", //生成js的路径    "strict": false, // 是否启用强制类型检查3). 启动监视任务:     终端 -&gt; 运行任务 -&gt; 监视tsconfig.json之后修改ts文件保存后会重新编译生成js文件</code></pre><h3 id="chestnut"><a href="#chestnut" class="headerlink" title=":chestnut:"></a><span class="github-emoji"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 类 成员变量、构造函数</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>  fullName<span class="token punctuation">:</span> <span class="token keyword">string</span>  firstName<span class="token punctuation">:</span> <span class="token keyword">string</span>  lastName<span class="token punctuation">:</span> <span class="token keyword">string</span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>firstName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> lastName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName    <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName    <span class="token keyword">this</span><span class="token punctuation">.</span>fullName <span class="token operator">=</span> firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> lastName  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 接口 这里的interface 类似于 Golang中的interface 可以作为范型来使用</span><span class="token comment" spellcheck="true">// 用接口来描述拥有两个字段的对象</span><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>  firstName<span class="token punctuation">:</span> <span class="token keyword">string</span>  lastName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// User类中包含了Person接口中定义的两个字段，Person对User是适配的</span><span class="token keyword">function</span> <span class="token function">greeter</span><span class="token punctuation">(</span>person<span class="token punctuation">:</span> Person<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> person<span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> person<span class="token punctuation">.</span>lastName<span class="token punctuation">}</span><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">'Jay'</span><span class="token punctuation">,</span> <span class="token string">'Chou'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">greeter</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译生成的<code>javascript</code></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 类 成员变量、构造函数</span><span class="token keyword">var</span> User <span class="token operator">=</span> <span class="token comment" spellcheck="true">/** @class */</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>fullName <span class="token operator">=</span> firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> User<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// User类中包含了Person接口中定义的两个字段，Person对User是适配的</span><span class="token keyword">function</span> <span class="token function">greeter</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Hello, '</span> <span class="token operator">+</span> person<span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> person<span class="token punctuation">.</span>lastName<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">'Jay'</span><span class="token punctuation">,</span> <span class="token string">'Chou'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">greeter</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于TypeScript的数据类型以及常用语法后续再补充。。。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://24kcs.github.io/vue3_study/">Vue3+TS 快速上手</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

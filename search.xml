<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Viterbi]]></title>
    <url>%2F2020%2F03%2F19%2FViterbi%2F</url>
    <content type="text"><![CDATA[Viterbi Algorithm Viterbi算法是栅栏图的最短路问题DP解法。如下图(图是知乎嫖的)，即一条从S到E的最短路。常应用于马尔科夫模型。 下面以一个具体的例子来说明它的一个应用(例子也是嫖的) :punch: 一个人有两种状态(健康 or 发烧) 且状态转换的概率如下表，如一个人从健康到发烧的概率为0.3 状态 健康 发烧 健康 0.7 0.3 发烧 0.4 0.6 状态的外在表现概率如下表，如一个人发烧表现出冷的概率为0.3 状态 正常 冷 头晕 健康 0.5 0.4 0.1 发烧 0.1 0.3 0.6 1234567891011121314151617181920212223# encode = utf-8import numpy as nptrans = np.array([[0.7, 0.3], [0.4, 0.6]])laun = np.array([[0.5, 0.4, 0.1], [0.1, 0.3, 0.6]])init = np.array([0.6, 0.4])look = np.array([0, 1, 2])kind = ['健康', '发烧']#print(laun[:, look[0]]) #取launch的第look[0]列#print(list(zip(init, laun[:, look[0]]))) #将对象中对应的元素打包成一个个元组#day1dp = np.array([a * b for a, b in zip(init, laun[:, look[0]])])print(max(dp))print(kind[np.where(dp == max(dp))[0][0]])#day2&amp;3for i in range(1,3): tmp = np.copy(dp) for j in range(2): dp[j] = max([a * b for a, b in zip(tmp, trans[:, j])]) * laun[j, look[i]] print('第&#123;&#125;次'.format(i + 1) + kind[np.where(dp == max(dp))[0][0]])]]></content>
      <categories>
        <category>NLP - Learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Skills]]></title>
    <url>%2F2020%2F02%2F11%2FComputer%20Skills%2F</url>
    <content type="text"><![CDATA[Computer Skills1.查看笔记本电池健康状况windows环境下， 打开cmd(管理员)， 窗口输入以下指令，会在目标目录下写入一个html文件 1powercfg /batteryreport /output "D:\Battery.html" 看来我的电池不行了。。。 以及其他各种使用情况。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Computer Skills</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(三) SpringBoot日志]]></title>
    <url>%2F2020%2F01%2F14%2F(%E4%B8%89)%20SpringBoot%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[(三) SpringBoot日志1. 日志框架小张：开发一个大型系统；1、System.out.println(“”);将关键数据打印在控制台；去掉？写在一个文件中？2、框架记录系统的一些运行信息；日志框架zhanglogging.jar3、高大上功能，异步模式？自动归档？xxx?zhanglogging-good.jar?4、将以前的框架卸下来？换上新的框架，重新修改之前的相关API;zhanglogging-perfect.jar;5、JDBC—数据库驱动； 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar;给项目中导入具体的日志实现就行；我们之前的日志框架都是实现的抽象层； 日志门面(日志抽象层) 日志实现 JCL(Jakarta Commons Logging) SLF4j(Simple Logging Facade for Java) jboss-logging Log4j JUL(java.util.logging) Log4j2 Logback 左边的抽象，右边的实现 日志门面：SLF4j(Simple Logging Facade for Java)日志实现：Logback Spring Boot:底层是Spring框架，Spring默认框架是JCL； SpringBoot选用SLF4J和logback 2. SLF4j使用2.1 如何在系统中使用SLF4j以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；应该给系统里面导入slf4j的jar包和logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 每个日志框架的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架本身的配置文件； 2.2 遗留问题a系统(slf4j+logback)：Spring（commons-logging）、Hibernate（jboss-logging）、Mybatis 统一日志框架，即使是别的框架和我一起统一使用slf4j进行输出；核心：1、将系统中其他日志框架排除出去；2、用中间包来替换原有的日志框架/3、导入slf4j的其他实现]]></content>
      <categories>
        <category>SpringBoot - Newbie</category>
      </categories>
      <tags>
        <tag>SpringBoot - Newbie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(四) SpringBoot & Web开发]]></title>
    <url>%2F2020%2F01%2F14%2F(%E5%9B%9B)%20SpringBoot%26Web%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[(四) SpringBoot &amp; Web开发1. 简介使用SpringBoot： 1. 创建SpringBoot应用，选中我们需要的模块 2. SpringBoot以及默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3. 自己编写业务代码 自动配置原理 这个场景的SpringBoot帮我们配置了什么？能不能修改？能修改那些配置？能不能扩展？xxx 12xxxAutoConfiguration:帮我们给容器中自动配置组件xxxProperties:配置类来封装配置文件的内容 2. SpringBoot 对静态资源文件映射规则：1234567891011121314151617public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); &#125; else &#123; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;"/webjars/**"&#125;).addResourceLocations(new String[]&#123;"classpath:/META-INF/resources/webjars/"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125;&#125; 2.1 webjar1)、所有的/webjars/**，都去classpath:/META-INF/resources/webjars/找资源； ​ webjars：以jar包的方式引入静态资源 2)、”/**” 访问当前项目的任何资源 1private String staticPathPattern = &quot;/**&quot;; 访问任何资源 会在这几文件夹下去找静态路径（静态资源文件夹） 12345&quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;,&quot;classpath:/public/&quot;,&quot;/&quot;;当前项目的根路径 3)、index页面欢迎页，静态资源文件夹下所有的index.html页面；被“/**”映射； ​ localhost:8080/ –&gt;index页面 123456@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern());&#125; 4)、喜欢的图标，即网站title的图标favicon。所有的**/favicon.ico 都是在静态资源文件下找； 1234567891011121314151617181920212223242526272829@Configuration@ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true)public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //把任何favicon的图标都在静态文件夹下找 mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125;&#125; 可以在配置文件配置静态资源文件夹 1spring.resources.static-locations=classpath:xxxx 3. 模版引擎将html和数据 结合到一起 输出组装处理好的新文件SpringBoot推荐Thymeleaf;语法简单，功能强大 3.1 引入thymeleaf 31234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 3.2 Thymeleaf使用和语法ThymeleafProperties.java 123456789101112131415@ConfigurationProperties( prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = "classpath:/templates/"; private String suffix = ".html"; private String mode = "HTML"; private Charset encoding; //只要把HTML文件方法类路径下的template文件夹下，就会自动导入 //只要把HTML页面放到classpath:/templates/,thymeleaf就能自动渲染； 例如：在HelloController.java中加入 12345@RequestMapping("/success")public String success() &#123; //classpath:/templates/success.html return "success";&#125; 启动项目，浏览器中输入 http://localhost:8080/success 得到以下页面 3.2.1 如何使用Thymeleaf ?1、导入Thymeleaf 的名称空间 1&lt;html xmlns:th="http://www.thymeleaf.org"&gt; 2、使用thymeleaf语法,取出数据 首先需要在HelloController.java中添加如下代码： 123456@RequestMapping("/success")public String success(Map&lt;String,Object&gt; map) &#123; //classpath:/templates/success.html map.put("hello","你好"); return "success";&#125; 然后在 src/main/resources/templates/success.html 中写入 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Success!&lt;/h2&gt; &lt;!-- th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果：页面出现hello的值：你好 3.2.2 Thymeleaf 语法规则1）、th:text=”${hello}”可以使用任意标签 替换原生的任何属性 在SpringBoot的环境下 123&lt;div id="testid" class="testcalss" th:id="$&#123;hello&#125;" th:class="$&#123;hello&#125;" th:text="$&#123;hello&#125;"&gt; 前端数据&lt;/div&gt; 2)、内联写法注意需要在body上加上 th:inline=”text”敲黑板 不然不起作用 1&lt;body class="text-center" th:inline="text"&gt;&lt;/body&gt; th标签的访问优先级 Order Feature Attributes 功能 标签 功能和jsp对比 1 Fragment inclusion th:insert th:replace include(片段包含) 2 Fragment iteration th:each c:forEach(遍历) 3 Conditional evaluation th:if th:unless th:switch th:case c:if(条件判断) 4 Local variable definition th:object th:with c:set(声明变量) 5 General attribute modification th:attr th:attrprepend th:attrappend 属性修改支持前面和后面追加内容 6 Specific attribute modification th:value th:href th:src … 修改任意属性值 7 Text (tag body modification) th:text th:utext 修改标签体内容utext：不转义字符大标题 8 Fragment specification th:fragment 声明片段 9 Fragment removal th:remove 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Simple expressions:(表达式语法) Variable Expressions: $&#123;...&#125; 1、获取对象属性、调用方法 2、使用内置基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 3、内置一些工具对象 #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125; //选择表达式：和$&#123;&#125;功能一样，补充功能 # 配合th:object使用，object=$&#123;object&#125; 以后获取就可以使用*&#123;a&#125; 相当于$&#123;object.a&#125; &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125; //获取国际化内容 Link URL Expressions: @&#123;...&#125; //定义URL链接 #&lt;a href=&quot;details.html&quot; th:href=&quot;@&#123;/order/details(orderId=$&#123;o.id&#125;)&#125;&quot;&gt;view&lt;/a&gt; Fragment Expressions: ~&#123;...&#125;//片段文档 Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:(文本操作) String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:（条件运算） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens:（空操作） No-Operation: _ inline写法 12[[]] --&gt;th:text[()] --&gt;th:utext 4. SpringMVC自动配置4.1 SpringMVC的自动导入Spring框架 自动配置好了mvc： 以下是SpringBoot对SpringMVC的默认 Spring Boot provides auto-configuration for Spring MVC that works well with most applications. The auto-configuration adds the following features on top of Spring’s defaults: Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver(视图解析器：根据方法的返回值得到视图对象（View）,视图对象决定如何渲染（转发？重定向？）) ContentNegotiatingViewResolver组合所有视图解析器 如何定制：我们可以自己给容器中添加一个视图解析器；自动将其整合进来 Support for serving static resources, including support for WebJars (see below).静态资源 Static index.html support. Custom Favicon support (see below). 自动注册 了Converter, GenericConverter, Formatter beans. Converter：类型转换 文本转为字面量 Formatter ：格式化器 转换后格式转换 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件配置入职格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; 自己添加的格式化转换器，只需要放在容器中即可 Support for HttpMessageConverters (see below). HttpMessageConverters ：转换HTTP转换和响应：User - json HttpMessageConverters ：是从容器中确定；获取所有的HttpMessageConverters ，将自己的组件注册在容器中@Bean If you need to add or customize converters you can use Spring Boot’s HttpMessageConverters class: 123456789101112131415import org.springframework.boot.autoconfigure.web.HttpMessageConverters;import org.springframework.context.annotation.*;import org.springframework.http.converter.*;@Configurationpublic class MyConfiguration &#123; @Bean public HttpMessageConverters customConverters() &#123; HttpMessageConverter&lt;?&gt; additional = ... HttpMessageConverter&lt;?&gt; another = ... return new HttpMessageConverters(additional, another); &#125;&#125; Automatic registration of MessageCodesResolver (see below). 定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). 123456789@Overrideprotected ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer() &#123; try &#123; return this.beanFactory.getBean(ConfigurableWebBindingInitializer.class); &#125; catch (NoSuchBeanDefinitionException ex) &#123; return super.getConfigurableWebBindingInitializer(); &#125;&#125; 在beanFactory：中可以自己创建一个，初始化webDataBinder 请求数据 ==》javaBean If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 思想：修改默认配置]]></content>
      <categories>
        <category>SpringBoot - Newbie</category>
      </categories>
      <tags>
        <tag>SpringBoot - Newbie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(二) SpringBoot配置]]></title>
    <url>%2F2020%2F01%2F11%2F(%E4%BA%8C)%20%20SpringBoot%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[(二) SpringBoot配置1. 配置文件SpringBoot使用一个全局的配置文件，其格式是固定的： application.properties application.yml 配置文件的作用：修改SpringBoot自动配置( 在底层封装好 )的默认值 YAML（YAML AIN’T Markup Language）是一个标记语言,又不是一个标记语言 标记语言： 以前的配置文件；大多数使用的是 xxx.xml文件； 以数据为中心，比json、xml等更适合做配置文件 yaml: 12server: port: 8080 xml: 123&lt;server&gt; &lt;port&gt;8080&lt;/port&gt;&lt;/server&gt; 2. YAML语法2.1 基本语法key: value 表示一对键值对（需要空格） 以缩进来控制层级关系，只要是左对齐的一列数据，都是一个层级的 123server: port: 8080 path: /hello 属性和值大小写敏感 2.2 值的写法字面量：普通的值（数字，字符串，布尔） ​ k: v 字面直接来写； ​ 字符串默认不用加引号 ​ “”：双引号会转义字符串里面的特殊字符，name: “Hi \n Bey” 输出: Hi 换行 Bey ​ ‘’：单引号不会转义字符串里面的特殊字符，上述例子输出Hi \n Bey 对象、Map（属性和值）（键值对） ​ k: v ​ 对象还是k: v的方式,在下面用缩进来确定关系 123Person: name: Tom age: 20 行内写法： 1Person:&#123;name: Tom,age: 20&#125; 数组（List、Set） 用 - 值表示数组中的一个元素 1234colors: - red - pink - purple 行内写法 1colors: [red,pink,purple] person.java文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.xxf.springboot.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.context.properties.EnableConfigurationProperties;import javax.xml.crypto.Data;import java.util.List;import java.util.Map;/** 将配置文件中配置的每一个属性的值，映射到这个组件中** */@EnableConfigurationProperties(person.class)@ConfigurationProperties(prefix = "person")public class person &#123; private String lastname; private Integer age; private Boolean boss; private Data birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; public person(String lastname, Integer age, Boolean boss, Data birth, Map&lt;String, Object&gt; maps, List&lt;Object&gt; lists, Dog dog) &#123; this.lastname = lastname; this.age = age; this.boss = boss; this.birth = birth; this.maps = maps; this.lists = lists; this.dog = dog; &#125; private Dog dog; @Override public String toString() &#123; return "person&#123;" + "lastname='" + lastname + '\'' + ", age=" + age + ", boss=" + boss + ", birth=" + birth + ", maps=" + maps + ", lists=" + lists + ", dog=" + dog + '&#125;'; &#125; public String getLastname() &#123; return lastname; &#125; public void setLastname(String lastname) &#123; this.lastname = lastname; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Boolean getBoss() &#123; return boss; &#125; public void setBoss(Boolean boss) &#123; this.boss = boss; &#125; public Data getBirth() &#123; return birth; &#125; public void setBirth(Data birth) &#123; this.birth = birth; &#125; public Map&lt;String, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Object&gt; maps) &#123; this.maps = maps; &#125; public List&lt;Object&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125; Dog.java文件 123456789101112131415161718192021222324252627282930package com.xxf.springboot.bean;public class Dog &#123; private String name; private Integer age; @Override public String toString() &#123; return "Dog&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; application.yml文件 1234567891011person: lastname: xxf age: 20 boss: true birth: 1999/05/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi dog: name: sj age: 2]]></content>
      <categories>
        <category>SpringBoot - Newbie</category>
      </categories>
      <tags>
        <tag>SpringBoot - Newbie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(一) 从 Hello 到 Goodbye]]></title>
    <url>%2F2020%2F01%2F09%2F(%E4%B8%80)%20%E4%BB%8EHello%20%E5%88%B0Goodbye%2F</url>
    <content type="text"><![CDATA[(一) 从 Hello 到 Goodbye1. 前置知识 Spring 框架 maven 项目构建和依赖管理 IDEA 使用 2. 运行环境 JDK1.8 maven 3.6.1 IntelliJ IDEA 2019.3.1 x64 Spring Boot 2.2.2 3. IDEA 配置 MavenConfigure → Setting → Maven → 配置目录及本地仓库 4. Hello SpringBoot实现浏览器端发送Hello请求，服务器端接收，最终服务器端响应Hello World字符串到浏览器 这一简单Web功能。 4.1 创建maven项目（jar）Create New Project → 左边选maven → 绑定JDK → 创建项目 → Choose Enable Auto-Import(自动导入依赖) 4.2 导入相关依赖在pom.xml中的project下插入以下代码，自动导入相关依赖 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.3 编写主程序在/src/main/java 下创建package(com.xxf)再创建主程序文件(HelloWorldMainApplication &lt;— 类名) or 直接创建com.xxf.HelloWorldMainApplication.java，自动创建包。 1234567891011121314package com.xxf;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** @SpringBootApplication 来标注一个主程序类，说明这是一个SpringBoot应用* */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; //启动Spring应用 调用静态run方法来构造SpringApplication并启动SpringBoot SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 其中涉及到一个注解@SpringBootApplication @SpringBootApplication其实就是以下三个注解的总和： @Configuration： 用于定义一个配置类 @EnableAutoConfiguration ：Spring Boot会自动根据你jar包的依赖来自动配置项目。 @ComponentScan： 告诉Spring 哪个packages 的用注解标识的类 会被spring自动扫描并且装入bean容器。用它标注一个主程序类，说明这是一个SpringBoot应用 什么是注解？ 在Java中，注解(Annotation)引入始于Java5，用来描述Java代码的元信息，通常情况下注解不会直接影响代码的执行，尽管有些注解可以用来做到影响代码执行。 Java中的注解通常扮演以下角色: 编译器指令 构建时指令 运行时指令 Java中常用的注解分为三类 JDK注解 Java第三方注解 自定义注解 JDK注解 JDK注解内置的有：@Override 表示当前方法覆盖了父类的方法 @Deprecation 表示方法已经过时,方法上有横线，使用时会有警告 @SuppviseWarnings 表示关闭一些警告信息(通知java编译器忽略特定的编译警告) Java第三方注解 Spring常用注解汇总：@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。@Scope注解 作用域@Lazy(true) 表示延迟初始化@Service用于标注业务层组件、@Controller用于标注控制层组件（如struts中的action）@Repository用于标注数据访问组件，即DAO组件。@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。@Scope用于指定scope作用域的（用在类上）@PostConstruct用于指定初始化方法（用在方法上）@PreDestory用于指定销毁方法（用在方法上）@DependsOn：定义Bean初始化及销毁时的顺序@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常@Qualifier（指定注入Bean的名称）@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：@Autowired @Qualifier(“personDaoBean”) 存在多个实例配合使用@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。@PostConstruct 初始化注解@PreDestroy 摧毁注解 默认 单例 启动就加载@Async异步方法调用 springmvc常用注解标签详解(部分): @Controller 在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。@RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。。。 以上嫖自网络，后面会对注解作更深的学习 4.4 编写相关的Controller、Service创建com.xxf的一个子包和文件（controller.HelloController.java） 1234567891011121314package com.xxf.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello() &#123; return "Hello World"; &#125;&#125; 注解功能说明：（SpringMVC的东西，我不会（wuwuwu~）,后面补上） 4.5 运行主程序测试启动HelloWorldMainApplication.java下的main方法，Tomcat启用8080，在浏览器中输入 http://localhost:8080/hello ，显示“Hello World” 4.6 简化部署 在pom.xml文件中，导入build插件 ,该插件可以将应用打包成一个可执行的jar包（NB网友说新版SpringBoot会自动导入） 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 打开右边栏Maven/Lifecycle，运行package,开始打包。。。 打包之后的jar文件会存储在target目录下，下面测试一下jar包 4.7 测试jar包拿出刚刚的jar包执行： 1java -jar SpringBoot-01-HelloWorld-1.0-SNAPSHOT.jar 5. Hello World 探究5.1 POM文件5.1.1 父项目12345678910111213141516171819202122232425&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;它的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;它来真正管理SpringBoot应用里面的所有依赖版本下面有个属性，定义了对应的版本号 &lt;properties&gt; &lt;activemq.version&gt;5.15.11&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.77&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.10.1&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.9.5&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.13.2&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; &lt;awaitility.version&gt;4.0.1&lt;/awaitility.version&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt; ...... SpringBoot的版本仲裁中心； 以后导入依赖默认无需写版本（没有在dependencies里面管理的依赖自然需要申明版本号） 5.1.2 启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web ​ spring-boot-starter ：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件； spring boot将所有的功能场景都抽取出来，做成一个个的starter(启动器)，只需要在项目里引入这些starter相关场景的所有依赖都会被导入进来，要用什么功能就导入什么场景的启动器。 5.2 主程序类，主入口类12345678910/** @SpringBootApplication 来标注一个主程序类，说明这是一个SpringBoot应用* */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; //启动Spring应用 调用静态run方法来构造SpringApplication并启动SpringBoot SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: SpringBoot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动应用 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration：SpringBoot的配置类： 标注在某个类上，表示这是一个SpringBoot的配置类 @Configuration:配置类上，来标注这个注解； 配置类 —- 配置文件，也是容器中的一个组件（@Component） @EnableAutoConfiguration:开启自动配置功能 以前需要自动配置的东西，Spring Boot帮我们自动配置; @EnableAutoConfiguration告诉SpringBoot开启自动 配置功能；这样自动配置才能生效。 123@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage:自动配置包 @Import({Registrar.class})：底层注解，给容器导入组件； 将主配置类（@SpringBootApplication标注的类）的所在包及下面所有的子包里面的所有组件扫描到Spring容器；@Import({AutoConfigurationImportSelector.class})： 给容器导入组件？AutoConfigurationImportSelector：导入组件选择器 将所有需要导入的组件以及全类名的方式返回；这些组件将以字符串数组 String[] 添加到容器中；会给容器非常多的自动配置类，（xxxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置 好这些组件。 6. 使用Spring Initializer创建一个快速向导IDE都支持使用Spring的项目创建向导 自己选择需要的组件:例如web 默认生成的SpringBoot项目 主程序已经生成好了，我们只需要完成我们的逻辑 resources文件夹目录结构 static:保存所有的静态文件；js css images templates:保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat,默认不支持JSP）；可 以使用模板引擎（freemarker.thymeleaf）; application.properties:Spring Boot的默认配置，例如 server.port=9000 Reference Bilibili（ https://www.bilibili.com/video/av38657363?p=4 ） github（ https://github.com/lxy-go/SpringBoot ）]]></content>
      <categories>
        <category>SpringBoot - Newbie</category>
      </categories>
      <tags>
        <tag>SpringBoot - Newbie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错排公式]]></title>
    <url>%2F2019%2F12%2F25%2F%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[第一篇博客，写个错排公式 实践一下md语法 dp[i] = (i-1) * (dp[i-1] + dp[i-2]) 问题：把n封信装进n个信封，有多少种方法？ 公式很easy，写在上面了，现在理解一下： 假设现在已经有i-1封已经完成错排，有dp[i-1]种方式，下面处理第i封从前i-1封中取出一封(k位置)换一下，有i-1个选择，取出的信怎么处理呢？(1)放在原来的第i个位置，剩下i-2封错排之后有dp[i-2]种方式，这很容易理解。(2)不放在第i个位置,同时也不能放在k位置，只能再和剩下的i-2封换了，仔细想一下，这不就是原来的问题嘛！只不过数据规模减少了1，所以有dp[i-2]种方式。综上：dp[i] = (i-1) * (dp[i-1] + dp[i-2])&emsp;&emsp;&emsp;dp[1]=0;dp[2]=1;递归搞一搞，得结果。 就酱，第一篇结束。。。排版很low 内容很low 我也很low哎，几个月前就开了博客，一直没写过，感觉还是把接触到的有意义东西记录一下吧！毕竟记性不好，现在会的东西两个月之后也忘得差不多了。应该会写点ACM的东西吧，再传点其他方面的笔记，嗯嗯，希望自己真的能做到,结束自闭，努力学习。]]></content>
      <categories>
        <category>递推</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何模版]]></title>
    <url>%2F2019%2F12%2F25%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F</url>
    <content type="text"><![CDATA[计算几何 Computational Geometry template 注定了这篇博客又臭又长 ‘.’ 点与向量 - 定义&amp;运算const double eps=1e-10; struct Point{ double x,y; Point(double x=0,double y=0):x(x),y(y){} }; typedef Point Vector; int dcmp(double x){if(fabs(x)&lt;eps) return 0;else return x&lt;0?-1:1;} Vector operator + (Vector A,Vector B){return Vector(A.x+B.x,A.y+B.y);} Vector operator - (Point A,Point B){return Vector(A.x-B.x,A.y-B.y);} Vector operator * (Vector A,double p){return Vector(A.x*p,A.y*p);} Vector operator / (Vector A,double p){return Vector(A.x/p,A.y/p);} bool operator &lt; (const Point &amp;a,const Point &amp;b){return dcmp(a.x-b.x)&lt;0||dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)&lt;0;} bool operator == (const Point &amp;a,const Point &amp;b){return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;} double Sita(Vector A){return atan2(A.y,A.x);}//返回极角 double Dot(Vector A,Vector B){return A.x*B.x+A.y*B.y;}//点乘 double Length(Vector A){return sqrt(Dot(A,A));}//向量的模 double Angle(Vector A,Vector B){return acos(Dot(A,B)/Length(A)/Length(B));}//向量的夹角 double Cross(Vector A,Vector B){return A.x*B.y-A.y*B.x;}//叉乘 double Area2(Point A,Point B,Point C) {return Cross(B-A,C-A);}//平行四边形面积有向面积 Vector Rotate(Vector A,double rad){return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));}//向量旋转 Vector Normal(Vector A){double L=Length(A);return Vector(-A.y/L,A.x/L);}//向量的单位法线，逆时针旋转90度 确保A不是零向量 bool ToleftTest(Point a,Point b,Point c){return Cross(b-a,c-b)&gt;0;}//判断向量bc是否在向量ab的左边(逆时针) 凸包常用 点与线 定义&amp;关系//调用前确保两条直线 P+tv 和 Q+tw 有唯一交点。当且仅当Cross(v,w)!=0 Point GetLineIntersection(Point P,Vector v,Point Q,Vector w){ Vector u=P-Q; double t=Cross(w,u)/Cross(v,w); return P+v*t; } double DistanceToLine(Point P,Point A,Point B){ Vector v1=B-A,v2=P-A; return fabs(Cross(v1,v2)/Length(v1));//点到直线的距离，如果不取绝对值得到的是有向距离 } double DistanceToSegment(Point P,Point A,Point B){//点到线段的距离 if(A==B) return Length(P-A); Vector v1=B-A,v2=P-A,v3=P-B; if(dcmp(Dot(v1,v2))&lt;0) return Length(v2); else if(dcmp(Dot(v1,v3))&gt;0) return Length(v3); else return fabs(Cross(v1,v2)/Length(v1)); } double DisSegToSeg(Point a1,Point a2,Point b1,Point b2){//线段到线段的距离 return min(min(DistanceToSegment(a1,b1,b2),DistanceToSegment(a2,b1,b2)), min(DistanceToSegment(b1,a1,a2),DistanceToSegment(b2,a1,a2))); } Point GetLineProjection(Point P,Point A,Point B){//点在直线上的投影 Vector v=B-A; return A+v*(Dot(v,P-A)/Dot(v,v)); } bool OnSegment(Point p,Point a1,Point a2){ if(p==a1||p==a2) return 1;//在端点上 return dcmp(Cross(a1-p,a2-p))==0&amp;&amp;dcmp(Dot(a1-p,a2-p))&lt;0; } bool SegmentProperIntersection(Point a1,Point a2,Point b1,Point b2){//判定线段相交(规范相交) double c1=Cross(a2-a1,b1-a1),c2=Cross(a2-a1,b2-a1), c3=Cross(b2-b1,a1-b1),c4=Cross(b2-b1,a2-b1); return dcmp(c1)*dcmp(c2)&lt;0&amp;&amp;dcmp(c3)*dcmp(c4)&lt;0; } bool SegmentProperIntersection(Point a1,Point a2,Point b1,Point b2){//判定线段相交(不规范相交) double c1=Cross(a2-a1,b1-a1),c2=Cross(a2-a1,b2-a1), c3=Cross(b2-b1,a1-b1),c4=Cross(b2-b1,a2-b1); if(!dcmp(c1)||!dcmp(c2)||!dcmp(c3)||!dcmp(c4)){ bool f1=OnSegment(b1,a1,a2); bool f2=OnSegment(b2,a1,a2); bool f3=OnSegment(a1,b1,b2); bool f4=OnSegment(a2,b1,b2); bool f=(f1|f2|f3|f4); return f; } return dcmp(c1)*dcmp(c2)&lt;0&amp;&amp;dcmp(c3)*dcmp(c4)&lt;0; } 多边形typedef vector&lt;Point&gt; Polygon; double PolygonArea(Point p[],int n){//多边形有向面积(凹凸均适用) double area=0; for(int i=1;i&lt;n-1;i++) area+=Cross(p[i]-p[0],p[i+1]-p[0]); return area/2; } //winding number绕数法 int PointInPolygon(Point p,Point poly[],int n){//判定点与多边形(可能非凸)的关系 int wn=0; for(int i=0;i&lt;n;i++){ if(OnSegment(p,poly[i],poly[(i+1)%n])) return 0;//在边界上 int k=dcmp(Cross(poly[(i+1)%n]-poly[i],p-poly[i])); int d1=dcmp(poly[i].y-p.y); int d2=dcmp(poly[(i+1)%n].y-p.y); if(k&gt;0&amp;&amp;d1&lt;=0&amp;&amp;d2&gt;0) wn++; if(k&lt;0&amp;&amp;d2&lt;=0&amp;&amp;d1&gt;0) wn--; } if(wn!=0) return -1;//在内部 return 1;//在外部 } /* 判定点与凸多边形的关系，凸包内的点按逆时针旋转(否则把&lt;0 改为&gt;0) -1：在凸边形外 0：在边界上 1：在内部 */ int PointInConvex(Point p,Polygon &amp;poly){ int n=poly.size(); for(int i=0;i&lt;n;i++) if(dcmp(Cross(poly[i]-p,poly[(i+1)%n]-p))&lt;0) return -1; else if(OnSegment(p,poly[i],poly[(i+1)%n])) return 0; return 1; } /*判定凸多边形,点按顺时针或逆时针均可,点的编号1~n-1*/ bool IsConvex(Point poly[],int n){ bool s[3];memset(s,0,sizeof(s)); for(int i=0;i&lt;n;i++){ s[dcmp(Cross(poly[(i+1)%n]-poly[i],poly[(i+2)%n]-poly[i]))+1]=1; if(s[0]&amp;&amp;s[2]) return 0; } return 1; } //两个多边形面积交与并 double CPIA(Point a[], Point b[], int na, int nb){//传入两个三角形，求相交部分的凸包 Point p[20], tmp[20]; //复制点集与临时点集（P其实可以用B来做 int tn, sflag, eflag; //每轮相交凸包的点，叉乘符号 a[na] = a[0], b[nb] = b[0]; //末点用初点复制方便首末点连边 memcpy(p,b,sizeof(Point)*(nb + 1)); //把B复制到P for(int i=0;i&lt;na&amp;&amp;nb&gt;2;i++){ //扫一次A sflag=dcmp(Cross(a[i+1]-a[i],p[0]-a[i])); //取A两点与B第一点求叉乘符号 for(int j=tn=0;j&lt;nb;j++,sflag=eflag){ //扫一次B，更新TMP，TN是点数 if(sflag&gt;=0)tmp[tn++]=p[j]; //叉乘为正就是B数组的那个点压入 eflag=dcmp(Cross(a[i+1]-a[i],p[j+1]-a[i]));//求叉乘符号 if((sflag^eflag)==-2) //1异或-1等于-2 tmp[tn++]=GetLineIntersection(a[i+1]-a[i],p[j+1]-p[j]);//求交点 } memcpy(p, tmp, sizeof(Point) * tn); //把TMP复制到P nb = tn, p[nb] = p[0];//TN即TMP点数记到NB }//其实该是NP表示P数组个数，这里省了个变量就用NB表示，下面第二行做参数而已 if(nb &lt; 3) return 0.0; //相交部分凸包不够三个点，面积就是0 return PolygonArea(p, nb); //求出相交凸包部分的面积 } double SPIA(Point a[], Point b[], int na, int nb){//传入两个多边形的点 int i,j; //循环变量 Point t1[4],t2[4]; //其实T13与T23没用上 double res=0,num1,num2; //答案初始化，及叉乘符号 a[na]=t1[0]=a[0],b[nb]=t2[0]=b[0]; //初始化T1,T2和ANA,BNB for(i=2;i&lt;na;i++){ //扫一次第一个多边形全部点 t1[1]=a[i-1],t1[2]=a[i]; //每次在第一个多边形取两个点赋给T11,T12 num1=dcmp(Cross(t1[1]-t1[0],t1[2]-t1[0]));//求出叉乘符号 if(num1&lt;0)swap(t1[1],t1[2]); //小于0则改变T11,T12可使叉乘符号变正，实即改变T1三个点的顺逆 for(j=2;j&lt;nb;j++){ //扫一次第二个多边形全部点 t2[1]=b[j-1],t2[2]=b[j]; //然后再在第二个多边形取两个点赋给T21,T22 num2=dcmp(Cross(t2[1]-t1[0],t2[2]-t1[0]));//求出叉乘符号 if(num2&lt;0)swap(t2[1],t2[2]);//小于0则改变T11,T12可使叉乘符号变正，实即改变T1三个点的顺逆 res+=CPIA(t1,t2,3,3); //累加相交部分面积 } } return res; } Point p1[maxn], p2[maxn];//两个数组存读入点集 int main() { int n1, n2; //定义 while(cin&gt;&gt;n1&gt;&gt;n2){ //输入两个多边形的点数 for(int i=0;i&lt;n1;i++)scanf(&quot;%lf%lf&quot;,&amp;p1[i].x,&amp;p1[i].y);//输入点数 for(int i=0;i&lt;n2;i++)scanf(&quot;%lf%lf&quot;,&amp;p2[i].x,&amp;p2[i].y);//输入点数 cout&lt;&lt;SPIA(p1,p2,n1,n2)&lt;&lt;endl;//输出面积交 }//如果要求面积并，则先用三角剖分分别求两个多边形的面积S1,S2，然后S1+S2-面积交即可 return 0; } 整数点int CountPointInSegment(Point a,Point b){//线段上的整数点 return __gcd(fabs(a.x-b.x),fabs(a.y-b.y))+1; } int CountPointOnEdge(Point p[],int n){//多边形上的整数点 int ans=0; for(int i=0;i&lt;n;i++) ans+=__gcd(fabs(p[i].x-p[(i+1)%n].x),fabs(p[i].y-p[(i+1)%n].y)); return ans; } int CountPointInSide(Point p[],int n){//多边形内部整数点 int ans=0; for(int i=0;i&lt;n;i++) ans+=p[(i+1)%n].y*(p[i].x-p[(i+2)%n].x); return (fabs(ans)-CountPointOnEdge(p,n))/2+1; } 圆与直线struct Line{ Point p;//直线上任意一点 Vector v;//方向向量，它的左边就是对应的半平面 double ang;//极角。即从x正半轴旋转到向量v所需的角(弧度) Line() {} Line(Point p=Point(),Vector v=Vector()):p(p),v(v){ang=atan2(v.y,v.x);} bool operator&lt; (const Line&amp; L) const{//排序用的比较运算符 return ang&lt;L.ang; } Point point(double t){return p+v*t;} }; struct Circle{ Point c; double r; Circle(Point c=Point(),double r=0.0):c(c),r(r){} Point point(double a){return Point(c.x+r*cos(a),c.y+r*sin(a));} }; int getLineCircleIntersection(Line L,Circle C,double &amp;t1,double &amp;t2,vector&lt;Point&gt;&amp; sol){//直线与圆的交点 double a=L.v.x, b=L.p.x-C.c.x, c=L.v.y, d=L.p.y-C.c.y; double e=a*a+c*c, f=2*(a*b+c*d), g=b*b+d*d-C.r*C.r; double delta=f*f-4*e*g;//判别式 if(dcmp(delta)&lt;0) return 0;//相离 if(dcmp(delta)==0){//相切 t1=t2=-f/(2*e);sol.push_back(L.point(t1)); return 1; } //相交 t1=(-f-sqrt(delta))/(2*e);sol.push_back(L.point(t1)); t2=(-f+sqrt(delta))/(2*e);sol.push_back(L.point(t2)); return 2; } double angle(Vector v){return atan2(v.y,v.x);} int getCircleCircleIntersection(Circle C1,Circle C2,vector&lt;Point&gt;&amp; sol){//求两圆的交点 double d=Length(C1.c-C2.c); if(dcmp(d)==0){ if(dcmp(C1.r-C2.r)==0) return -1;//两圆重合 return 0; } if(dcmp(C1.r+C2.r-d)&lt;0) return 0;//内含 if(dcmp(fabs(C1.r-C2.r)-d)&gt;0) return 0;//外离 double a=angle(C2.c-C1.c); double da=acos((C1.r*C1.r+d*d-C2.r*C2.r)/(2*C1.r*d));//向量C1C2的极角 //C1C2到C1P1的角 Point p1=C1.point(a-da),p2=C1.point(a+da); sol.push_back(p1); if(p1==p2) return 1; sol.push_back(p2); return 2; } //过点p到圆C的切线。v[i]是第i条切线的向量。返回切线条数 int getTangents(Point p,Circle C,Vector* v){ Vector u=C.c-p; double dist=Length(u); if(dist&lt;C.r) return 0;//p在圆中无切线 else if(dcmp(dist-C.r)==0){//p在圆上一条切线 v[0]=Rotate(u,PI/2); return 1; }else{//p在圆外两条切线 double ang=asin(C.r/dist); v[0]=Rotate(u,-ang); v[1]=Rotate(u,+ang); return 2; } } //求线圆切点 Point getTan_Point(Point p,Circle C,Vector v){ double len1=Length(C.c-p)*Length(C.c-p)-C.r*C.r; double k=sqrt((len1)/(v.x*v.x+v.y*v.y)); return Point(p.x+v.x*k,p.y+v.y*k); } //两圆的公切线，返回切线的条数。-1表示无穷多条切线。 //a[i]和b[i]分别是第i条切线在圆A和圆B上的切点 int getTangents(Circle A,Circle B,Point* a,Point* b){ int cnt=0; if(dcmp(A.r-B.r)&lt;0){swap(A,B);swap(a,b);} double d2=sqrt((A.c.x-B.c.x)*(A.c.x-B.c.x)+(A.c.y-B.c.y)*(A.c.y-B.c.y)); double rdiff=A.r-B.r; double rsum=A.r+B.r; if(dcmp(d2-rdiff)&lt;0) return 0;//内含 double base=atan2(B.c.y-A.c.y,B.c.x-A.c.x); if(dcmp(d2)==0) return -1;//无限多条切线 if(dcmp(d2-rdiff)==0){//内切,一条切线 a[cnt]=b[cnt]=A.point(base); cnt++; return 1; } //有外共切线 double ang=acos((A.r-B.r)/d2); a[cnt]=A.point(base+ang);b[cnt]=B.point(base+ang);cnt++; a[cnt]=A.point(base-ang);b[cnt]=B.point(base-ang);cnt++; if(dcmp(d2-rsum)==0){ a[cnt]=b[cnt]=A.point(base);cnt++; } else if(dcmp(d2-rsum)&gt;0){ double ang=acos((A.r+B.r)/d2); a[cnt]=A.point(base+ang);b[cnt]=B.point(PI+base+ang);cnt++; a[cnt]=A.point(base-ang);b[cnt]=B.point(PI+base-ang);cnt++; } return cnt; } //两圆相交的面积 //三角形外接圆(三点保证不共线) Circle CircumscribedCircle(Point p1,Point p2,Point p3){ double Bx=p2.x-p1.x,By=p2.y-p1.y; double Cx=p3.x-p1.x,Cy=p3.y-p1.y; double D=2*(Bx*Cy-By*Cx); double cx=(Cy*(Bx*Bx+By*By)-By*(Cx*Cx+Cy*Cy))/D+p1.x; double cy=(Bx*(Cx*Cx+Cy*Cy)-Cx*(Bx*Bx+By*By))/D+p1.y; Point p=Point(cx,cy); return Circle(p,Length(p1-p)); } //三角形内切圆 Circle InscribedCircle(Point p1,Point p2,Point p3){ double a=Length(p2-p3); double b=Length(p3-p1); double c=Length(p1-p2); Point p=(p1*a+p2*b+p3*c)/(a+b+c); return Circle(p,DistanceToLine(p,p1,p2)); } //圆与多边形面积交 double TriAngleCircleInsection(Circle C, Point A, Point B) { Vector OA = A-C.c, OB = B-C.c; Vector BA = A-B, BC = C.c-B; Vector AB = B-A, AC = C.c-A; double DOA = Length(OA), DOB = Length(OB),DAB = Length(AB), r = C.r; if(dcmp(Cross(OA,OB)) == 0) return 0; if(dcmp(DOA-C.r) &lt; 0 &amp;&amp; dcmp(DOB-C.r) &lt; 0) return Cross(OA,OB)*0.5; else if(DOB &lt; r &amp;&amp; DOA &gt;= r) { double x = (Dot(BA,BC) + sqrt(r*r*DAB*DAB-Cross(BA,BC)*Cross(BA,BC)))/DAB; double TS = Cross(OA,OB)*0.5; return asin(TS*(1-x/DAB)*2/r/DOA)*r*r*0.5+TS*x/DAB; } else if(DOB &gt;= r &amp;&amp; DOA &lt; r) { double y = (Dot(AB,AC)+sqrt(r*r*DAB*DAB-Cross(AB,AC)*Cross(AB,AC)))/DAB; double TS = Cross(OA,OB)*0.5; return asin(TS*(1-y/DAB)*2/r/DOB)*r*r*0.5+TS*y/DAB; } else if(fabs(Cross(OA,OB)) &gt;= r*DAB || Dot(AB,AC) &lt;= 0 || Dot(BA,BC) &lt;= 0) { if(Dot(OA,OB) &lt; 0){ if(Cross(OA,OB) &lt; 0) return (-acos(-1.0)-asin(Cross(OA,OB)/DOA/DOB))*r*r*0.5; else return ( acos(-1.0)-asin(Cross(OA,OB)/DOA/DOB))*r*r*0.5; } else return asin(Cross(OA,OB)/DOA/DOB)*r*r*0.5; } else { double x = (Dot(BA,BC)+sqrt(r*r*DAB*DAB-Cross(BA,BC)*Cross(BA,BC)))/DAB; double y = (Dot(AB,AC)+sqrt(r*r*DAB*DAB-Cross(AB,AC)*Cross(AB,AC)))/DAB; double TS = Cross(OA,OB)*0.5; return (asin(TS*(1-x/DAB)*2/r/DOA)+asin(TS*(1-y/DAB)*2/r/DOB))*r*r*0.5 + TS*((x+y)/DAB-1); } } Point p[666],A,B; int main() { int n,i,j,cas = 1; double k; while(scanf(&quot;%d%lf&quot;,&amp;n,&amp;k)!=EOF) { for(i=1;i&lt;=n;i++) p[i].input(); A.input(),B.input(),p[n+1] = p[1]; double D = (2.0*k*k*A.x-2.0*B.x)/(1.0-k*k); double E = (2.0*k*k*A.y-2.0*B.y)/(1.0-k*k); double F = (B.x*B.x+B.y*B.y-k*k*(A.x*A.x+A.y*A.y))/(1.0-k*k); Circle C = Circle(Point(-D*0.5,-E*0.5),sqrt(D*D+E*E-4.0*F)*0.5); double ans = 0.0; for(i=1;i&lt;=n;i++) ans += TriAngleCircleInsection(C, p[i], p[i+1]); printf(&quot;Case %d: %.10f\n&quot;,cas++,fabs(ans)); } return 0; } 球面问题//经纬度转化为空间坐标 //角度转换成弧度 double torad(double deg){ return deg/180*acos(-1); // acos(-1) 就是PI } //经纬度（角度）转化为空间坐标 void get_coord(double R,double lat,double lng,double &amp;x,double &amp;y,double &amp;z){ lat=torad(lat); lng=torad(lng); x=R*cos(lat)*cos(lng); y=R*cos(lat)*sin(lng); z=R*sin(lat); } 半径为r，弦长为d的圆弧长度： 圆心角为：2arcsin(d/2r) -&gt; 2*asin(d/(2*r)) 弧长为： 2arcsin(d/2r)r -&gt; 2*asin(d/(2*r))*r 二维凸包虽然凸包也是多边形。。。 //二维凸包 //计算凸包，输入点数组p，个数为p，输出点数组ch。返回凸包顶点数 //输入不能有重复点。函数执行完之后输入点的顺序被破坏 //如果不希望在凸包的边上有输入点，把两个&lt;=改为&lt; //在精度要求较高时建议用dcmp比较 int ConvexHull(Point* p,int n,Point* ch){ sort(p,p+n);//先比较x,再比较y int m=0; for(int i=0;i&lt;n;i++){ while(m&gt;1&amp;&amp;Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; } int k=m; for(int i=n-2;i&gt;=0;i--){ while(m&gt;k&amp;&amp;Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; } if(n&gt;1) m--; return m; } double Diameter(Point P[],int n)//旋转卡壳法求凸包的直径即最大的点对距离 { double ans=-1; if(n==2) return Length(P[1]-P[0]); for(int i=0,k=0;i&lt;n;i++){ while(Length(P[i]-P[k])&lt;Length(P[i]-P[(k+1)%n])) k=(k+1)%n; ans=max(ans,Length(P[i]-P[k])); } return ans; } //凸包相交 //if(ConvexHullIntersection(ch1,t1,ch2,t2)&amp;&amp;ConvexHullIntersection(ch2,t2,ch1,t1))printf(&quot;YES\n&quot;);else printf(&quot;NO\n&quot;); bool ConvexHullIntersection(Point *ch1,int t1,Point *ch2,int t2)//判断凸包是否相交 { double angle[maxn],x; int i,j,k,m; if(t1==1) return true; if(t1==2){ for(i=0;i&lt;t2;i++){ k=dcmp(Cross(ch1[1]-ch1[0],ch2[i]-ch1[0])); if(k==0&amp;&amp;Dot(ch1[1]-ch1[0],ch2[i]-ch1[0])&gt;0) if(Length(ch2[i]-ch1[0])&lt;Length(ch1[1]-ch1[0]))break; } if(i&lt;t2)return false; if(t2==2&amp;&amp;SegmentProperIntersection(ch1[0],ch1[1],ch2[0],ch2[1]))return false; return true; } angle[0]=0; for(i=2;i&lt;t1;i++) angle[i-1]=Angle(ch1[1]-ch1[0],ch1[i]-ch1[0]); for(i=0;i&lt;t2;i++){ j=dcmp(Cross(ch1[1]-ch1[0],ch2[i]-ch1[0])); if(j&lt;0||(j==0&amp;&amp;Dot(ch1[1]-ch1[0],ch2[i]-ch1[0])&lt;0))continue; j=dcmp(Cross(ch1[t1-1]-ch1[0],ch2[i]-ch1[0])); if(j&gt;0||(j==0&amp;&amp;Dot(ch1[t1-1]-ch1[0],ch2[i]-ch1[0])&lt;0))continue; x=Angle(ch1[1]-ch1[0],ch2[i]-ch1[0]); m=lower_bound(angle,angle+t1-1,x)-angle; if(m==0) j=0; else j=m-1; k=dcmp(Cross(ch1[j+1]-ch2[i],ch1[j+2]-ch2[i])); if(k&gt;=0)break; } if(i&lt;t2)return false; return true; } 半平面交简单地说，半平面交问题就是给出若干个半平面，求他们的公共部分。 其中每个半平面都用一条有向线段表示，它的左侧就是它所代表的半平面。 struct Line{ Point p;//直线上任意一点 Vector v;//方向向量，它的左边就是对应的半平面 double ang;//极角。即从x正半轴旋转到向量v所需的角(弧度) Line() {} Line(Point p,Vector v):p(p),v(v){ang=atan2(v.y,v.x);} bool operator&lt; (const Line&amp; L) const{//排序用的比较运算符 return ang&lt;L.ang; } Point point(double t){return p+v*t;} }; //点p在有向直线L的左侧 bool OnLeft(Line L,Point p){return Cross(L.v,p-L.p) &gt; 0;} //两直线交点。假定交点唯一存在 Point GetIntersection(Line a,Line b){ Vector u=a.p-b.p; double t=Cross(b.v,u)/Cross(a.v,b.v); return a.p+a.v*t; } //半平面交的主过程 int HalfplaneIntersection(Line* L,int n,Point* poly){ sort(L,L+n);//按照极角排序 int first=0,last=0;//双端队列的第一个元素和最后一个元素 Point *P=new Point[n];//p[i] 为 q[i]与q[i + 1]的交点 Line *q=new Line[n];//双端队列 q[first=last=0]=L[0];//初始化为只有一个半平面L[0] for(int i=1;i&lt;n;++i){ while(first&lt;last&amp;&amp;!OnLeft(L[i],P[last-1])) last--; while(first&lt;last&amp;&amp;!OnLeft(L[i],P[first])) first++; q[++last]=L[i]; if(dcmp(Cross(q[last].v,q[last-1].v))==0){//两向量平行且同向，取内侧一个 last--;if(OnLeft(q[last],L[i].p)) q[last]=L[i]; } if(first&lt;last) P[last-1]=GetIntersection(q[last-1],q[last]); } while(first&lt;last&amp;&amp;!OnLeft(q[first],P[last-1])) last--; //删除无用平面 if(last-first&lt;=1)return 0;//空集 P[last]=GetIntersection(q[last],q[first]);//计算首尾两个半平面的交点 //从deque复制到输出中 int m=0; for(int i=first;i&lt;=last;++i) poly[m++]=P[i]; return m; } 最近点对-分治struct Point{ double x,y; Point(double x=0.0,double y=0.0):x(x),y(y){} }P[maxn]; int mpt[maxn]; bool cmpxy(const Point &amp;a,const Point &amp;b){return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);} bool cmpy(const int &amp;a,const int &amp;b){return P[a].y&lt;P[b].y;} double min(double a,double b){return a&lt;b?a:b;} double Distance(const int&amp; a,const int&amp; b){ return sqrt((P[a].x-P[b].x)*(P[a].x-P[b].x)+(P[a].y-P[b].y)*(P[a].y-P[b].y)); } double Closest_Pair(int l,int r){ double d=1e20; if(l==r) return d; if(l+1==r) return Distance(l,r); int mid =(l+r)&gt;&gt;1; double d1=Closest_Pair(l,mid); double d2=Closest_Pair(mid+1,r); d=min(d1,d2);int i,j,k=0; //分离出宽度为d的区间 for(i=l;i&lt;=r;i++) if(fabs(P[mid].x-P[i].x)&lt;=d) mpt[k++]=i; sort(mpt,mpt+k,cmpy); //线性扫描 for(i=0;i&lt;k;i++){ for(j=i+1;j&lt;k&amp;&amp;P[mpt[j]].y-P[mpt[i]].y&lt;d;j++){ double d3=Distance(mpt[i],mpt[j]); if(d&gt;d3) d=d3; } } return d; } int main() { int n;scanf(&quot;%d&quot;,&amp;n); double x,y; for(int i=0;i&lt;n;i++) scanf(&quot;%lf%lf&quot;,&amp;P[i].x,&amp;P[i].y); sort(P,P+n,cmpxy); printf(&quot;%.11f\n&quot;,Closest_Pair(0,n-1)); return 0; } 线段交点个数(平行坐标轴)(离散化+树状数组)struct Line{ int x,y,z; Line(int x=0,int y=0,int z=0):x(x),y(y),z(z){} bool operator&lt; (const Line&amp; t)const{ return x&lt;t.x || x==t.x &amp;&amp; z&lt;t.z; } }a[maxn],b[maxn],c[maxn*2]; int val[maxn*4],cnt; int id(int x){return lower_bound(val+1,val+1+cnt,x)-val;} struct BIT{ int a[maxn*5]; void init(){mem(a,0);} int lowbit(int x){return x&amp;(-x);} void update(int x,int val){ for(int i=x;i&lt;=maxn&lt;&lt;2;i+=lowbit(i)) a[i]+=val; } int query(int x){ int res=0; for(int i=x;i&gt;0;i-=lowbit(i)) res+=a[i]; return res; } int solve(int x,int y){ return query(y)-query(x-1); } }Tree; int main() { fastinout; int k,na=0,nb=0,nc=0; cnt=0;cin&gt;&gt;k; for(int i=1;i&lt;=k;i++){ int x1,x2,y1,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; val[++cnt]=x1;val[++cnt]=y1; val[++cnt]=x2;val[++cnt]=y2; if(x1==x2){ if(y1&gt;y2) swap(y1,y2); b[++nb]=Line(x1,y1,y2); } if(y1==y2){ if(x1&gt;x2) swap(x1,x2); a[++na]=Line(y1,x1,x2); } } sort(val+1,val+1+cnt); cnt=unique(val+1,val+1+cnt)-val-1; for(int i=1;i&lt;=na;i++){ a[i].x=id(a[i].x); a[i].y=id(a[i].y); a[i].z=id(a[i].z); c[++nc]=Line(a[i].y,i,1); c[++nc]=Line(a[i].z,i,3); } for(int i=1;i&lt;=nb;i++){ b[i].x=id(b[i].x); b[i].y=id(b[i].y); b[i].z=id(b[i].z); c[++nc]=Line(b[i].x,i,2); } sort(c+1,c+1+nc);Tree.init(); ll ans=0; for(int i=1;i&lt;=nc;i++){ if(c[i].z==1) Tree.update(a[c[i].y].x,1); if(c[i].z==2) ans+=Tree.solve(b[c[i].y].y,b[c[i].y].z); if(c[i].z==3) Tree.update(a[c[i].y].x,-1); } cout&lt;&lt;ans&lt;&lt;endl; } 旋转卡壳 三维几何]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2019%2F12%2F25%2F%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[背包问题参考背包九讲的内容，首先给定一个有容量的背包(限定条件)，再给出每件(种)物品的价值和体积，背包问题大致可分为以下几种： 1.01背包(n个物品，对每个物品选或不选) 2.完全背包(n种物品，每种可取无数件，每件物品选或不选) 3.多重背包(n种物品，每种可取k[i]件,不选/选/选几件) 4.分组背包(n组物品，每组最多选一件，选/不选) 5.二维费用背包(两个维度的限制条件) 6.混合背包(1.2.3三种情况的混合) 7.其他(问法不同(最值与可行性)、泛化物品) 01背包最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放 F[i,v] 表示前 i 件物品恰放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程便是： F[i,v]=max{F[i−1,v],F[i−1,v−C[i]]+W[i]} 伪代码(时间和空间复杂度均为O(VN))： F[0,0..V ] ← 0 for i ← 1 to N for v ← C i to V F[i,v]=max{F[i−1,v],F[i−1,v−C[i]]+W[i]} 滚动数组优化空间复杂度：F[v]=max{F[v],F[v−C[i]]+W[i]} 伪代码(时间复杂度O(VN)、空间复杂度为O(N))： F[0..V ]←0 for i ← 1 to N for v ← V to C i //注意递推是从上一次的正上方和左边过来的，这里就不难理解了 F[v]=max{F[v],F[v−C[i]]+W[i]} 不同的问法：恰好装满 与 不必装满 若是恰好装满，那么在初始化时除了F[0]为0，其它F[1..V]均设为 −∞ ，这样就可以保证最终得到的F[V]是一种恰好装满背包的最优解。 可以理解为：初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满， 那么此时只有容量为 0 的背包可以在什么也不装且价值为0的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 -∞ 了。 如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为0了。 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 F[0..V ]全部设为 0 。 01背包题目HDU-2995 小数/概率 背包题意：抢劫银行，给定被抓最大概率P，给出n个银行(其价值和被抓概率)，求被抓概率小于P的情况下，可抢到的最大价值。 注意：概率不是累加而是累乘，同时应把最抓概率转换成不被抓概率，因为被抓概率累乘会变得更小，显然错误，应该是不被抓概率累乘变得更小。 思路：开始直接想到背包容量定为最大概率P，但是它是小数，想到P*100(or 1ek)转化为整数 结果WA； 于是转变思路，让背包容量等于所有银行价值之和，dp[i]-&gt;不被抓概率 //HDU-2995 小数/概率 背包 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=105; int w[maxn]; double v[maxn],dp[maxn*100]; int main() { ios::sync_with_stdio(0);cin.tie(0); int T;cin&gt;&gt;T; //int V=0 开始在这里定义 结果TLE 怎么又犯这种错误. while(T--){ int V=0; double P;int n;cin&gt;&gt;P&gt;&gt;n;P=1.0-P;//转为不被抓概率 for(int i=0;i&lt;n;i++){ cin&gt;&gt;w[i]&gt;&gt;v[i];v[i]=1.0-v[i];V+=w[i]; } for(int i=0;i&lt;n*100;i++) dp[i]=0;dp[0]=1; for(int i=0;i&lt;n;i++){ for(int j=V;j&gt;=w[i];j--){ dp[j]=max(dp[j],dp[j-w[i]]*v[i]); } } int ans=0; for(int i=V;i&gt;=0;i--){ if(dp[i]&gt;=P){ ans=i;break; } } cout&lt;&lt;ans&lt;&lt;endl; } } CF-366C 转化为01背包题意:有n个水果, 每个水果都有两个属性值ai表示美味程度, bi表示能量值, 现在要求选出一个或多个水果, 使得选出的水果的ai和与bi和的比例是k 问在这种情形可能出现的情况下ai的和最多是多少, 如果这样的情形不存在输出 -1 思路：每个物品的耗费是a[i]-k*b[i]的物品，这样就可以转化为01背包，求dp[i][0]，但是这样算耗值可能是负值，所以我们数组平移n*100个单位，就可以求出dp[n][m] 注意：此题不能用一个dp数组完成滚动，因为a[i]-k*b[i]可能为负值，转移可能来自上一层的左上方或右上方，若滚动会覆盖冲突。 //CF-366C 转化为01背包 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=105; const int INF=0x3f3f3f3f; int n,k; int a[maxn],b[maxn],dp[maxn][maxn*300]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;k; memset(dp,-INF,sizeof(dp));//无意义状态 dp[0][100*n]=0;//不选时合法 for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;b[i];b[i]=a[i]-k*b[i]; } for(int i=1;i&lt;=n;i++){ for(int j=b[i];j&lt;=200*n;j++){ dp[i][j]=max(dp[i-1][j],dp[i-1][j-b[i]]+a[i]); } } int ans=dp[n][100*n]; cout&lt;&lt;(ans?ans:-1)&lt;&lt;endl; } 完全背包完全背包与01背包唯一不同的是完全背包的每件物品可重复使用无数次。 状态转移： F[i,v] = max{F[i−1,v−kC[i]]+kW[i] | 0 ≤ kC[i]≤ v} 伪代码： F[0..V]←0 for i ← 1 to N for v ← C i to V F[v] ← max(F[v],F[v − C[i]] + W[i]) 有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。 第 i 种物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤1000 0&lt;vi,wi≤1000 样例 输入:4 5 输出：10 1 2 2 4 3 4 4 5 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; int v[maxn],w[maxn],dp[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int N,V;cin&gt;&gt;N&gt;&gt;V; for(int i=0;i&lt;N;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=0;i&lt;N;i++) dp[i]=0; for(int i=0;i&lt;N;i++) for(int j=v[i];j&lt;=V;j++)//注意循环方向 dp[j]=max(dp[j],dp[j-v[i]]+w[i]); cout&lt;&lt;dp[V]&lt;&lt;endl; } 多重背包多重背包中每个物品可使用的次数是有限制条件的，因此要假如第三重循环，限制选的次数。 注意：背包问题中第一重循环是物品种类 ，第二重是背包体积 ，第三重是限制条件 多重背包的优化： 二进制优化、单调队列优化 模版题： 有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 无优化 O(n*V*S)： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; int dp[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int N,V;cin&gt;&gt;N&gt;&gt;V; for(int i=0;i&lt;N;i++) dp[i]=0; for(int i=0;i&lt;N;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; for(int j=V;j&gt;=v;j--) for(int k=0;k&lt;=s&amp;&amp;k*v&lt;=j;k++) dp[j]=max(dp[j],dp[j-k*v]+k*w); } cout&lt;&lt;dp[V]&lt;&lt;endl; } 二进制优化 O(n*V*ΣS)： 数据范围：0&lt;N≤1000 0&lt;V≤2000 0&lt;vi,wi,si≤2000 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e3+5; int dp[maxn]; struct node{ int v,w; }; vector&lt;node&gt; goods; int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m;cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; for(int k=1;k&lt;=s;k*=2){ s-=k;goods.push_back({v*k,w*k}); } if(s) goods.push_back({v*s,w*s}); } for(auto good:goods) for(int j=m;j&gt;=good.v;j--) dp[j]=max(dp[j],dp[j-good.v]+good.w); cout&lt;&lt;dp[m]&lt;&lt;endl; } 单调队列优化 0(N*V): //未懂，待补+双端队列(滑动窗口) 数据范围：0&lt;N≤1000 0&lt;V≤20000 0&lt;vi,wi,si≤20000 双端队列思想优化背包问题-&gt; https://blog.csdn.net/hebtu666/article/details/83018230 首先优化思路来自最最原始的无优化的方程。 仔细观察，对于任意的j，都是从v[i]的倍数转移过来的。它们本来应该是连续的，可以用滑动窗口（不熟悉此问题的同学可以先行百度）解决。但在无优化的时候却每次把所有的倍数都遍历了一遍。 所以可以把m根据模v[i]的余数分为v[i]类。 for(int j=0;j&lt;v;j++) 此时对于任意的j，只需要向v[i]的倍数去转移。所以我们在下一层循环的时候把k定义为j+k*v[i] for(int k=j;k&lt;=m;k+=v) 此时的k相当于原来的j，但是我们可以利用k和v之间存在的倍数关系去做滑动窗口。 由于滑动窗口记录的是下标，但每一个k所对应的下标都是在变化的。所以要根据当前的k判断窗口里存在的k对应的值包含了多少个v，以便于计算新的价值 v的个数=(下标-余数)/v 价值=(下标-余数)/v*w =(q[h]-j)/v =(k-j)/v*w 然后每次只用了前i-1的值，所以可以滚动数组优化一下空间 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e4+5; int n,m,dp[maxn],q[maxn],g[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; memcpy(g,dp,sizeof(dp));//滚动数组优化空间，g[]即dp[i-1][]; for(int j=0;j&lt;v;j++){ int h=0,t=-1; for(int k=j;k&lt;=m;k+=v){ dp[k]=g[k]; if(h&lt;t&amp;&amp;k-s*v&gt;q[h]) h++;//如果当前窗口的内容超过了s个; if(h&lt;=t) dp[k]=max(dp[k],g[q[h]]+(k-q[h])/v*w);//max(f[i-1][k],f[i-1][能转移里最大]+个数*v[i]); while(h&lt;=t&amp;&amp;g[q[t]]-(q[t]-j)/v*w&lt;=g[k]-(k-j)/v*w) t--; q[++t]=k; } } } cout&lt;&lt;dp[m]&lt;&lt;endl; } 混合背包混合背包就是把以上三种背包问题混合在一起，什么物品可以选几次有响应的限制条件，根据条件选择不同的dp方程即可 模版题： 有 N 种物品和一个容量是 V 的背包。物品一共有三类： * 第一类物品只能用1次（01背包）； * 第二类物品可以用无限次（完全背包）； * 第三类物品最多只能用 si 次（多重背包）； 每种体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式： 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 si=−1 表示第 i 种物品只能用1次； si=0 表示第 i 种物品可以用无限次； si&gt;0 表示第 i 种物品可以使用 si 次； 输出格式： 输出一个整数，表示最大价值。 数据范围：0&lt;N,V≤1000 ，0&lt;vi,wi≤1000 ，−1≤si≤1000 输入样例： 输出样例： 4 5 8 1 2 -1 2 4 1 3 4 0 4 5 2 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e3+5; int dp[maxn]; struct node{ int v,w,s; }; int n,V; vector&lt;node&gt; G; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=0;i&lt;n;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; if(s==-1) G.push_back({v,w,-1}); else if(s==0) G.push_back({v,w,0}); else{ for(int k=1;k&lt;=s;k*=2){ G.push_back({v*k,w*k,-1});s-=k; } if(s) G.push_back({v*s,w*s,-1}); } } for(auto g:G){ if(g.s==-1) for(int j=V;j&gt;=g.v;j--) dp[j]=max(dp[j],dp[j-g.v]+g.w); else if(g.s==0) for(int j=g.v;j&lt;=V;j++) dp[j]=max(dp[j],dp[j-g.v]+g.w); } cout&lt;&lt;dp[V]&lt;&lt;endl; } 二维费用背包二维费用背包就是加了重限制条件，物品的总体积与物品的总重量都不能超过背包可承受范围。 有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。 每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。 输出最大价值。 输入格式： 第一行两个整数，N，V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。 接下来有 N 行，每行三个整数 vi,mi,wi，用空格隔开，分别表示第 i 件物品的体积、重量和价值。 输出格式： 输出一个整数，表示最大价值。 数据范围： 0&lt;N≤1000 ，0&lt;V,M≤100 ，0&lt;vi,mi≤100 ，0&lt;wi≤1000 输入样例： 输出样例： 4 5 6 8 1 2 3 2 4 4 3 4 5 4 5 6 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e3+5; int n,V,M; int v[maxn],m[maxn],w[maxn]; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V&gt;&gt;M; for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i]&gt;&gt;m[i]&gt;&gt;w[i]; for(int i=0;i&lt;n;i++) for(int j=V;j&gt;=v[i];j--) for(int k=M;k&gt;=m[i];k--) dp[j][k]=max(dp[j][k],dp[j-v[i]][k-m[i]]+w[i]); cout&lt;&lt;dp[V][M]&lt;&lt;endl; } 分组背包分组背包就是把物品分为很多组，限定每组最多可选的个数 有 N 组物品和一个容量是 V 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。 每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。 接下来有 N 组数据： 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量； 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值； 输出格式 输出一个整数，表示最大价值。 数据范围：0&lt;N,V≤100，0&lt;Si≤100，0&lt;vij,wij≤100 输入样例： 输出样例： 3 5 8 2 1 2 2 4 1 3 4 1 4 5 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e2+5; int n,V; int v[maxn],w[maxn];//体积和价值 int dp[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=0;i&lt;n;i++){ int s;cin&gt;&gt;s; for(int j=1;j&lt;=s;j++) cin&gt;&gt;v[j]&gt;&gt;w[j]; for(int j=V;j&gt;=0;j--) for(int k=1;k&lt;=s;k++)每组选一个使价值最大化 if(j&gt;=v[k]) dp[j]=max(dp[j],dp[j-v[k]]+w[k]); } cout&lt;&lt;dp[V]&lt;&lt;endl; } 有依赖的背包问题待补 有 N 个物品和一个容量是 V 的背包。 物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。 如上图所示： 如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。 每件物品的编号是 i，体积是 vi，价值是 wi，依赖的父节点编号是 pi。物品的下标范围是 1…N。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式： 第一行有两个整数 N，V，用空格隔开，分别表示物品个数和背包容量。 接下来有 N 行数据，每行数据表示一个物品。 第 i 行有三个整数 vi,wi,pi，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。 如果 pi=−1，表示根节点。 数据保证所有物品构成一棵树。 输出格式： 输出一个整数，表示最大价值。 数据范围：1≤N,V≤100，1≤vi,wi≤100 父节点编号范围： 内部结点：1≤pi≤N; 根节点 pi=−1; 输入样例 输出样例： 5 7 11 2 3 -1 2 2 1 3 5 1 4 7 2 3 6 2 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int h[N], e[N], ne[N], idx; int v[N], w[N]; int f[N][N]; void add(int x, int y) { e[idx] = y, ne[idx] = h[x], h[x] = idx++; } void dfs(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int y = e[i]; dfs(y); for (int j = m - v[x]; j &gt;= 0; j--) { for (int k = 0; k &lt;= j; k++) { f[x][j] = max(f[x][j], f[x][j - k] + f[y][k]); } } } for (int i = m; i &gt;= v[x]; i--) { f[x][i] = f[x][i - v[x]] + w[x]; } for (int i = 0; i &lt; v[x]; i++) { f[x][i] = 0; } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int root; for (int i = 1; i &lt;= n; i++) { int p; cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p; if (p == -1) { root = i; } else { add(p, i); } } dfs(root); cout &lt;&lt; f[root][m] &lt;&lt; endl; return 0; } 背包问题求方案数有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 1e9+7 的结果。 输入格式: 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式: 输出一个整数，表示 方案数 模 109+7 的结果。 数据范围: 0&lt;N,V≤1000, 0&lt;vi,wi≤1000 输入样例: 输出样例: 4 5 2 1 2 2 4 3 4 4 6 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; const ll mod=1e9+7; int n,V; int v[maxn],w[maxn]; int dp[maxn]; ll num[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=0;i&lt;=V;i++) num[i]=1; for(int i=1;i&lt;=n;i++){ for(int j=V;j&gt;=v[i];j--){ if(dp[j]&lt;dp[j-v[i]]+w[i]){ dp[j]=dp[j-v[i]]+w[i]; num[j]=num[j-v[i]]%mod; } else if(dp[j]==dp[j-v[i]]+w[i]){ num[j]=(num[j-v[i]]+num[j])%mod; } } } cout&lt;&lt;num[V]&lt;&lt;endl; } 背包问题求具有方案有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 1e9+7 的结果。 输入格式: 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式: 输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。 物品编号范围是 1…N 数据范围: 0&lt;N,V≤1000, 0&lt;vi,wi≤1000 输入样例: 输出样例: 4 5 1 4 1 2 2 4 3 4 4 6 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; const ll mod=1e9+7; int n,V; int v[maxn],w[maxn]; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=n;i&gt;=1;i--) for(int j=0;j&lt;=V;j++){//这样写dp方程是因为dp[i][j]的意义与之前的不同 //dp[i][j] -&gt;从前i件物品中选，使得背包容量大于j的 方案的价值 if(j&gt;=v[i]) dp[i][j]=max(dp[i+1][j],dp[i+1][j-v[i]]+w[i]); else dp[i][j]=dp[i+1][j]; } for(int i=1;i&lt;=n;i++){ if(i==n&amp;&amp;V&gt;=v[i]){ cout&lt;&lt;i&lt;&lt;&quot; &quot;;break; } if(V-v[i]&gt;=0&amp;&amp;dp[i][V]==dp[i+1][V-v[i]]+w[i]){ cout&lt;&lt;i&lt;&lt;&quot; &quot;;V-=v[i]; } if(V&lt;0) break; } } 超大背包体积超大、价值适合给出N个物品，所有物品的的价值总和V不会超过5000，但是背包的体积B和物品的体积超大(1e10)，求背包能装出来的最大价值 这种背包问题显然要以价值为突破口，转化一下dp的含义，令dp[i][j]-&gt;从前i个物品中选出价值总和为j的物品的最小的体积， 那么求最大价值时按照V从大到小遍历dp即可，当dp[i][j]&lt;=B时输出j即可 FZU-2214 #include&lt;iostream&gt; using namespace std; typedef long long ll; const ll INF=1e12; int v[505]; ll w[505],dp[5005]; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int T;cin&gt;&gt;T; while(T--){ int n,V=0;ll B;cin&gt;&gt;n&gt;&gt;B; for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i],V+=v[i]; for(int i=1;i&lt;=V;i++) dp[i]=INF;dp[0]=0;//注意初始化 for(int i=1;i&lt;=n;i++) for(int j=V;j&gt;=v[i];j--) dp[j]=min(dp[j],dp[j-v[i]]+w[i]); for(int i=V;i&gt;=0;i--){ if(dp[i]&lt;=B){ cout&lt;&lt;i&lt;&lt;endl;break; } } } } 体积超大、价值超大这种题目显然不能dp了，因为数组开不下，记录不了状态，那怎么做呢。往往会设置一个比较小的物品数量，使得可以折半枚举。 给你N(N≤40)个物品，物品的单个价值和重量都达到10^15问你在背包容量为W下背包所能装出来的最大价值 采用折半枚举法，先把前2^20个物品的组合先枚举预处理出来2^20个w、v。 然后如果我们能对于这枚举出来的前 2^20 个和后面 2^20 个物品的某个组合结合然后找出最优的结果，最后从这 2^20 个最优结果中再取最优就是答案，问题就是如何对于预处理出来的前 2^20 个组合与后面结合产生最优。 假设现在背包容量为 C ，在前 2^20 个物品组合中取出一个，价值为 vi 重量为 wi ，那么如果我们能从后 2^20 个中找出一个组合使得其在满足重量 w&apos; ≤ C - wi 的情况下价值最大 只要对于后 2^20 个的所有组合处理出其重量和价值，然后根据重量排序且根据价值去重 这样就能用二分查找来加快查找速度！ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=40; const ll INF=0x3f3f3f3f3f3f3f3f; pair&lt;ll,ll&gt; pi[1&lt;&lt;(maxn/2)];//(重量，价值) ll w[maxn],v[maxn],N,W; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin&gt;&gt;N&gt;&gt;W; for(int i=0;i&lt;N;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; //枚举前半部分 O(2^N/2) int N2=N/2; for(int i=0;i&lt;(1&lt;&lt;N2);i++){ ll sw=0,sv=0; for(int j=0;j&lt;N2;j++){ if(i&gt;&gt;j&amp;1){//按二进制枚举 sw+=w[j];sv+=v[j]; } } pi[i]=make_pair(sw,sv); } //去除多余的元素：使得对i&lt;j有 sw[i]&lt;=sw[j]并且sv[i]&gt;=sv[j] sort(pi,pi+(1&lt;&lt;N2));//按照第一键值（重量）排序 int num=1; for(int i=1;i&lt;(1&lt;&lt;N2);i++) if(pi[num-1].second&lt;pi[i].second)//当i的重量大于num-1的重量且价值小于num-1的价值时，i被放弃 pi[num++]=pi[i]; ll ans=0; for(int i=0;i&lt;(1&lt;&lt;(N-N2));i++){//枚举后半段的组合 ll sw=0,sv=0; for(int j=0;j&lt;(N-N2);j++){ if(i&gt;&gt;j&amp;1){ sw+=w[N2+j];sv+=v[N2+j]; } } if(sw&lt;=W){//在前半段的组合中找到体积小于等于W-sw的第一个即价值最大的那个 int idx=(lower_bound(pi,pi+num,make_pair(W-sw,INF))-pi)-1; pair&lt;ll,ll&gt;tmp=pi[idx]; ans=max(ans,sv+tmp.second); } } cout&lt;&lt;ans&lt;&lt;endl; } /* 体积 价值 4 5 4 2 5 2 2 1 8 3 13 */]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流]]></title>
    <url>%2F2019%2F12%2F25%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[网络流重在建图,再套模版 -最大流、最小割、最大匹配、最大权闭合图 Blog：https://www.cnblogs.com/Paul-Guderian/p/6657639.html https://www.cnblogs.com/zsnuo/p/8909613.html https://loj.ac/problems/tag/30,6 模版模版1(Dinic-SPFA from CSL O(nnm))#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e4+5; struct Edge{ int from,to,cap,flow; Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){} }; struct Dinic{ int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn],cur[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap){ edges.emplace_back(from,to,cap,0); edges.emplace_back(to,from,0,0); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BFS(){ memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); queue&lt;int&gt; q;q.push(s); d[s]=0;vis[s]=1; while(!q.empty()){ int x=q.front();q.pop(); for(int i=0;i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){ vis[e.to]=1;d[e.to]=d[x]+1;q.push(e.to); } } } return vis[t]; } int DFS(int x,int a){ if(x==t||a==0) return a; int flow=0,f; for(int&amp; i=cur[x];i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(d[x]+1==d[e.to]&amp;&amp;(f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){ e.flow+=f;edges[G[x][i]^1].flow-=f; flow+=f;a-=f;if(a==0) break; } } return flow; } int Maxflow(int s,int t){ this-&gt;s=s;this-&gt;t=t; int flow=0; while(BFS()){ memset(cur,0,sizeof(cur)); flow+=DFS(s,INF); } return flow; } }; 模版2(Dijkstr-MCMF from NBWY)#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;int,int&gt; pii; const int maxn=1e4; const int INF=0x7fffffff; struct edge{ int to,capacity,cost,rev; edge(){} edge(int to,int _capacity,int _cost,int _rev):to(to),capacity(_capacity),cost(_cost),rev(_rev) {} }; struct Min_Cost_Max_Flow { int V,H[maxn],dis[maxn+5],PreV[maxn+5],PreE[maxn+5]; vector&lt;edge&gt; G[maxn]; void init(int n){ V=n;for(int i=0;i&lt;=V;++i)G[i].clear(); } void Add_Edge(int from,int to,int cap,int cost){ G[from].push_back(edge(to, cap, cost, G[to].size())); G[to].push_back(edge(from, 0, -cost, G[from].size() - 1)); } //flow是自己传进去的变量，就是最后的最大流，返回的是最小费用 int Min_cost_max_flow(int s,int t,int f,int&amp; flow){ int res=0;fill(H,H+1+V,0); while(f){ priority_queue &lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt; &gt; q; fill(dis,dis+1+V,INF); dis[s]=0;q.push(pair&lt;int,int&gt;(0,s)); while(!q.empty()){ pair&lt;int,int&gt; now=q.top();q.pop(); int v=now.second; if(dis[v]&lt;now.first) continue; for(int i=0;i&lt;G[v].size();++i){ edge&amp; e=G[v][i]; if(e.capacity&gt;0&amp;&amp;dis[e.to]&gt;dis[v]+e.cost+H[v]-H[e.to]){ dis[e.to]=dis[v]+e.cost+H[v]-H[e.to]; PreV[e.to]=v;PreE[e.to]=i; q.push(pair&lt;int,int&gt;(dis[e.to],e.to)); } } } if(dis[t]==INF)break; for(int i=0;i&lt;=V;++i) H[i]+=dis[i]; int d=f; for(int v=t;v!=s;v=PreV[v]) d=min(d,G[PreV[v]][PreE[v]].capacity); f-=d;flow+=d;res+=d*H[t]; for (int v=t;v!=s;v=PreV[v]){ edge&amp; e=G[PreV[v]][PreE[v]]; e.capacity-=d; G[v][e.rev].capacity+=d; } } return res; } int Max_cost_max_flow(int s,int t,int f, int&amp; flow) { int res=0; fill(H,H+1+V,0); while(f){ priority_queue &lt;pair&lt;int, int&gt;&gt; q; fill(dis,dis+1+V,-INF); dis[s]=0; q.push(pair&lt;int,int&gt;(0,s)); while(!q.empty()){ pair&lt;int,int&gt; now=q.top();q.pop(); int v=now.second; if(dis[v]&gt;now.first)continue; for (int i=0;i&lt;G[v].size();i++){ edge&amp; e=G[v][i]; if(e.capacity&gt;0&amp;&amp;dis[e.to]&lt;dis[v]+e.cost+H[v]-H[e.to]){ dis[e.to]=dis[v]+e.cost+H[v]-H[e.to]; PreV[e.to]=v;PreE[e.to]=i; q.push(pair&lt;int,int&gt;(dis[e.to],e.to)); } } } if(dis[t]==-INF)break; for(int i=0;i&lt;=V;i++) H[i]+=dis[i]; int d=f; for(int v=t;v!=s;v=PreV[v]) d=min(d,G[PreV[v]][PreE[v]].capacity); f-=d;flow+=d; res+=d*H[t]; for(int v=t;v!=s;v=PreV[v]){ edge&amp; e=G[PreV[v]][PreE[v]]; e.capacity-=d; G[v][e.rev].capacity+=d; } } return res; } }; int flow,a[maxn]; Min_Cost_Max_Flow MCMF; int main() { int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n,k;scanf(&quot;%d%d&quot;,&amp;n,&amp;k); MCMF.init(2*n+2); for(int i=1;i&lt;= n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); MCMF.Add_Edge(i,i+n,1,-a[i]); } for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if (a[i]&lt;=a[j]) MCMF.Add_Edge(i+n,j,1,0); MCMF.Add_Edge(0,2*n+1,k,0); for(int i=1;i&lt;=n;++i) { MCMF.Add_Edge(2*n+1,i,1,0); MCMF.Add_Edge(i+n,2*n+2,1,0); } cout&lt;&lt;-MCMF.Min_cost_max_flow(0,2*n+2,INF,flow)&lt;&lt;endl; return 0; } } 模版3(Dijkstr-Bellman from CSL)#include&lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int INF=0x3f3f3f3f; const int maxn=2005; struct Edge{ int from,to,cap,flow,cost; Edge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w){} }; struct MCMF { int n,m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn]; int d[maxn]; int p[maxn]; int a[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap,int cost){ edges.emplace_back(from,to,cap,0,cost); edges.emplace_back(to,from,0,0,-cost); int m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BellmanFord(int s,int t,int &amp;flow,ll &amp;cost){ for(int i=0;i&lt;n;i++) d[i]=INF; memset(inq,0,sizeof(inq));d[s]=0;inq[s]=1;p[s]=0;a[s]=INF; queue&lt;int&gt; q;q.push(s); while(!q.empty()){ int u=q.front();q.pop();inq[u]=0; for(int i=0;i&lt;G[u].size();i++){ Edge&amp; e=edges[G[u][i]]; if(e.cap&gt;e.flow&amp;&amp;d[e.to]&gt;d[u]+e.cost){ d[e.to]=d[u]+e.cost;p[e.to]=G[u][i]; a[e.to]=min(a[u],e.cap-e.flow); if(!inq[e.to]){ q.push(e.to);inq[e.to]=1; } } } } if(d[t]==INF) return 0; flow+=a[t]; cost+=(ll)d[t]*(ll)a[t]; for(int u=t;u!=s;u=edges[p[u]].from){ edges[p[u]].flow+=a[t]; edges[p[u]^1].flow-=a[t]; } return 1; } int MincostMAXflow(int s,int t,ll &amp;cost){ int flow=0;cost=0; while(BellmanFord(s,t,flow,cost)); return flow; } }Mc; 模版4(最大匹配)#include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 105; int n, m; vector&lt;int&gt; G[maxn]; int linker[maxn]; bool used[maxn]; inline void init(int n) { for (int i = 0; i &lt;= n; i++) G[i].clear(); } inline void addedge(int u, int v) { G[u].push_back(v); } inline bool dfs(int u) { for (auto &amp;v : G[u]) { if (!used[v]) { used[v] = 1; if (linker[v] == -1 || dfs(linker[v])) { linker[v] = u; return 1; } } } return 0; } inline int hungary() { int ans = 0; memset(linker, -1, sizeof(linker)); for (int u = 1; u &lt;= m; u++) {//左边点的个数 memset(used, 0, sizeof(used)); if (dfs(u)) ans++; } return ans; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int u, v; while (~scanf(&quot;%d%d&quot;, &amp;u, &amp;v)) { addedge(u, v); } printf(&quot;%d\n&quot;, hungary()); } 题目题源：https://loj.ac/problems/search?keyword=%E7%BD%91%E7%BB%9C%E6%B5%81 1.飞行员配对方案问题(最大匹配)题意：每架飞机需要两个驾驶员，一个正驾驶员和一个副驾驶员。由于种种原因，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。两个正驾驶员或两个副驾驶员都不能同机飞行。 思路：拆点跑网络流或二分图最大匹配裸题，备忘两种都写了 1.拆点网络流 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=500; const int INF=0x3f3f3f3f; struct Edge{ int from,to,cap,flow; Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){} }; struct Dinic{ int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn],cur[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap){ edges.emplace_back(from,to,cap,0); edges.emplace_back(to,from,0,0); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BFS(){ memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); queue&lt;int&gt; q;q.push(s); d[s]=0;vis[s]=1; while(!q.empty()){ int x=q.front();q.pop(); for(int i=0;i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){ vis[e.to]=1;d[e.to]=d[x]+1;q.push(e.to); } } } return vis[t]; } int DFS(int x,int a){ if(x==t||a==0) return a; int flow=0,f; for(int&amp; i=cur[x];i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(d[x]+1==d[e.to]&amp;&amp;(f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){ e.flow+=f;edges[G[x][i]^1].flow-=f; flow+=f;a-=f;if(a==0) break; } } return flow; } int Maxflow(int s,int t){ this-&gt;s=s;this-&gt;t=t; int flow=0; while(BFS()){ memset(cur,0,sizeof(cur)); flow+=DFS(s,INF); } return flow; } }Dic; int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int x=0; Dic.init(2*n+2); for(int i=1;i&lt;=n;i++) Dic.AddEdge(i,i+n,1); int u,v; while(~scanf(&quot;%d%d&quot;,&amp;u,&amp;v)){ Dic.AddEdge(u+n,v,1); } for(int i=1;i&lt;=m;i++) Dic.AddEdge(0,i,1); for(int i=m+1;i&lt;=n;i++) Dic.AddEdge(i+n,2*n+1,1); int ans=Dic.Maxflow(0,2*n+1); printf(&quot;%d\n&quot;,ans); } 2.二分图最大匹配 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 105; int n, m; vector&lt;int&gt; G[maxn]; int linker[maxn]; bool used[maxn]; inline void init(int n) { for (int i = 0; i &lt;= n; i++) G[i].clear(); } inline void addedge(int u, int v) { G[u].push_back(v); } inline bool dfs(int u) { for (auto &amp;v : G[u]) { if (!used[v]) { used[v] = 1; if (linker[v] == -1 || dfs(linker[v])) { linker[v] = u; return 1; } } } return 0; } inline int hungary() { int ans = 0; memset(linker, -1, sizeof(linker)); for (int u = 1; u &lt;= m; u++) { memset(used, 0, sizeof(used)); if (dfs(u)) ans++; } return ans; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int u, v; while (~scanf(&quot;%d%d&quot;, &amp;u, &amp;v)) { addedge(u, v); } printf(&quot;%d\n&quot;, hungary()); } 2.太空飞行计划（最大点权闭合子图）最大权闭合子图：给定带权图G(权值可正可负),求一个权和最大的点集，使得起点在该点集中的任意弧，终点也在该点集中 解法：新增源点s和汇点t，从s向所有正权点引一条边，容量为权值；从所有负权点向汇点引一条边，容量为权值的相反数。求出最小割f,S-{s}就是最大权闭合子图。 题意：现已确定了一个可供选择的实验集合 E={E1,E2,⋯,Em}，和进行这些实验需要使用的全部仪器的集合 I={I1,I2,⋯,In}。实验 Ej 需要用到的仪器是 I 的子集 Rj⊆I。 配置仪器 Ik​​ 的费用为 ck​​ 美元。实验 Ej 的赞助商已同意为该实验结果支付 pj 美元。对于给定的实验和仪器配置情况，找出净收益最大的试验计划. 思路：最大权闭合子图。从 S 向每个实验连一条容量为 pi 的边，每个实验向所需要的仪器连一条容量为INF的边，每个仪器向 T 连一条容量为 ci 的边。答案为 ∑pi−maxflow 。 对于输出方案，如果d[i]!=0那么i点显然走过了。输出即可 输入输出太坑了！！！ vector&lt;int&gt; v1,v2; int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;m,&amp;n);Dic.init(n+m+2); int S=0; for(int i=1;i&lt;=m;i++){ int p,v;char ch;scanf(&quot;%d&quot;,&amp;p);S+=p; Dic.AddEdge(0,i,p); while(getchar()==&apos; &apos;){ scanf(&quot;%d&quot;,&amp;v); Dic.AddEdge(i,v+m,INF); } } for(int i=m+1;i&lt;=n+m;i++){ int c;scanf(&quot;%d&quot;,&amp;c); Dic.AddEdge(i,n+m+1,c); } int ans=S-Dic.Maxflow(0,n+m+1); v1.clear();v2.clear(); for(int i=1;i&lt;=m;i++) if(Dic.d[i]!=0) v1.push_back(i); for(int i=1;i&lt;=n;i++) if(Dic.d[i+m]!=0) v2.push_back(i); printf(&quot;%d&quot;,v1[0]);for(int i=1;i&lt;v1.size();i++) printf(&quot; %d&quot;,v1[i]);printf(&quot;\n&quot;); printf(&quot;%d&quot;,v2[0]);for(int i=1;i&lt;v2.size();i++) printf(&quot; %d&quot;,v2[i]);printf(&quot;\n&quot;); printf(&quot;%d\n&quot;,ans); } 3.最小路径覆盖(二分图匹配) 定义：通俗点讲，就是在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。 最小路径覆盖分为最小不相交路径覆盖和最小可相交路径覆盖。 最小不相交路径覆盖：每一条路径经过的顶点各不相同。如图，其最小路径覆盖数为3。即1-&gt;3&gt;4，2，5。 最小可相交路径覆盖：每一条路径经过的顶点可以相同。如果其最小路径覆盖数为2。即1-&gt;3-&gt;4，2-&gt;3&gt;5。 DAG的最小不相交路径覆盖:拆点得二分图，最小路径覆盖=原图节点数-新图最大匹配数 把原图的每个点V拆成Vx和Vy两个点，如果有一条有向边A-&gt;B，那么就加边Ax−&gt;By。这样就得到了一个二分图。那么最小路径覆盖=原图的结点数-新图的最大匹配数 一开始每个点都是独立的为一条路径，总共有n条不相交路径。我们每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，也就相当于路径数减少了1。所以找到了几条匹配边，路径数就减少了多少。所以有最小路径覆盖=原图的结点数-新图的最大匹配数。 DAG的最小可相交路径覆盖：先用floyd求出原图的传递闭包，即如果a到b有路径，那么就加边a-&gt;b。然后就转化成了最小不相交路径覆盖问题。 为了连通两个点，某条路径可能经过其它路径的中间点。比如1-&gt;3-&gt;4，2-&gt;4-&gt;5。但是如果两个点a和b是连通的，只不过中间需要经过其它的点，那么可以在这两个点之间加边，那么a就可以直达b，不必经过中点的，那么就转化成了最小不相交路径覆盖。 题意：给定有向图 G=(V,E)。设 P 是 G 的一个简单路（顶点不相交）的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。 P 中路径可以从 V 的任何一个顶点开始，长度也是任意的， 特别地，可以为 0。G 的最小路径覆盖是 G 的所含路径条数最少的路径覆盖。 求一个有向无环图 G 的最小路径覆盖。 分析：二分图最大匹配。将每个点拆为两个点，在新图中对应连边。二分图的每一个合法匹配都可以视为一种路径覆盖的方式，路径条数为总点数-匹配数。最小不相交路径覆盖即为总点数-二分图最大匹配。（建图方式仅限DAG） 此题需要输出路径，根据匹配找路径即可，注意记录路径 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 505; vector&lt;int&gt; G[maxn]; int linker[maxn]; bool used[maxn]; inline void init(int n){ for(int i=0;i&lt;=n;i++) G[i].clear(); } inline void addedge(int u,int v){G[u].push_back(v);} inline bool dfs(int u){ for (auto &amp;v:G[u]){ if (!used[v]){ used[v]=1; if(linker[v]==-1||dfs(linker[v])){ linker[v] = u;linker[u]=v;//记录路径 return 1; } } } return 0; } inline int hungary(int n){ int ans=0; memset(linker,-1,sizeof(linker)); for (int u=1;u&lt;=n;u++){//左边点的个数 memset(used,0,sizeof(used)); if(dfs(u)) ans++; } return ans; } inline void print(int u,int n){ printf(&quot; %d&quot;,u-n); if(linker[u-n]!=-1) print(linker[u-n],n); } int main() { int n,m,u,v; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); while(m--){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v+n); } int ans=hungary(n); for(int i=n+1;i&lt;=2*n;i++){ if(linker[i]==-1){ printf(&quot;%d&quot;,i-n); if(linker[i-n]!=-1) print(linker[i-n],n); printf(&quot;\n&quot;); } } printf(&quot;%d\n&quot;,n-ans); } 若使用网络流算法可以根据每两点之间流量的关系找回路径，下面是NB网友的代码： int main() { n=read();m=read();S=0;T=n*2+1; for(int i=1;i&lt;=m;i++) { x=read();y=read(); insert(x,y+n,1); } for(int i=1;i&lt;=n;i++)insert(S,i,1); for(int i=1;i&lt;=n;i++)insert(i+n,T,1); while(bfs()) { for(int i=S;i&lt;=T;i++)cur[i]=first[i]; ans+=dfs(S,inf); } for(int x=1;x&lt;=n;x++) for(int i=first[x];i;i=e[i].next) if(!e[i].flow&amp;&amp;e[i].to)to[x]=e[i].to-n,ind[e[i].to-n]++; for(int x=1;x&lt;=n;x++) if(!ind[x]) { for(int i=x;i;i=to[i])printf(&quot;%d &quot;,i); printf(&quot;\n&quot;); } printf(&quot;%d\n&quot;,n-ans); return 0; } 4.魔术球(待补)#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int from,to,cap,flow; Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){} }; struct Dinic{ int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn],cur[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap){ edges.emplace_back(from,to,cap,0); edges.emplace_back(to,from,0,0); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BFS(){ memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); queue&lt;int&gt; q;q.push(s); d[s]=0;vis[s]=1; while(!q.empty()){ int x=q.front();q.pop(); for(int i=0;i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){ vis[e.to]=1;d[e.to]=d[x]+1;q.push(e.to); } } } return vis[t]; } int DFS(int x,int a){ if(x==t||a==0) return a; int flow=0,f; for(int&amp; i=cur[x];i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(d[x]+1==d[e.to]&amp;&amp;(f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){ e.flow+=f;edges[G[x][i]^1].flow-=f; flow+=f;a-=f;if(a==0) break; } } return flow; } int Maxflow(int s,int t){ this-&gt;s=s;this-&gt;t=t; int flow=0; while(BFS()){ memset(cur,0,sizeof(cur)); flow+=DFS(s,INF); } return flow; } }Dic; bool check(int x,int y){ int t=sqrt(x+y); return t*t==x+y; } int to[maxn]; int main() { int n; while(~scanf(&quot;%d&quot;,&amp;n)){ int s=0,t=401,cnt=0,ans=0;Dic.init(401); while(1){ ans++;cnt++;Dic.AddEdge(s,ans,1); Dic.AddEdge(ans+200,t,1); for(int i=1;i&lt;ans;i++) if(check(i,ans)) Dic.AddEdge(i,ans+200,1); cnt-=Dic.Maxflow(s,t); if(cnt&gt;n) break; }ans--; printf(&quot;%d\n&quot;,ans); for(int i=1;i&lt;=ans;i++) for(auto &amp;v:Dic.G[i]) if(!Dic.edges[v].flow&amp;&amp;Dic.edges[v].to){ to[i]=Dic.edges[v].to-200;break; } for(int i=1;i&lt;=ans;i++) if(!Dic.vis[i]){ for(int j=i;j;j=to[j]) printf(&quot;%d &quot;,j),Dic.vis[i]=1; printf(&quot;\n&quot;); } } } 5.圆桌聚餐(最大流)题意：来自n个不同单位的代表参加一次国际会议。每个单位的代表数分别为ri。会议餐厅共有m张餐桌，每张餐桌可容纳ci个代表就餐。为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试给出满足要求的代表就餐方案。 思路：最大流。从S向每个单位连一条容量为人数的边，从餐桌向T连接一条容量为餐桌容量的边，从单位向每个餐桌连一条容量为1的边。直接跑最大流求解。 注意判断是否有解应该是将最大流与总人数比较，若最大流等于总人数输出1，否则输出0； int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int s=0,t=n+m+1,sum=0;Dic.init(n+m+1); for(int i=1;i&lt;=n;i++){ int x;scanf(&quot;%d&quot;,&amp;x);Dic.AddEdge(s,i,x);sum+=x; } for(int i=n+1;i&lt;=n+m;i++){ int x;scanf(&quot;%d&quot;,&amp;x);Dic.AddEdge(i,t,x); } for(int i=1;i&lt;=n;i++){ for(int j=n+1;j&lt;=n+m;j++){ Dic.AddEdge(i,j,1); } } int ans=Dic.Maxflow(s,t); if(ans&gt;=sum) printf(&quot;1\n&quot;); else {printf(&quot;0\n&quot;);return 0;} for(int i=1;i&lt;=n;i++){ for(auto &amp;v:Dic.G[i]){ if(Dic.edges[v].flow&gt;0) printf(&quot;%d &quot;,Dic.edges[v].to-n); } printf(&quot;\n&quot;); } } 6.最长递增子序列问题(最大流)题意：给定正整数序列x1∼xn,以下递增均为非严格递增.计算其最长递增子序列的长度s;计算从给定的序列中最多可取出多少个长度为s的递增子序列。 如果允许在取出的序列中多次使用x1​和xn,则从给定序列中最多可取出多少个长度为s的递增子序列。 令fi表示以第i位开头的最长递增子序列长度，可用dp求解。若fi=s,则从S向i连一条容量为1的边;若fi=1,则从i向T连一条容量为1的边； 限定每个点只选一次,拆点，连一条容量为1的边；若i&lt;j且xi&lt;=xj且fi=fj+1，则从i向j连一条容量为1的边。直接跑最大流求解即可。 回答第三问时，把对应边的限制放成 inf，再跑一次最大流。 int main() { int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) {scanf(&quot;%d&quot;,&amp;a[i]);dp[i]=1;} for(int i=n;i&gt;=1;i--){ for(int j=n;j&gt;i;j--){ if(a[j]&gt;=a[i]) dp[i]=max(dp[i],dp[j]+1); } } int MAX=0; for(int i=1;i&lt;=n;i++) MAX=max(MAX,dp[i]); if(MAX==1) {printf(&quot;1\n&quot;);printf(&quot;%d\n&quot;,n);printf(&quot;%d\n&quot;,n);return 0;} int s=0,t=2*n+1;Dic.init(2*n+1); for(int i=1;i&lt;=n;i++){ Dic.AddEdge(i,i+n,1); if(dp[i]==MAX) Dic.AddEdge(s,i,1); if(dp[i]==1) Dic.AddEdge(i+n,t,1); } for(int i=1;i&lt;=n;i++){ for(int j=i+1;j&lt;=n;j++){ if(a[j]&gt;=a[i]&amp;&amp;dp[i]==dp[j]+1) Dic.AddEdge(i,j,1); } } int ans1=Dic.Maxflow(s,t); Dic.init(2*n+1);Dic.AddEdge(1,1+n,INF);Dic.AddEdge(n,n+n,INF); for(int i=2;i&lt;n;i++) Dic.AddEdge(i,i+n,1); for(int i=1;i&lt;=n;i++){ if(dp[i]==MAX){ if(i==1||i==n) Dic.AddEdge(s,i,INF); else Dic.AddEdge(s,i,1); } if(dp[i]==1){ if(i==1||i==n) Dic.AddEdge(i+n,t,INF); else Dic.AddEdge(i+n,t,1); } for(int j=i+1;j&lt;=n;j++){ if(a[j]&gt;=a[i]&amp;&amp;dp[i]==dp[j]+1) Dic.AddEdge(i,j,1); } } int ans2=Dic.Maxflow(s,t); printf(&quot;%d\n&quot;,MAX);printf(&quot;%d\n&quot;,ans1);printf(&quot;%d\n&quot;,ans2); } 7.试题库问题(最大流)题意：假设一个试题库中有n道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。 现要从题库中抽取m道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。 分析：最大流。从S向每种类别连一条容量为需求的边，从题目向T连接一条容量为1的边,从每个类别向题目连一条容量为1的边。直接跑最大流求解即可。 int main() { int k,n,sum=0;scanf(&quot;%d%d&quot;,&amp;k,&amp;n); int s=0,t=n+k+1;Dic.init(n+k+1); for(int i=1;i&lt;=k;i++){ int c;scanf(&quot;%d&quot;,&amp;c);Dic.AddEdge(0,i,c);sum+=c; } for(int i=k+1;i&lt;=k+n;i++){ int c;scanf(&quot;%d&quot;,&amp;c); while(c--){ int x;scanf(&quot;%d&quot;,&amp;x); Dic.AddEdge(x,i,1); } Dic.AddEdge(i,t,1); } int ans=Dic.Maxflow(s,t); if(ans!=sum) {printf(&quot;No Solution!\n&quot;);return 0;} for(int i=1;i&lt;=k;i++){ printf(&quot;%d:&quot;,i); for(auto &amp;v:Dic.G[i]){ if(Dic.edges[v].flow&gt;0) printf(&quot; %d&quot;,Dic.edges[v].to-k); } printf(&quot;\n&quot;); } } 8.机器人路径规划问题 9.方格取数问题(最大点权独立集)最大独立集：从一个图中找出一种点集，任意两点之间没有边，且点的数量最大 最大点权独立集：从一个图中找出一种点集，任意两点之间没有边，每个点有相应的权值，要求所有点的权值和最大。 最小覆盖集：在一个图中找出这么一个点击，使得所有的边的至少一个端点属于这个集合，并要求点的数量最小 最小点权覆盖：在一个图中找出这么一个点击，使得所有的边的至少一个端点属于这个集合，每个点有权值，要求点的权值和最小。 结论：最大独立集+最小覆盖集=总点数 最大点权独立集+最小点权覆盖=总点权和 最小点权覆盖=最大流 二分图建成网络流以后，，可以用最小割的概念去理解，找出最小的边权（实际上是把点权移到边上了）使得二分图的两个点集不连通，而不连通就是满足了题意 ********************************************************** 二分图最小点覆盖和最大独立集都可以转化为最大匹配求解。在这个基础上，把每个点赋予一个非负的权值，这两个问题就转化为：二分图最小点权覆盖和二分图最大点权独立集。 二分图最小点权覆盖：从x或者y集合中选取一些点，使这些点覆盖所有的边，并且选出来的点的权值尽可能小。 建模：原二分图中的边(u,v)替换为容量为INF的有向边(u,v)，设立源点s和汇点t，将s和x集合中的点相连，容量为该点的权值；将y中的点同t相连，容量为该点的权值。在新图上求最大流，最大流量即为最小点权覆盖的权值和。 二分图最大点权独立集：在二分图中找到权值和最大的点集，使得它们之间两两没有边。 其实它是最小点权覆盖的对偶问题。答案=总权值-最小点覆盖集=总权值-最大流。具体证明参考胡波涛的论文。 ********************************************************** 题意：在一个有n×m个方格的棋盘中,每个方格中有一个正整数。现要从方格中取数,使任意 2个数所在方格没有公共边,且取出的数的总和最大。试设计一个满足要求的取数算法。 分析：最大点权独立集。先将棋盘黑白染色，从S向每个黑点连一条容量为黑点数值的边，从白点向T连接一条容量为白点数值的边，从每个黑点向相邻白点连一条容量为INF的边。 答案为总价值-最小割,即总价值-最大流。 为什么要这样做呢？ 可以从最小割来理解，把相邻的黑白点转化为一个二分图，要使其两部分不连通，即连通边隔断，即最小割 注意：在分黑白点时可以按照坐标分，(坐标之和为奇数为黑点，否则是白点，点的下标设为(i-1)*m+j ) int a[35][35]; int dir[4][2]={0,-1,1,0,0,1,-1,0}; int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int s=0,t=n*m+1,sum=0;Dic.init(n*m+1); for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ scanf(&quot;%d&quot;,&amp;a[i][j]);sum+=a[i][j]; if((i+j)&amp;1) Dic.AddEdge(0,(i-1)*m+j,a[i][j]); else Dic.AddEdge((i-1)*m+j,t,a[i][j]); } } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ if((i+j)&amp;1){ for(int k=0;k&lt;4;k++){ int x=i+dir[k][0],y=j+dir[k][1]; if(x&lt;=n&amp;&amp;x&gt;=1&amp;&amp;y&lt;=m&amp;&amp;y&gt;=1) Dic.AddEdge((i-1)*m+j,(x-1)*m+y,INF); } } } } int ans=sum-Dic.Maxflow(s,t); printf(&quot;%d\n&quot;,ans); } 10.餐巾计划问题(最小费用最大流)(好难啊!!!)题意：一个餐厅在相继的 n 天里，每天需用的餐巾数不尽相同。假设第 i 天需要 ri ​​ 块餐巾。餐厅可以购买新的餐巾，每块餐巾的费用为 P 分； 或者把旧餐巾送到快洗部，洗一块需 M 天，其费用为 F 分；或者送到慢洗部，洗一块需 N 天，其费用为 S 分（S&lt;F）。 每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。 但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。 试设计一个算法为餐厅合理地安排好 n 天中餐巾使用计划,使总的花费最小。 分析：把每一天都拆成一对点 xi 和 yi ，xi 表示脏的餐巾，yi 表示干净的餐巾。从 S 向 yi 连一条容量为 inf 费用为 P 的边，代表购买决策； 从 yi 向 T 连一条容量为 ri 费用为 0 的边，代表每天需求；从 S 向 xi 连一条容量为 ri 费用为 0 的边，代表每天剩余的未洗餐巾； 从 xi 向 xi+1 连一条容量为 inf 费用为 0 的边，代表将脏餐巾屯到下一天；从 xi 向 yi+m 连一条容量为 inf 费用为 F 的边，代表快洗决策； 从 xi 向 yi+n 连一条容量为 inf 费用为 S 的边，代表慢洗决策。直接跑最小费用最大流即可。 #include&lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int INF=0x3f3f3f3f; const int maxn=2005; struct Edge{ int from,to,cap,flow,cost; Edge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w){} }; struct MCMF { int n,m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn]; int d[maxn]; int p[maxn]; int a[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap,int cost){ edges.emplace_back(from,to,cap,0,cost); edges.emplace_back(to,from,0,0,-cost); int m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BellmanFord(int s,int t,int &amp;flow,ll &amp;cost){ for(int i=0;i&lt;n;i++) d[i]=INF; memset(inq,0,sizeof(inq));d[s]=0;inq[s]=1;p[s]=0;a[s]=INF; queue&lt;int&gt; q;q.push(s); while(!q.empty()){ int u=q.front();q.pop();inq[u]=0; for(int i=0;i&lt;G[u].size();i++){ Edge&amp; e=edges[G[u][i]]; if(e.cap&gt;e.flow&amp;&amp;d[e.to]&gt;d[u]+e.cost){ d[e.to]=d[u]+e.cost;p[e.to]=G[u][i]; a[e.to]=min(a[u],e.cap-e.flow); if(!inq[e.to]){ q.push(e.to);inq[e.to]=1; } } } } if(d[t]==INF) return 0; flow+=a[t]; cost+=(ll)d[t]*(ll)a[t]; for(int u=t;u!=s;u=edges[p[u]].from){ edges[p[u]].flow+=a[t]; edges[p[u]^1].flow-=a[t]; } return 1; } int MincostMAXflow(int s,int t,ll &amp;cost){ int flow=0;cost=0; while(BellmanFord(s,t,flow,cost)); return flow; } }Mc; int a[1005]; int main() { int n,P,M,F,N,S;scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;P,&amp;M,&amp;F,&amp;N,&amp;S); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); int s=0,t=2*n+1;Mc.init(2*n+2); for(int i=1;i&lt;=n;i++){ Mc.AddEdge(s,i+n,INF,P);Mc.AddEdge(i+n,t,a[i],0); } for(int i=1;i&lt;n;i++){ Mc.AddEdge(s,i,a[i],0);Mc.AddEdge(i,i+1,INF,0); } for(int i=1;i&lt;=n-M;i++) Mc.AddEdge(i,i+n+M,INF,F); for(int i=1;i&lt;=n-N;i++) Mc.AddEdge(i,i+n+N,INF,S); ll cost=0; int ans=Mc.MincostMAXflow(s,t,cost); printf(&quot;%d\n&quot;,cost); } 11.航空路线问题(最小费用最大流-输出路径)题意：给定一张航空图，图中顶点代表城市，边代表两个城市间的直通航线。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线： 从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）； 除起点城市外，任何城市只能访问一次。对于给定的航空图，试设计一个算法找出一条满足要求的最佳航空旅行路线。 分析：问题转化为求两条不相交的路径且路径之和最长。考虑拆点，连一条容量为1费用为−1的边(1和n的容量为2)。跑最小费用最大流求解，若最大流不等于2则无解。 建图不难，输出方案调死我了 *.* 被傻屌网友忽悠半天，最后写了个dfs水过去了。。。 从起点开始dfs， 第一趟走到终点，第二趟从起点再次走到终点，两个路径以终点分隔，把第二条路径倒过来输出就可以了 map&lt;string,int&gt; mmp; map&lt;int,string&gt; mmp1; bool vis[maxn]; vector&lt;int&gt; ANS,ans1; void dfs(int u,int n){ if(u&lt;=n+1&amp;&amp;!vis[u]) ANS.push_back(u);vis[u]=1; for(auto &amp;v:Mc.G[u+n]){ if((Mc.edges[v].flow&gt;0)&amp;&amp;!vis[Mc.edges[v].to]) dfs(Mc.edges[v].to,n); } } int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m;cin&gt;&gt;n&gt;&gt;m;int S=1,T=2*n; string s;Mc.init(n*2); for(int i=1;i&lt;=n;i++){ cin&gt;&gt;s;mmp[s]=i;mmp1[i]=s; } for(int i=2;i&lt;n;i++) Mc.AddEdge(i,i+n,1,-1); Mc.AddEdge(1,1+n,2,-1);Mc.AddEdge(n,n*2,2,-1); for(int i=1;i&lt;=m;i++){ string a,b;cin&gt;&gt;a&gt;&gt;b; int A=mmp[a],B=mmp[b]; if(A&gt;B) swap(A,B); if(A==1&amp;&amp;B==n) Mc.AddEdge(n+1,n,2,0);//起点到终点的直达路线的费用应该为0 Mc.AddEdge(A+n,B,1,0); } ll cost=0; int ans=Mc.MincostMAXflow(S,T,cost); if(ans!=2) {cout&lt;&lt;&quot;No Solution!&quot;&lt;&lt;endl;return 0;} cout&lt;&lt;-cost-2&lt;&lt;endl;dfs(1,n); int f=0; for(int i=0;i&lt;ANS.size();i++){ if(ANS[i]==n) {f=1;cout&lt;&lt;mmp1[ANS[i]]&lt;&lt;endl;} else if(f) ans1.push_back(ANS[i]); else cout&lt;&lt;mmp1[ANS[i]]&lt;&lt;endl; } reverse(ans1.begin(),ans1.end()); for(int i=0;i&lt;ans1.size();i++) cout&lt;&lt;mmp1[ans1[i]]&lt;&lt;endl; cout&lt;&lt;mmp1[1]&lt;&lt;endl; } 12.软件补丁问题(待补-太难了!!!) 13.星际转移问题(分层图动态加边-最大流)题意：现有n个太空站位于地球与月球之间，且有m艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而每艘太空船i只可容纳Hi个人。每艘太空船将周期性地停靠一系列的太空站，例如：1,3,4 表示该太空船将周期性地停靠太空站134134134⋯ 每一艘太空船从一个太空站驶往任一太空站耗时均为1。人们只能在太空船停靠太空站（或月球、地球）时上、下船。初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。 分析：建立分层图。从S向每一天的地球连一条容量为inf的边；从每一天的月球向T连一条容量为inf的边；从每一天的节点向下一天的对应节点连一条容量为inf的边； 对于每一艘飞船，从每一天的位置向下一天的位置连一条容量为Hi的边。枚举天数建图，跑最大流直到不小于总人数即可 注意：每次枚举一个新的天数，加一层新的边。在重新跑网络流之前要记得把上次跑网络流的流量清空，因为上一次残留的流量会对重新跑的网络流造成误差。 int h[maxn],r[maxn],p[maxn][50],pos[maxn]; int main() { int n,m,k;scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);n+=2; int S=0,T=10000;Dic.init(T+2); for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;h[i],&amp;r[i]); for(int j=0;j&lt;r[i];j++){//地球-&gt;1 月球-&gt;n 太空站-&gt;2~n-1 int t;scanf(&quot;%d&quot;,&amp;t);p[i][j]=t+1; if(p[i][j]==0) p[i][j]=n;//p[i][j]记录飞船i，在循环运动到相对第j个位置 所处的绝对位置 } } Dic.AddEdge(S,1,INF);Dic.AddEdge(n,T,INF);//建源点和汇点 int ans=0; while(ans&lt;100){ ans++; Dic.AddEdge(S,ans*n+1,INF);Dic.AddEdge(ans*n+n,T,INF);//地球连源点、月球连汇点 for(int i=1;i&lt;=m;i++){ int u=p[i][pos[i]];pos[i]=(pos[i]+1)%r[i];//pos记录飞船i在其循环运动中的第几个位置 int v=p[i][pos[i]];Dic.AddEdge(n*ans+u-n,n*ans+v,h[i]);//飞船在星球间运动 } for(int i=2;i&lt;n;i++) Dic.AddEdge(ans*n-n+i,ans*n+i,INF);//对每个星球，前一天的星球应该向下一天连一条边 for(auto &amp;v:Dic.edges) v.flow=0;//清空残余流量 int FLOW=Dic.Maxflow(S,T); if(FLOW&gt;=k) {printf(&quot;%d\n&quot;,ans);return 0;} } printf(&quot;0\n&quot;);return 0;//无解输出0 } 13.负载平衡(费用流，循环建图-双向边)题意：公司有 n 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 n 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。 分析：由于总量是固定的，我们可以得出每个仓库的最终储货量，令 ai 表示原有储货量-最终储货量。对于每一个仓库，拆成两个点 xi 和 yi ，一个代表供应，一个代表需求。 若 ai&gt;0 ，从 S 向 xi 连一条容量为 ai 费用为 0 的边；若 ai&lt;0 ，从 yi 向 T 连一条容量为 −ai 费用为 0 的边； 对于两个相邻的顶点 j ，从 xi 分别向 xj 和 yj 连一条容量为 inf 费用为 1 的边。跑最小费用最大流即可。 注意：由于相邻的可以相互运输，于是仓库之间需要建双向边，如：1右→2左 且 1左←2右，注意费用是单位长度的费用！！！ int a[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m;cin&gt;&gt;n;int S=0,T=2*n+1;Mc.init(2*n+2); int sum=0; for(int i=1;i&lt;=n;i++) {cin&gt;&gt;a[i];sum+=a[i];} sum/=n; for(int i=1;i&lt;=n;i++){ Mc.AddEdge(S,i,a[i],0);Mc.AddEdge(i+n,T,sum,0); Mc.AddEdge(i,i+n,INF,0); } for(int i=2;i&lt;=n;i++) Mc.AddEdge(i-1+n,i,INF,1);Mc.AddEdge(n+n,1,INF,1);//1右→2左 for(int i=1;i&lt;n;i++) Mc.AddEdge(i+1+n,i,INF,1);Mc.AddEdge(n+1,n,INF,1);//1左←2右 ll cost=0;Mc.MincostMAXflow(S,T,cost); cout&lt;&lt;cost&lt;&lt;endl; } 14.深海机器人问题() POJ-2125 最小割输出方案题意：最小割问题不是很复杂，主要是第一次做最小割输出方案 思路：对于输出方案，跑完最大流之后，图会被分为两个点集，一个连源点一个连汇点 从起点开始做一遍dfs，向下扩展的条件是边的容量大于它的流量(有残余流量) 和源点相连的 -能被访问- 到的点是左边的最小割，和汇点相连的 -不能被访问- 到的点是右边的最小割 为什么呢？因为割边都是满流边。 与源点相连的点,如果不能被访问到说明连边达到满流，显然是割边。 与汇点相连的点，我也不知道为啥，那就记住吧，能被访问到的就是割边 这是网友的解释：https://www.bbsmax.com/A/A2dmnO27ze/ bool vis[maxn]; vector&lt;int&gt; ANS; void dfs(int u){ vis[u]=1; for(int i=0;i&lt;Dic.G[u].size();i++){ int v=Dic.G[u][i]; if(Dic.edges[v].cap&gt;Dic.edges[v].flow&amp;&amp;!vis[Dic.edges[v].to]) dfs(Dic.edges[v].to); } } void solve(int S,int T){ int ans=Dic.Maxflow(S,T); cout&lt;&lt;ans&lt;&lt;endl; dfs(S); for(int i=1;i&lt;=2*n;i++){ if(i&gt;n){if(vis[i]) ANS.push_back(i);} else{if(!vis[i]) ANS.push_back(i);} } cout&lt;&lt;ANS.size()&lt;&lt;endl; for(int i=0;i&lt;ANS.size();i++){ if(ANS[i]&gt;n) cout&lt;&lt;ANS[i]-n&lt;&lt;&quot; +&quot;&lt;&lt;endl; else cout&lt;&lt;ANS[i]&lt;&lt;&quot; -&quot;&lt;&lt;endl; } } int main() { fastinout;cin&gt;&gt;n&gt;&gt;m; int S=0,T=2*n+1;Dic.init(2*n+2); for(int i=1;i&lt;=n;i++) {cin&gt;&gt;t;Dic.AddEdge(i+n,T,t);} for(int i=1;i&lt;=n;i++) {cin&gt;&gt;t;Dic.AddEdge(S,i,t);} for(int i=0;i&lt;m;i++){ int u,v;cin&gt;&gt;u&gt;&gt;v; Dic.AddEdge(u,v+n,inf); } solve(S,T); }]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流-有上下界限制]]></title>
    <url>%2F2019%2F12%2F25%2F%E7%BD%91%E7%BB%9C%E6%B5%81-%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[有上下界限制的网络流问题参考博客：https://www.cnblogs.com/liu-runda/p/6262832.html(有代码) https://www.cnblogs.com/mjtcn/p/8469349.html(有公式说明) https://blog.csdn.net/corsica6/article/details/81488993(思路清晰) https://www.cnblogs.com/mlystdcall/p/6734852.html(荐) 给定一个网络，一个加权的有向图G，其中的每条边都有一个容量上界C。 其中的两点：S只有出度没有入度，T只有入度没有出度。求S到T最大可以流过的流量，这是最大流的模型。 且满足以下条件： 容量限制：每条边的流量0≤f≤C 流量平衡：任意一个点i，∑f(u,i)=∑f(i,v) (u,i)∈E 那么f是G的一个可行流。最大流即满足容量限制和流量平衡的最大的流。 如果在网络中，每条边增加一个流量下界B，这就是有 &quot;上下界限制的网络流&quot; 的模型了。 那么有上下界限制的网络流也是满足两个条件： 容量限制：每条边的流量B≤f≤C 流量平衡：任意一个点i，∑f(u,i)=∑f(i,v) (u,i)∈E 有上下界限制的网络流一般分为四类： 无源汇有上下界可行流 有源汇有上下界可行流 有源汇有上下界最大流 有源汇有上下界最小流 预备知识： B(u,v): u-&gt;v的流量下界 C(u,v): u-&gt;v的流量上界 f(u,v): u-&gt;v的流量 无源汇上下界可行流顾名思义，无源汇上下界可行流：没有源点S，汇点T。在网络中求可行流或者指出不存在。 对于这个问题，不好处理，但是如果我们去掉流量下界限制B，那么就是最大流的模型了，问题就可以解决了。 建图方法： 首先建一个源ss和一个汇tt，一般称为附加源和附加汇 对于图中的每条弧&lt;u,v&gt;假设它的容量下界为b，上界为c，那么把这条边拆为三条只有上界的弧。 一条为&lt;ss,v&gt;，容量为b； 一条为&lt;u,tt&gt;，容量为b； 一条为&lt;u,v&gt;，容量为c−b。 其中前两条弧一般称为附加弧。 然后对这张图跑最大流，以ss为源，以tt为汇，如果所有的附加弧都满流，则原图有可行流。 这时，每条非附加弧的流量加上它的容量下界，就是原图中这条弧应该有的流量。 理解方法： 对于原图中的每条弧，我们把c−b称为它的自由流量，意思就是只要它流满了下界，这些流多少都没问题。 既然如此，对于每条弧&lt;u,v&gt;，我们强制给v提供b单位的流量，并且强制从u那里拿走b单位的流量，这一步对应着两条附加弧。 如果这一系列强制操作能完成的话，也就是有一组可行流了。 注意：这张图的最大流只是对应着原图的一组可行流，而不是原图的最大或最小流。 板子题：https://loj.ac/problem/115 这里放一个Dinic的板子，后面的代码只放主函数 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e4+5;//数组开大点 const int INF=0x3f3f3f3f; struct Edge{ int from,to,cap,flow; Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){} }; struct Dinic{ int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn],cur[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap){ edges.emplace_back(from,to,cap,0); edges.emplace_back(to,from,0,0); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BFS(){ memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); queue&lt;int&gt; q;q.push(s); d[s]=0;vis[s]=1; while(!q.empty()){ int x=q.front();q.pop(); for(int i=0;i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){ vis[e.to]=1;d[e.to]=d[x]+1;q.push(e.to); } } } return vis[t]; } int DFS(int x,int a){ if(x==t||a==0) return a; int flow=0,f; for(int&amp; i=cur[x];i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(d[x]+1==d[e.to]&amp;&amp;(f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){ e.flow+=f;edges[G[x][i]^1].flow-=f; flow+=f;a-=f;if(a==0) break; } } return flow; } int Maxflow(int s,int t){ this-&gt;s=s;this-&gt;t=t; int flow=0; while(BFS()){ memset(cur,0,sizeof(cur)); flow+=DFS(s,INF); } return flow; } }Dic; int d[maxn],low[maxn];//d[i]-&gt; 附加流中i节点出去的流量 //d[i]&gt;0时需要在附加流中设置从i流出T流量为d[i]的边 //d[i]&lt;=0时需要需要在附加流中设置从S流入i流量为-d[i]的边 int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n,m;cin&gt;&gt;n&gt;&gt;m;int S=0,T=n+1,sum=0; Dic.init(n+2);memset(d,0,sizeof(d)); for(int i=0;i&lt;m;i++){ int a,b,up,down;cin&gt;&gt;a&gt;&gt;b&gt;&gt;down&gt;&gt;up; Dic.AddEdge(a,b,up-down); d[a]+=down;d[b]-=down;low[i]=down; } for(int i=1;i&lt;=n;i++){ if(d[i]&gt;0) {Dic.AddEdge(i,T,d[i]);sum+=d[i];} Dic.AddEdge(S,i,-d[i]); } int ans=Dic.Maxflow(S,T); if(ans!=sum) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; else{ cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; for(int i=0;i&lt;m;i++){//输出原弧中的流量，需要加上之前删掉的下界流量 cout&lt;&lt;Dic.edges[i*2].flow+low[i]&lt;&lt;endl; } } } 有源汇上下界可行流建模方法： 建立弧&lt;t,s&gt;，容量下界为0，上界为∞。 然后对这个新图（实际上只是比原图多了一条边）按照无源汇可行流的方法建模，如果所有附加弧满流，则存在可行流。 求原图中每条边对应的实际流量的方法，同无源汇可行流，只是忽略掉弧&lt;t,s&gt;就好。 而且这时候弧&lt;t,s&gt;的流量就是原图的总流量。 理解方法： 有源汇相比无源汇的不同就在于，源和汇是不满足流量平衡的，那么连接&lt;t,s&gt;之后，源和汇也满足了流量平衡，就可以直接按照无源汇的方式建模。 注意：这张图的最大流只是对应着原图的一组可行流，而不是原图的最大或最小流。 有源汇上下界最大流建模方法： 首先按照有源汇可行流的方法建模，如果不存在可行流，更别提什么最大流了。 如果存在可行流，那么在运行过有源汇可行流的图上（就是已经存在流量的那张图，流量不要清零）， 跑一遍从s到t的最大流（这里的s和t是原图的源和汇，不是附加源和附加汇），就是原图的最大流。 理解方法： 为什么要在那个已经有了流量的图上跑最大流？因为那张图保证了每条弧的容量下界， 在这张图上跑最大流，实际上就是在容量下界全部满足的前提下尽量多得获得“自由流量”。 注意，在这张已经存在流量的图上，弧&lt;t,s&gt;也是存在流量的，千万不要忽略这条弧。 因为它的相反弧&lt;s,t&gt;的流量为&lt;t,s&gt;的流量的相反数，且&lt;s,t&gt;的容量为0，所以这部分的流量也是会被算上的。 //https://loj.ac/problem/116 int d[maxn],low[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n,m,s,t;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; int sum=0,S=0,T=n+1; Dic.init(n+2);memset(d,0,sizeof(d)); for(int i=0;i&lt;m;i++){ int a,b,up,down;cin&gt;&gt;a&gt;&gt;b&gt;&gt;down&gt;&gt;up; Dic.AddEdge(a,b,up-down); d[a]+=down;d[b]-=down;low[i]=down; } for(int i=1;i&lt;=n;i++){ if(d[i]&gt;0) {Dic.AddEdge(i,T,d[i]);sum+=d[i];} Dic.AddEdge(S,i,-d[i]); } Dic.AddEdge(t,s,INF); int ans=Dic.Maxflow(S,T); if(ans!=sum) cout&lt;&lt;&quot;please go home to sleep&quot;&lt;&lt;endl; else{ S=s;T=t;int len=Dic.edges.size()-2;//将S,T删去恢复源汇 ans=Dic.edges[len].flow;//跑完有源汇可行流之后，弧&lt;t,s&gt;的流量就是原图的流量。 Dic.edges[len].flow=Dic.edges[len].cap=0;//清空原来的附加源汇点之间的流量和容量 Dic.edges[len^1].flow=Dic.edges[len^1].cap=0; ans+=Dic.Maxflow(S,T); cout&lt;&lt;ans&lt;&lt;endl; } } 有源汇上下界最小流有源汇最小流的常见建模方法比较多，以下是网友的两种方法。 NO.1 建模方法： 首先按照有源汇可行流的方法建模，但是不要建立&lt;t,s&gt;这条弧。 然后在这个图上，跑从附加源ss到附加汇tt的最大流。 这时候再添加弧&lt;t,s&gt;，下界为0，上界为∞。 在现在的这张图上，从ss到tt的最大流，就是原图的最小流。 理解方法： 我们前面提到过，有源汇可行流的流量只是对应一组可行流，并不是最大或者最小流。 并且在跑完有源汇可行流之后，弧&lt;t,s&gt;的流量就是原图的流量。 从这个角度入手，我们想让弧&lt;t,s&gt;的流量尽量小，就要尽量多的消耗掉那些“本来不需要经过&lt;t,s&gt;”的流量。 于是我们在添加&lt;t,s&gt;之前，跑一遍从ss到tt的最大流，就能尽量多的消耗那些流量啦QwQ。 NO.2 我们再理解一下dinic的反向边.反向边的流量增加等价于正向边的的流量减少. 因此我们在残量网络上找出t到s的流就相当于减小了s到t的流,因此我们在跑出可行流的残量网络上跑t-s最大流, 用可行流的大小减去这一次t-s最大流的大小就是最小流的大小.(t-s最大流其实是尽量缩减s-t方向的流). 问题:会不会使流量缩减到不满足流量下限? 不会.和有源汇有上下限的最大流一样,我们之前从每条边上拿出了大小等于流量下限的流量构成初始流,这些流量不在我们建出的图中. 最极端的情况是缩减到所有边的流量等于流量下限,不会更小了. int d[maxn],low[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n,m,s,t;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; int sum=0,S=0,T=n+1; Dic.init(n+2);memset(d,0,sizeof(d)); for(int i=0;i&lt;m;i++){ int a,b,up,down;cin&gt;&gt;a&gt;&gt;b&gt;&gt;down&gt;&gt;up; Dic.AddEdge(a,b,up-down); d[a]+=down;d[b]-=down;low[i]=down; } for(int i=1;i&lt;=n;i++){ if(d[i]&gt;0) {Dic.AddEdge(i,T,d[i]);sum+=d[i];} Dic.AddEdge(S,i,-d[i]); } Dic.AddEdge(t,s,INF); int ans=Dic.Maxflow(S,T); if(ans!=sum) cout&lt;&lt;&quot;please go home to sleep&quot;&lt;&lt;endl; else{ S=t;T=s;int len=Dic.edges.size()-2;//跑反向边最大流 ans=Dic.edges[len].flow; Dic.edges[len].flow=Dic.edges[len].cap=0; Dic.edges[len^1].flow=Dic.edges[len^1].cap=0; ans-=Dic.Maxflow(S,T);//减一减 cout&lt;&lt;ans&lt;&lt;endl; } }]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F12%2F25%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线段树NB网友Blog(https://blog.csdn.net/huangzihaoal/article/details/81813454) 线段树，是一种二叉搜索树。它将一段区间划分为若干单位区间，每一个节点都储存着一个区间。 它功能强大，支持区间求和，区间最大值，区间修改，单点修改等操作。 线段树的每一个节点都储存着一段区间[L…R]的信息，其中叶子节点L=R。 它的大致思想是：将一段大区间平均地划分成2个小区间，每一个小区间都再平均分成2个更小区间……以此类推， 直到每一个区间的L等于R（这样这个区间仅包含一个节点的信息，无法被划分）。通过对这些区间进行修改、查询，来实现对大区间的修改、查询。 这样一来，每一次修改、查询的时间复杂度都只为O(logn) 但是，可以用线段树维护的问题必须满足区间加法，否则是不可能将大问题划分成子问题来解决的。 初阶线段树单点修改区间查询区间求和//HDU 1166 单点更新区间求和 #include&lt;bits/stdc++.h&gt; using namespace std; #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 const int maxn=1e5+5; int sum[maxn&lt;&lt;2],a[maxn],n; void pushup(int rt) {sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];} void build(int l,int r,int rt){ if(l==r) {sum[rt]=a[l];return;} int m=(l+r)&gt;&gt;1;build(lson);build(rson);pushup(rt); } void update(int p,int t,int l,int r,int rt){ if(l==r) {sum[rt]+=t;return;} int m=(l+r)&gt;&gt;1; if(p&lt;=m) update(p,t,lson); else update(p,t,rson); pushup(rt); } int query(int L,int R,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r) return sum[rt]; int m=(l+r)&gt;&gt;1,ans=0; if(L&lt;=m) ans+=query(L,R,lson); if(R&gt;m) ans+=query(L,R,rson); return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); int t;cin&gt;&gt;t;int ca=1; while(t--){ cin&gt;&gt;n;for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; cout&lt;&lt;&quot;Case &quot;&lt;&lt;ca++&lt;&lt;&quot;:&quot;&lt;&lt;endl;build(1,n,1);string s; while(cin&gt;&gt;s){ if(s[0]==&apos;E&apos;) break;int x,y;cin&gt;&gt;x&gt;&gt;y; if(s[0]==&apos;Q&apos;) cout&lt;&lt;query(x,y,1,n,1)&lt;&lt;endl; else if(s[0]==&apos;A&apos;) update(x,y,1,n,1); else update(x,-y,1,n,1); } } } 区间最值//HDU-1754 单点更新区间最值 #include&lt;bits/stdc++.h&gt; using namespace std; #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 const int maxn=2e5+5; int ans[maxn&lt;&lt;2],a[maxn],n,m; void pushup(int rt) {ans[rt]=max(ans[rt&lt;&lt;1],ans[rt&lt;&lt;1|1]);} void build(int l,int r,int rt){ if(l==r) {ans[rt]=a[l];return;} int m=(l+r)&gt;&gt;1;build(lson);build(rson);pushup(rt); } void update(int p,int t,int l,int r,int rt){ if(l==r){ans[rt]=t;return;} int m=(l+r)&gt;&gt;1; if(p&lt;=m) update(p,t,lson); else update(p,t,rson); pushup(rt); } int query(int L,int R,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r) return ans[rt]; int m=(l+r)&gt;&gt;1,ret=0; if(L&lt;=m) ret=max(ret,query(L,R,lson)); if(R&gt;m) ret=max(ret,query(L,R,rson)); return ret; } int main() { ios::sync_with_stdio(0);cin.tie(0); while(cin&gt;&gt;n&gt;&gt;m){ for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; build(1,n,1);char c;int x,y; while(cin&gt;&gt;c&gt;&gt;x&gt;&gt;y){ if(c==&apos;U&apos;) update(x,y,1,n,1); else cout&lt;&lt;query(x,y,1,n,1)&lt;&lt;endl; } } } 区间修改区间查询需要lazy标记 区间替换//HDU-1698 区间替换 #include&lt;bits/stdc++.h&gt; using namespace std; #define lson l,m+1,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 const int maxn=1e5+5; int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],a[maxn],n; void pushup(int rt){ sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1]; } void pushdown(int rt,int m){ if(lazy[rt]){ lazy[rt&lt;&lt;1]=lazy[rt&lt;&lt;1|1]=lazy[rt]; sum[rt&lt;&lt;1]=(m-(m&gt;&gt;1))*lazy[rt]; sum[rt&lt;&lt;1|1]=(m&gt;&gt;1)*lazy[rt]; lazy[rt]=0; } } void build(int l,int r,int rt){ lazy[rt]=0; if(l==r) {sum[rt]=a[l];return;} int m=(l+r)&gt;&gt;1; build(lson);build(rson);pushup(rt); } void update(int L,int R,int c,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r){ lazy[rt]=c;sum[rt]=(r-l+1)*c;return; } pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; if(L&lt;=m) update(L,R,c,lson); if(R&gt;m) update(L,R,c,rson); pushup(rt); } int query(int L,int R,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r) return sum[rt]; pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; int ans=0; if(L&lt;=m) ans+=query(L,R,lson); if(R&gt;m) ans+=query(L,R,rson); cout&lt;&lt;ans&lt;&lt;endl; } int main() { ios::sync_with_stdio(0);cin.tie(0); int t,n,m,ca=1;cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; build(1,n,1); while(m--){ int x,y,z;cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; update(x,y,z,1,n,1); } cout&lt;&lt;&quot;Case &quot;&lt;&lt;ca++&lt;&lt;&quot;: The total value of the hook is &quot;&lt;&lt;sum[1]&lt;&lt;&quot;.&quot;&lt;&lt;endl; } } 区间增减//POJ-3468 区间增减 #include&lt;iostream&gt; typedef long long ll; using namespace std; #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 const int maxn=1e5+5; ll sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],a[maxn]; int n,m; void pushup(int rt){ sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1]; } void build(int l,int r,int rt){ lazy[rt]=0; if(l==r) {sum[rt]=a[l];return;} int m=(l+r)&gt;&gt;1; build(lson);build(rson);pushup(rt); } void pushdown(int rt,int m){ if(lazy[rt]){ lazy[rt&lt;&lt;1]+=lazy[rt]; lazy[rt&lt;&lt;1|1]+=lazy[rt]; sum[rt&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[rt]; sum[rt&lt;&lt;1|1]+=((m&gt;&gt;1))*lazy[rt]; lazy[rt]=0; } } void update(int L,int R,int c,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r){sum[rt]+=(r-l+1)*c;lazy[rt]+=c;return;} pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; if(L&lt;=m) update(L,R,c,lson); if(R&gt;m) update(L,R,c,rson); pushup(rt); } ll query(int L,int R,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r) return sum[rt]; pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; ll ans=0; if(L&lt;=m) ans+=(ll)query(L,R,lson); if(R&gt;m) ans+=(ll)query(L,R,rson); return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); while(cin&gt;&gt;n&gt;&gt;m){ for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; build(1,n,1); char c;int x,y,z; while(m--){ cin&gt;&gt;c&gt;&gt;x&gt;&gt;y; if(c==&apos;Q&apos;) cout&lt;&lt;query(x,y,1,n,1)&lt;&lt;endl; else {cin&gt;&gt;z;update(x,y,z,1,n,1);} } } } 中阶线段树乘法线段树//https://www.luogu.org/problem/P3373 题意：三种操作：将某区间每一个数乘上x、将某区间每一个数加上x、求出某区间每一个数的和 思路：注意加法和乘法的优先级，维护两种lazy标记。 输入： 输出： 5 5 38 17 1 5 4 2 3 2 2 1 4 1 3 2 5 1 2 4 2 2 3 5 5 3 1 4 #include&lt;bits/stdc++.h&gt; #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 using namespace std; const int maxn=1e5+5; typedef long long ll; ll sum[maxn&lt;&lt;2],mlz[maxn&lt;&lt;2],plz[maxn&lt;&lt;2]; ll n,m,p; inline void pushup(int rt){sum[rt]=(sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1])%p;} inline void Build(int l,int r,int rt){ mlz[rt]=1;plz[rt]=0; if(l==r){ll t;cin&gt;&gt;t;sum[rt]=t%p;return;} int m=(l+r)&gt;&gt;1;Build(lson);Build(rson);pushup(rt); } inline void pushdown(int rt,int m){ ll k1=mlz[rt],k2=plz[rt]; sum[rt&lt;&lt;1]=(sum[rt&lt;&lt;1]*k1+(m-(m&gt;&gt;1))*k2)%p;//左边和乘以乘法lazy+元素总数*加法lazy sum[rt&lt;&lt;1|1]=(sum[rt&lt;&lt;1|1]*k1+((m&gt;&gt;1))*k2)%p;//右边和乘以乘法lazy+元素总数*加法lazy mlz[rt&lt;&lt;1]=(mlz[rt&lt;&lt;1]*k1)%p;//乘法标记向左下推 mlz[rt&lt;&lt;1|1]=(mlz[rt&lt;&lt;1|1]*k1)%p;//乘法标记向右下推 plz[rt&lt;&lt;1]=(plz[rt&lt;&lt;1]*k1+k2)%p;//左下加法lazy*父节点的乘法lazy+左下乘法lazy plz[rt&lt;&lt;1|1]=(plz[rt&lt;&lt;1|1]*k1+k2)%p;//右下加法lazy*父节点的乘法lazy+左下乘法lazy mlz[rt]=1;plz[rt]=0;//lazy标记置位 } inline void add(int L,int R,int x,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r){ sum[rt]+=(r-l+1)*x%p; plz[rt]=(plz[rt]+x)%p;//修改加法lazy return; } pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; if(L&lt;=m) add(L,R,x,lson); if(R&gt;m) add(L,R,x,rson); pushup(rt); } inline void mul(int L,int R,int x,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r){ sum[rt]=sum[rt]*x%p; mlz[rt]=(mlz[rt]*x)%p;//乘以一个数后，加法的lazy标记应该也被乘以这个数 plz[rt]=(plz[rt]*x)%p;//修改乘法lazy return; } pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; if(L&lt;=m) mul(L,R,x,lson); if(R&gt;m) mul(L,R,x,rson); pushup(rt); } inline ll query(int L,int R,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r) {return sum[rt];} pushdown(rt,r-l+1);//查询记得将lazy下推 int m=(l+r)&gt;&gt;1; ll ans=0; if(L&lt;=m) ans+=query(L,R,lson); if(R&gt;m) ans+=query(L,R,rson); return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;Build(1,n,1); for(int i=0;i&lt;m;i++){ int f,a,b,c;cin&gt;&gt;f; if(f==1){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;c%=p;mul(a,b,c,1,n,1); } else if(f==2){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;c%=p;add(a,b,c,1,n,1); } else{ cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;query(a,b,1,n,1)%p&lt;&lt;endl; } } } 根号线段树//HDU-4027 根号线段树 题意：两种操作：将某区间每一个数取根号、求出某区间每一个数的和 思路：注意优化，如果区间和位区间长度，则无需取根号，1e18的数取根号6~7次变为1 输入： 输出： 10 Case #1: 1 2 3 4 5 6 7 8 9 10 19 5 7 0 1 10 6 1 1 10 1 1 5 0 5 8 1 4 8 #include&lt;bits/stdc++.h&gt; using namespace std; #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 const int maxn=1e5+5; typedef long long ll; ll sum[maxn&lt;&lt;2]; void PushUP(int rt){sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];} void build(int l,int r,int rt){ if(l==r){scanf(&quot;%lld&quot;,&amp;sum[rt]);return;} int m=(l+r)&gt;&gt;1;build(lson);build(rson);PushUP(rt); } void Sqrt(int L,int R,int l,int r,int rt) { if(l==r){sum[rt]=sqrt(sum[rt]);return;} if(L&lt;=l&amp;&amp;R&gt;=r&amp;&amp;sum[rt]==r-l+1) return;//如果区间内的所有数都是1则不必更新 int m=(l+r)&gt;&gt;1; if(L&lt;=m) Sqrt(L,R,lson); if(m&lt;R) Sqrt(L,R,rson); PushUP(rt); } ll query(int L,int R,int l,int r,int rt) { if(L&lt;=l&amp;&amp;r&lt;=R) return sum[rt]; int m=(l+r)&gt;&gt;1; ll ans=0; if(L&lt;=m) ans+=query(L,R,lson); if(R&gt;m) ans+=query(L,R,rson); return ans; } int main() { int n,m,t=0; while(scanf(&quot;%d&quot;,&amp;n)==1) { int a,b,c; build(1,n,1); scanf(&quot;%d&quot;,&amp;m); printf(&quot;Case #%d:\n&quot;,++t); while(m--) { scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); if(b&gt;c) swap(b,c); if(a) printf(&quot;%lld\n&quot;,query(b,c,1,n,1)); else Sqrt(b,c,1,n,1); } printf(&quot;\n&quot;); } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2019%2F12%2F25%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一维树状数组 &amp; 二维树状数组 &amp; 三维树状数组* 树状数组 - 动态维护前缀和O(logn)或前缀最值 查询O(logn),常数小于线段树 * 利用二进制数的性质，关键在: lowbit(int x){return x&amp;(-x)}; * 解决二维偏序问题(如逆序对) 一维树状数组单点更新区间查询#include&lt;bits/stdc++.h&gt; using namespace std; int n,m; int a[50005],c[50005]; //对应原数组和树状数组 int lowbit(int x){return x&amp;(-x);}//求最低位的1 void update(int i,int k){//在i位置加上k while(i&lt;=n){c[i]+=k;i+=lowbit(i);} } int query(int i){//求A[1 - i]的和 int res=0; while(i&gt;0){res+=c[i];i-=lowbit(i);} return res; } int main() { int x,y,val;cin&gt;&gt;x&gt;&gt;y&gt;&gt;val; update(x,val);//x位置加上val update(x,-val);//x位置减去val cout&lt;&lt;query(x)&lt;&lt;endl;//求a[1~x]的元素之和 cout&lt;&lt;query(y)-query(x-1)&lt;&lt;endl;//求a[x~y]的元素之和 } 区间更新区间查询#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=5e5+5; int n,m; int a[maxn]; int sum1[maxn];//(D[1] + D[2] + ... + D[n]) int sum2[maxn];//(1*D[1] + 2*D[2] + ... + n*D[n]) int lowbit(int x){return x&amp;(-x);} void updata(int i,int k){ int x=i; //因为x不变，所以得先保存i值 while(i&lt;=n){ sum1[i]+=k; sum2[i]+=k*(x-1); i+=lowbit(i); } } int query(int i){//求前缀和 int res=0,x=i; while(i&gt;0){ res+=x*sum1[i]-sum2[i]; i-=lowbit(i); } return res; } int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i];updata(i,a[i]-a[i-1]); //输入初值的时候，也相当于更新了值 } int x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k; //[x,y]区间内加上k updata(x,k);//A[x] - A[x-1]增加k updata(y+1,-k);//A[y+1] - A[y]减少k //求[x,y]区间和 int sum=query(y)-query(x-1); //求点[y]的和 int point=query(y)-query(y-1); return 0; } 例题 Star POJ-2352题意：按照y升序给你n个星星的坐标，如果有m个星星的x,y坐标均小于等于星星A的坐标，那么星星A的等级为m。 输出每颗星星的等级。 由于y坐标是升序的且坐标不重复，所以在星星A后面输入的星星的x,y坐标不可能都小于等于星星A。 假如当前输入的星星为（3,3），易得我们只需要去找 树状数组中小于等于3的值就可以了，即GetSum(3)。 注意：A[i]表示x坐标为i的个数，C[]为A[]的树状数组，那么GetSum(i)就是 序列中前i个元素的和，即x小于等于i的星星数。 本题还是一点要注意：星星坐标的输入可以是（0,0），所以我们把x坐标统一加1，然后用树状数组实现。 #include&lt;iostream&gt; using namespace std; typedef long long ll; const int maxn=1e5+5; int maxm=0; int n,c[maxn],ans[maxn],x[maxn]; int lowbit(int x){return x&amp;(-x);} void update(int i,int val){ while(i&lt;=maxm){c[i]+=val;i+=lowbit(i);} } int query(int i){ int ans=0; while(i&gt;0){ans+=c[i];i-=lowbit(i);} return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin&gt;&gt;n;int t; for(int i=0;i&lt;n;i++) {cin&gt;&gt;x[i]&gt;&gt;t;x[i]++;maxm=max(maxm,x[i]);} for(int i=0;i&lt;n;i++){ ans[query(x[i])]++; update(x[i],1); } for(int i=0;i&lt;n;i++) cout&lt;&lt;ans[i]&lt;&lt;endl; } 二维树状数组Blog：https://www.cnblogs.com/RabbitHu/p/BIT.html 问题：一个由数字构成的大矩阵，能进行两种操作 1) 对矩阵里的某个数加上一个整数（可正可负） 2) 查询某个子矩阵里所有数字的和,要求对每次查询，输出结果。 一维树状数组很容易扩展到二维，在二维情况下:数组A[][]的树状数组定义为： C[x][y] = ∑ a[i][j], 其中， x-lowbit(x) + 1 &lt;= i &lt;= x, y-lowbit(y) + 1 &lt;= j &lt;= y. 单点更新区间查询#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=500; int tree[maxn][maxn];//行列分开看，每一行每一列都是一个一位树状数组 int n,m;//n行m列 int lowbit(int x){return x&amp;(-x);} void update(int x,int y,int val){//单点更新 for(int i=x;i&lt;=n;i+=lowbit(i)) for(int j=y;j&lt;=m;j+=lowbit(j))//列的一维树状数组 tree[i][j]+=val; } int sum(int x,int y){//返回(0,0)(x,y)为对角顶点的矩阵和 int res=0; for(int i=x;i&gt;0;i-=lowbit(i)) for(int j=y;j&gt;0;j-=lowbit(j)) res+=tree[i][j]; return res; } int query(int x1,int y1,int x2,int y2){//区间查询 return sum(x2,y2)+sum(x1-1,y1-1)-sum(x2,y1-1)-sum(x1,y2);//注意精度为int or longlong } 区间更新单点查询//区间修改,单点查询,和一维树状数组差分思想一样,差分思想。 //二维前缀和： //sum[i][j]=sum[i−1][j]+sum[i][j−1]−sum[i−1][j−1]+a[i][j] //那么我们可以令差分数组d[i][j] 表示 a[i][j] 与 a[i−1][j]+a[i][j−1]−a[i−1][j−1] 的差。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=500; int tree[maxn][maxn];//行列分开看，每一行每一列都是一个一位树状数组 int n,m;//n行m列 int lowbit(int x){return x&amp;(-x);} void update(int x,int y,int val){//单点更新 for(int i=x;i&lt;=n;i+=lowbit(i)) for(int j=y;j&lt;=m;j+=lowbit(j))//列的一维树状数组 tree[i][j]+=val; } int query(int x,int y){//返回(0,0)(x,y)为对角顶点的矩阵和 int res=0; for(int i=x;i&gt;0;i-=lowbit(i)) for(int j=y;j&gt;0;j-=lowbit(j)) res+=tree[i][j]; return res; } void regionupdate(int x1,int y1,int x2,int y2,int val){ update(x1,y1,val); update(x2+1,y1,-val); update(x1,y2+1,-val); update(x2+1,y2+1,val); } int pointQuery(int x,int y){ return query(x,y); } 区间更新区间查询#include&lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int maxn=500; ll n,m,Q; ll tree[maxn][maxn][4]; inline ll lowbit(ll x){return x&amp;(-x);} void update(ll x,ll y,ll val){ for(int i=x;i&lt;=n;i+=lowbit(i)) for(int j=y;j&lt;=m;j+=lowbit(j)){ tree[i][j][0]+=val; tree[i][j][1]+=val*x; tree[i][j][2]+=val*y; tree[i][j][3]+=val*x*y; } } void range_update(ll xa,ll ya,ll xb,ll yb,ll val){//(xa,ya)到(xb,yb)的矩形 update(xa,ya,val); update(xa,yb+1,-val); update(xb+1,ya,-val); update(xa+1,ya+1,val); } ll query(ll x,ll y){ ll ans=0; for(int i=x;i&gt;0;i+=lowbit(i)) for(int j=y;j&gt;0;j+=lowbit(j)){ ans+=(x+1)*(y+1)*tree[i][j][0] -(y+1)*tree[i][j][1] -(x+1)*tree[i][j][2] +tree[i][j][3]; } return ans; } ll range_query(ll xa,ll ya,ll xb,ll yb){ return query(xb,yb)-query(xb,ya-1)-query(xa-1,yb)+query(xa-1,ya-1); } 例题 Matrix POJ-2155题意：一个01矩阵 可以区间翻转 单点查询 思路：二维树状数组，区间更新单点查询 #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int maxn=1005; int tree[maxn][maxn]; int n,m; int lowbit(int x){return x&amp;(-x);} void update(int x,int y,int val){ for(int i=x;i&lt;=n;i+=lowbit(i)) for(int j=y;j&lt;=m;j+=lowbit(j)) tree[i][j]+=val; } int query(int x,int y){ int res=0; for(int i=x;i&gt;0;i-=lowbit(i)) for(int j=y;j&gt;0;j-=lowbit(j)) res+=tree[i][j]; return res; } void regionupdate(int x1,int y1,int x2,int y2,int val){ update(x1,y1,val); update(x2+1,y1,-val); update(x1,y2+1,-val); update(x2+1,y2+1,val); } int pointQuery(int x,int y){ return query(x,y); } int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int T;cin&gt;&gt;T; while(T--){ memset(tree,0,sizeof(tree)); int q;cin&gt;&gt;n&gt;&gt;q;m=n; while(q--){ char ch;cin&gt;&gt;ch; if(ch==&apos;C&apos;){ int x1,x2,y1,y2;cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; regionupdate(x1,y1,x2,y2,1); } else{ int x,y;cin&gt;&gt;x&gt;&gt;y;cout&lt;&lt;pointQuery(x,y)%2&lt;&lt;endl; } } if(T&gt;0) cout&lt;&lt;endl; } } 三维树状数组三维空间内维护最值等相关信息 2019牛客多校(八) D-Distance//https://ac.nowcoder.com/acm/contest/888/D 题意：三维空间内长宽高(n,m,h)，q次操作(两种)，可以给一个点打标记也可以查询离一个点最近的打标记的点，计算曼哈顿距离。 思路：(定期重构或三维树状数组) 树状数组中维护前缀最大值，一个点的坐标对应着一个值(与原点的曼哈顿距离)， 打标记就把这个点后面的区间更新一下，计算距离即把一个点的坐标之和减去其前缀中的最大坐标之和即为最近距离。 因此需要以立方体的八个顶点为起点开八个树状数组，每次操作维护相关信息即可 #include&lt;bits/stdc++.h&gt; #define fi first #define se second #define pb(x) push_back(x) #define eb(x) emplace_back(x) #define mem(a,b) memset(a,b,sizeof(a)) #define all(x) x.begin(),x.end() #define fastinout ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); using namespace std; typedef unsigned long long ull; typedef long long ll; typedef double db; typedef pair&lt;int,int&gt; pii; typedef vector&lt;int&gt; vi; typedef vector&lt;ll&gt; vl; const double eps=1e-6; const int inf=0x3f3f3f3f; const ll INF=0x3f3f3f3f3f3f3f3f; const int mod=998244353; const int maxn=3e5+5; /***********************************************/ int n,m,h; struct BIT{ int a[maxn]; inline int lowbit(int x){return x&amp;(-x);} inline int getid(int x,int y,int z){return x*m*h+y*h+z;} inline void init(){for(int i=0;i&lt;maxn;i++) a[i]=-inf;} inline void add(int x,int y,int z,int val){ for(int i=x;i&lt;=n;i+=lowbit(i)) for(int j=y;j&lt;=m;j+=lowbit(j)) for(int k=z;k&lt;=h;k+=lowbit(k)) a[getid(i,j,k)]=max(a[getid(i,j,k)],val); } inline int query(int x,int y,int z){ int res=-inf; for(int i=x;i;i-=lowbit(i)) for(int j=y;j;j-=lowbit(j)) for(int k=z;k;k-=lowbit(k)) res=max(res,a[getid(i,j,k)]); return res; } }tree[8]; int main() { fastinout;int T;cin&gt;&gt;n&gt;&gt;m&gt;&gt;h&gt;&gt;T; for(int i=0;i&lt;8;i++) tree[i].init(); while(T--){ int op,x,y,z;cin&gt;&gt;op&gt;&gt;x&gt;&gt;y&gt;&gt;z; if(op==1){ tree[0].add(x,y,z,x+y+z); tree[1].add(x,y,h-z+1,x+y-z); tree[2].add(x,m-y+1,z,x-y+z); tree[3].add(x,m-y+1,h-z+1,x-y-z); tree[4].add(n-x+1,y,z,-x+y+z); tree[5].add(n-x+1,y,h-z+1,-x+y-z); tree[6].add(n-x+1,m-y+1,z,-x-y+z); tree[7].add(n-x+1,m-y+1,h-z+1,-x-y-z); } else{ int ans=inf; ans=min(ans,x+y+z-tree[0].query(x,y,z)); ans=min(ans,x+y-z-tree[1].query(x,y,h-z+1)); ans=min(ans,x-y+z-tree[2].query(x,m-y+1,z)); ans=min(ans,x-y-z-tree[3].query(x,m-y+1,h-z+1)); ans=min(ans,-x+y+z-tree[4].query(n-x+1,y,z)); ans=min(ans,-x+y-z-tree[5].query(n-x+1,y,h-z+1)); ans=min(ans,-x-y+z-tree[6].query(n-x+1,m-y+1,z)); ans=min(ans,-x-y-z-tree[7].query(n-x+1,m-y+1,h-z+1)); cout&lt;&lt;ans&lt;&lt;endl; } } } 题目树状数组-求线段交点个数//HDU-5862 /* 扫描线+线段树维护竖直方向点个数的前缀和，把坐标离散化之后用一条垂直x轴的线去扫(想象垂直线) 对于平行x轴的线(水平线)，碰到左端点就在响应位置+1，碰到右端点就在之前的位置-1。(删掉之后这条水平线就不会产生贡献了) 对于垂直线,求其上端点到下端点之间的点的个数(区间内水平线的个数) */ const int maxn=1e5+5; struct Line{ int x,y,z; Line(int x=0,int y=0,int z=0):x(x),y(y),z(z){} bool operator&lt; (const Line&amp; l){ return x&lt;l.x||(x==l.x&amp;&amp;z&lt;l.z); } }a[maxn],b[maxn],c[maxn*2]; int val[maxn&lt;&lt;2],cnt; int id(int x){return lower_bound(val+1,val+1+cnt,x)-val;} struct BIT{ int a[maxn*5]; void init(){mem(a,0);} int lowbit(int x){return x&amp;(-x);} void update(int x,int v){ for(int i=x;i&lt;=maxn&lt;&lt;2;i+=lowbit(i)) a[i]+=v; } int query(int x){ int res=0; for(int i=x;i&gt;0;i-=lowbit(i)) res+=a[i]; return res; } int solve(int l,int r){ return query(r)-query(l-1); } }Tree; int main() { fastinout;int T;cin&gt;&gt;T; while(T--){ Tree.init(); int k,na=0,nb=0,nc=0; cnt=0;cin&gt;&gt;k; for(int i=1;i&lt;=k;i++){ int x1,x2,y1,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; val[++cnt]=x1;val[++cnt]=y1; val[++cnt]=x2;val[++cnt]=y2; if(x1==x2){ if(y1&gt;y2) swap(y1,y2); b[++nb]=Line(x1,y1,y2); } if(y1==y2){ if(x1&gt;x2) swap(x1,x2); a[++na]=Line(y1,x1,x2); } } sort(val+1,val+1+cnt); cnt=unique(val+1,val+1+cnt)-val-1; for(int i=1;i&lt;=na;i++){ a[i].x=id(a[i].x); a[i].y=id(a[i].y); a[i].z=id(a[i].z); c[++nc]=Line(a[i].y,i,1); c[++nc]=Line(a[i].z,i,3); } for(int i=1;i&lt;=nb;i++){ b[i].x=id(b[i].x); b[i].y=id(b[i].y); b[i].z=id(b[i].z); c[++nc]=Line(b[i].x,i,2); } sort(c+1,c+1+nc); ll ans=0; for(int i=1;i&lt;=nc;i++){ if(c[i].z==1) Tree.update(a[c[i].y].x,1); if(c[i].z==2) ans+=Tree.solve(b[c[i].y].y,b[c[i].y].z); if(c[i].z==3) Tree.update(a[c[i].y].x,-1); } cout&lt;&lt;ans&lt;&lt;endl; } }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形dp]]></title>
    <url>%2F2019%2F12%2F25%2F%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[树形DP树形DP主要有三种题型： 1.最大独立子集问题(父节点与子节点不能共存) 2.数的直径(一棵树上的两个节点间的路径长度的最大值) 3.树的重心(将节点x去掉后，树所形成的各个连通块的节点数最少) 最大独立子集问题洛谷P1352 没有上司的舞会题意：一棵树，n个点，每人一个权值，父节点与子节点不能同时选，求子集最大权 思路：dfs，在递归的回溯阶段完成计算dp[i][0]-&gt;不选i节点取得的最大值 dp[i][1]-&gt;选i节点取得的最大值 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=6e3+5; int r[maxn],boss[maxn],dp[maxn][2],n,l,k; vector&lt;int&gt; G[maxn]; void dfs(int u){ for(auto &amp;v:G[u]){ dfs(v);//v是u的子节点，回溯需注意 dp[u][0]+=max(dp[v][1],dp[v][0]);//不选u,则v可选或不选 dp[u][1]+=dp[v][0];//选u,则v不能选 } dp[u][1]+=r[u];//选u,需要加上自身的权值 } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;r[i]); while(~scanf(&quot;%d%d&quot;,&amp;l,&amp;k),l+k){ boss[l]=k;G[k].push_back(l); } for(int i=1;i&lt;=n;i++){ if(boss[i]==0){//从树的根出发，即入度为0的点 dfs(i);printf(&quot;%d\n&quot;,max(dp[i][0],dp[i][1]));break; } } } 洛谷P2015 二叉苹果树题意：一棵树(规定每个节点的子节点要么为0、要么为2),每个树枝上有权值，现减边，求保留m条边最多能留住多少权值。 思路：树形DP 要使得一棵树割掉k个节点后整棵树权值和最大。这个题目挺恶心人的处理起来也麻烦。因为虽然这题目保证是二叉树，但是他输入时并没有给我们两个点的先后顺序。也就是他输入u,v,w，你不知道u是v的父亲还是v是u的父亲。网上有很多人写这个题解时为了方便就乱搞，判断什么如果那个点左儿子为空就成为左儿子否则成为右儿子的什么鬼。 正确的姿势应该是用边表存储。像我的做法就是拿边表存储之后弄一个find函数找出每一个节点的父亲。 我还多做了一个其实可以不用这么做的无用功：我又跑了一遍枚举找出每个节点的左右儿子。前面麻烦的事干完，接下来我们就可以考虑dp了。 由于题目给的权值都是边权，我们就可以进行一个骚操作：把每条边的权值都下移到那条边通向的儿子节点上，然后给根节点的权值置0。 因为我们给了根节点1一个0的权值，所以我们要保留的节点数就从q变成q+1了！然后我们可以继续进行骚操作，用dp(i,j)表示保留j个节点，于是我们一开始就dp根节点：dp(1,q+1)。那么这个dp的函数该怎么写呢？ 我们设某一个子树要保留j个节点，而根节点是一定要保存的，因为如果你一开始就把根节点剪掉了就啥都没了嘛。所以根节点的以两个儿子为根的子树就总共要保存j-1个节点。 有了思路，我们就可以设左子树保存k个节点，然后我们来枚举这个k，于是右子树就可以推出来是保存j-k-1个节点啦。然后我们就来找状态转移方程和最大值。 首先我们来想，当j=0时，也就是某棵子树上取0个点时。取0个点答案当然是0。然后我们可以按照刚才的思路，给左儿子分配可以保留k个节点，给右儿子分配可以保留j-k-1个 节点，于是我们就枚举k，然后记忆化搜索一波：如果f[某个子节点][k]==0就说明这个节点还没访问过，答案还没有更新，我们就来把这个节点和这个k值dp一遍，作为待会dp 时需要的条件（dp前必须把需要的东西准备好，这就是在准备东西。）然后就可以推出状态转移方程为： f[i][j]=max(f[i][j],f[son[i][0]][k]+f[son[i][1]][j-k-1]+dis[i]); f[i][j]=max(f[i][j],儿子节点分配后的最大值加上i节点的权值。 #include&lt;bits/stdc++.h&gt; #define pii pair&lt;int,int&gt; using namespace std; const int maxn=105; int fa[maxn],son[maxn][2],dis[maxn],dp[maxn][maxn]; bool vis[maxn]; vector&lt;pii&gt; edge[maxn]; void addedge(int u,int v,int w){ edge[u].push_back(pii(v,w)); } void find(int x){ for(auto &amp;v:edge[x]){ if(vis[v.first]==0){//如果x边的出点还没被标记过 fa[v.first]=x;vis[v.first]=1; find(v.first); } } } void solve(int i,int j){//树形DP的函数 if(j==0) dp[i][j]=0;//如果要保留0个点，最大值当然是0了 else if(son[i][0]==0&amp;&amp;son[i][1]==0) dp[i][j]=dis[i];//如果没有儿子节点，最大值就是它本身的价值。 else{ for(int k=0;k&lt;j;k++){//k不能=j，否则j-k-1就会变成负数，是没有意义的，注意边界。 if(dp[son[i][0]][k]==0) solve(son[i][0],k); if(dp[son[i][1]][j-k-1]==0) solve(son[i][1],j-k-1); dp[i][j]=max(dp[i][j],dp[son[i][0]][k]+dp[son[i][1]][j-k-1]+dis[i]);//状态转移方程 } } } int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;n;i++){ int u,v,w;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); addedge(u,v,w);addedge(v,u,w); } vis[1]=1;find(1); for(int i=1;i&lt;=n;i++){//这是找每个节点的左右儿子的过程 int v=-1; for(auto &amp;j:edge[i]){ if(fa[j.first]==i){//如果i是j.first点的爸爸的话 son[i][++v]=j.first; dis[j.first]=j.second; if(v==1) break;//v==1时说明i节点的两个儿子都找到了，所以就直接break掉减少枚举量 } } } solve(1,m+1); printf(&quot;%d\n&quot;,dp[1][m+1]); } 洛谷P2014 选课题意：有的课程有先修课，每门课有权值，求修m门课能获得的最大权值 思路：不一定是二叉树，实际上是多叉树，需要转换为二叉树，多叉树转换时儿子变为左儿子son[i][0],兄弟变为右儿子；插入兄弟时需要循环查找最后一个兄弟，再插入； #include&lt;bits/stdc++.h&gt; #define pii pair&lt;int,int&gt; using namespace std; const int maxn=305; int fa[maxn],son[maxn][2],val[maxn],dp[maxn][maxn];//son[][0]-&gt;左儿子 son[][1]-&gt;兄弟 vector&lt;pii&gt; edge[maxn]; int dfs(int i,int j){ if(i==0||j==0) return 0;//递归边界返回0 if(dp[i][j]) return dp[i][j];//记忆化 dp[i][j]=dfs(son[i][1],j);//(dfs入口从0节点进入)0节点作为祖先的大儿子，祖先的其他儿子都是他的兄弟(因此不存在森林) for(int k=0;k&lt;j;k++){ dp[i][j]=max(dp[i][j],dfs(son[i][0],k)+dfs(son[i][1],j-k-1)+val[i]);//转移方程 } return dp[i][j];//记得返回 } int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ int u,w;scanf(&quot;%d%d&quot;,&amp;u,&amp;w); val[i]=w; if(son[u][0]==0) son[u][0]=i;//没有左儿子直接插 else{//有左儿子 int x=son[u][0];//x-&gt;左儿子 while(son[x][1]) x=son[x][1];//变为左儿子的兄弟 son[x][1]=i; } } printf(&quot;%d\n&quot;,dfs(son[0][0],m));//递归入口注意-&gt; 0 } HDU-1054(Strategic Game)题意：一棵树求最小边覆盖 思路：二分图最小覆盖(建双向边故最大匹配/2) or 树形dp 实测前者436ms VS 后者182ms #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1505; int n,dp[maxn][2]; bool fa[maxn]; vector&lt;int&gt; G[maxn]; inline void init(int n){ for(int i=0;i&lt;n;i++) G[i].clear(),fa[i]=0,dp[i][0]=0,dp[i][1]=1; } inline void addedge(int u,int v){G[u].push_back(v);} void dfs(int u){ for(auto &amp;v:G[u]){ dfs(v); dp[u][0]+=dp[v][1];//不选u点则其孩子节点必须选 dp[u][1]+=min(dp[v][0],dp[v][1]);//选了u则其孩子可选可不选 } } int main() { while(~scanf(&quot;%d&quot;,&amp;n)){ init(n); for(int i=0;i&lt;n;i++){ int u,v,c; scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;c); while(c--){ scanf(&quot;%d&quot;,&amp;v); addedge(u,v);fa[v]=1; } } int r=0;for(int i=0;i&lt;n;i++) if(!fa[i]) {r=i;break;} dfs(r); printf(&quot;%d\n&quot;,min(dp[r][0],dp[r][1])); } } 树的直径1.两遍bfs，何苦dp 2.树形dp POJ-1985 Cow Marathon求树的直径裸题,边带权，第一次随机找一点bfs看最远能走到哪(比如v),再以v为起点bfs找最远点 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #define pii pair&lt;int,int&gt; using namespace std; const int maxn=1e5+5; int n,m,d[maxn]; bool vis[maxn]; vector&lt;pii&gt; edge[maxn]; int bfs(int s,int f){ memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); queue&lt;int&gt; que;que.push(s); int ans=s,MAX=0; d[s]=0;vis[s]=1; while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;edge[t].size();i++){ int v=edge[t][i].first; if(vis[v]) continue; d[v]=d[t]+edge[t][i].second; vis[v]=1;que.push(v); if(MAX&lt;d[v]){ MAX=d[v];ans=v; } } } if(f==0) return ans; else return MAX; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int q=0; for(int i=1;i&lt;=m;i++){ int j,k,l,ch;scanf(&quot;%d %d %d %c&quot;,&amp;j,&amp;k,&amp;l,&amp;ch); edge[j].push_back(pii(k,l)); edge[k].push_back(pii(j,l)); } int v=bfs(1,0); int ans=bfs(v,1); printf(&quot;%d\n&quot;,ans); } 2019牛客多校(四) A-meeting题意：一棵树上有n个点，边权均为1，k个人在不同的k个点上(1&lt;k&lt;=n)求这k个人汇聚到同一点上的最长时间 思路：两遍bfs求关键点子树的半径，先求直径，再除以2向上取整，注意求最远距离时遇到关键点才更新最大值 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+5; vector&lt;int&gt; G[maxn]; bool vis[maxn],vis1[maxn]; int n,k,d1[maxn],vis2[maxn]; int bfs1(int s){ queue&lt;int&gt; que;que.push(s);vis1[s]=1;int ans=s; while(!que.empty()){ int u=que.front();que.pop(); for(auto&amp; v:G[u]){ if(!vis1[v]){ if(vis[v]) ans=v; que.push(v);vis1[v]=1; } } } return ans; } int bfs2(int s){ queue&lt;int&gt; que;que.push(s);vis2[s]=1;int ans=0; while(!que.empty()){ int u=que.front();que.pop(); for(auto&amp; v:G[u]){ if(!vis2[v]){ vis2[v]=vis2[u]+1;que.push(v); if(vis[v]) ans=vis2[v]; } } } return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;n;i++){ int u,v;cin&gt;&gt;u&gt;&gt;v; G[u].push_back(v);G[v].push_back(u); } int t; while(k--) {cin&gt;&gt;t;vis[t]=1;} int s=bfs1(t); double ans=bfs2(s)-1; cout&lt;&lt;ceil(ans/2)&lt;&lt;endl; } HDU-2196 Computer讲解来自NB网友 首先第一个dfs求出所有每个节点i在其子树中的正向最大距离和正向次大距离和dist[i][0]和dist[i][1]（如果i节点在子树中最大距离经过了2号儿子，那么次大距离就是不经过2号儿子的最大距离）。 并且还要标记longest[i]=j表示节点i在其子树中的最大距离经过了节点j（即j是i的一个儿子）。 由上步我们获得了正向最大距离，正向次大距离和最大距离的儿子节点标记。画图可以知道我们建立的这棵树，i节点的最远距离只有两种选择： i节点所在子树的最大距离，或者i节点连接它的父节点所能到达的最大距离。（即前者往下走，后者先往上走之后很可能也往下走） 所以我们只要求出反向最大距离dist[i][2]（即i节点往它的父节点走所能到达的最大距离）就可以知道i节点在整个树中能走的最大距离了。 dist[i][2]求法：i节点往它的父节j点走，如果它的父节点的正向最大距离不经过i的话，那么dist[i][2]要不就是它父节点的反向最大距离+W[i][j]要不就是它父节点的正向最大距离+ W[i][j]. 如果它的父节点的正向最大距离经过i的话，那么dist[i][2]要不就是它父节点的反向最大距离+W[i][j]要不就是它父节点的正向次大距离+ W[i][j]. #include&lt;bits/stdc++.h&gt; #define pii pair&lt;int,int&gt; using namespace std; const int maxn=1e4+5; vector&lt;pii&gt; edge[maxn]; int dp[maxn][3],id[maxn]; void dfs1(int u,int f){//第一个dfs求出子树的最大和次大和 for(auto &amp;v:edge[u]){ if(v.first==f) continue; dfs1(v.first,u); if(dp[u][0]&lt;dp[v.first][0]+v.second){//记录最大和，记录经过哪个儿子最大 dp[u][0]=dp[v.first][0]+v.second;id[u]=v.first; } } for(auto &amp;v:edge[u]){ if(v.first==f||id[u]==v.first) continue;//跳过这个儿子在里面找一个最大的就是这点次大的 dp[u][1]=max(dp[u][1],dp[v.first][0]+v.second); } } void dfs2(int u,int f){//更新先往父亲节点走一步的最大和 for(auto &amp;v:edge[u]){ if(v.first==f) continue; //难点，每个父亲都有两种方式，一个是再往父亲走一步，一个是走父亲的子树，max(dp[u][2], dp[u][1])，这个就体现出这两步了，注意不经过这个点直接走子树最大和的那个点 if(v.first==id[u]) dp[v.first][2]=max(dp[u][2],dp[u][1])+v.second;//这个是针对儿子，所以是dp[v.first][2]=，体现了先走一步父亲，经过就走次大的，再走最大的就重复了一段 else dp[v.first][2]=max(dp[u][2],dp[u][0])+v.second; dfs2(v.first,u);//因为dfs1更新了所有子树的特点，子树的信息可以直接用了，父节点的信息从一步步dfs下去都已经更新好了，上面的也是可以直接用，每一步都看看是不是走父亲的父亲更好，一直更新最优 } } int main() { int n; while(~scanf(&quot;%d&quot;,&amp;n)){ int a,b;memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) edge[i].clear(); for(int i=2;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;a,&amp;b); edge[i].push_back(pii(a,b)); edge[a].push_back(pii(i,b)); } dfs1(1,-1); dfs2(1,-1);//1为根节点 for(int i=1;i&lt;=n;i++) printf(&quot;%d\n&quot;,max(dp[i][0],dp[i][2])); } }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小表示法]]></title>
    <url>%2F2019%2F12%2F25%2F%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最小表示法大米饼巨巨&apos;s Blog: https://www.cnblogs.com/Paul-Guderian/p/10206362.html 给定一个长度为n，可循环旋转的字符串环，求从哪个位置断开 使得该长度为n的字符串的字典序最小/最大 下面以字典序最小为例，最大同理 令 i=0,j=1 表示最小字符串可能出现的位置 找到一个 k 使得 s[i+1]==s[j+1],s[i+2]==s[j+2],...,s[i+k-1]==s[j+k-1] 但是 s[i+k]!=s[j+k] 若 s[i+k]&lt;s[j+k] ，对于j&apos;=j+1到j+k的位置一定不是最优解,因为i+j&apos;-j位置的串一定比j&apos;位置的更优； 且如果i+j&apos;-j位置的串更优一定会被i选到。那么我们就可以 j=j+k+1 s[i+k]&gt;s[j+k]就i=i+k+1,注意i==j时要再向后移动一位 事实上你可以理解成i和j是互相独立的只是其中的某一个为最小的串的待定值，另一个为用来比较的串； 每多匹配一位k，i或j一次跳跃的次数就会相应多一位，最多跳2*k，所以复杂度O(n)； template: int solve(string s){ int i=0,j=1,k,n=s.length(); while(i&lt;n&amp;&amp;j&lt;n){ for(k=0,s[i+k]==s[j+k];k++); if(s[i+k]&lt;s[j+k]){j+=k+1;if(i==j) j++;} //若是最大表示 改成&gt;即可 else {i+=k+1;if(i==j) i++;} } return min(i,j); } 题目寻找主人 BZOJ-1389]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小树形图]]></title>
    <url>%2F2019%2F12%2F25%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最小树形图简单来说，最小树形图就是有向图的最小生成树 给出一个带权有向图，从中指定一个特殊的节点root，求一棵以root为根的有向生成树，且使得T中所有边权之和最小 朱刘算法 O(VE) 网上讲解无证明，了解过程 - 会套模版 - 分清有定根与无定根 - 重在建图 在选出入边集后，若有向图中不存在有向环，则说明该图是最小树形图 1）选入边集，找到除 root 点之外，每一个点的所有入边中权值最小的权值，用数组 in[] 记录这个最小权值，用 pre[] 记录到达该点的前驱。 2）判断图中是否存在独立点，若存在除 root 外的孤立点，则说明 root 无法到达该点，说明最小树形图不存在。 3）在图中寻找环，对环进行缩点并用数组 id[] 记录节点所属环的编号。 4）更新其他点到环上的距离。 5）重复 3、4 直到 图中不存在环 为止，此时图是最小树形图。 套公式记得下标统一。 模版（NB网友）#include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=4e4+5; const int INF=0x3f3f3f3f; struct Edge{ int x,y,w; }edge[maxm]; int vis[maxn]; int id[maxn];//结点所属环编号 int in[maxn],pre[maxn];//in[]为最小入边权,pre[]为其对应的起点 int zhuLiu(int root,int n,int m){//root结点、点数、边数 int res=0;//最小树形图总权值 while(true){ for(int i=0;i&lt;n;i++)//初始化为无穷大 in[i]=INF; //寻找每个点的最小入边 for(int i=0;i&lt;m;i++){//遍历每条边 int x=edge[i].x; int y=edge[i].y; if(edge[i].w&lt;in[y] &amp;&amp; x!=y){//更新最小入边 pre[y]=x;//记录前驱 in[y]=edge[i].w;//更新 } } //判断是否存在最小树形图 for(int i=0;i&lt;n;i++){ if(i==root) continue; if(in[i]==INF)//除根节点外的点存在孤立点 return -1; } //寻找所有的环 int cnt=0;//记录环数 in[root]=0; memset(id,-1,sizeof(id)); memset(vis,-1,sizeof(vis)); for(int i=0;i&lt;n;i++){//标记每个环 res+=in[i];//记录权值 int y=i; while(vis[y]!=i&amp;&amp;id[y]==-1&amp;&amp;y!=root){//寻找图中有向环 //三种情况会终止：找到出现同样标记的点、结点已属其他环、遍历到根 vis[y]=i;//标记 y=pre[y];//向上找 } if(y!=root&amp;&amp;id[y]==-1){//没有遍历到根或没有找到结点属于其他环,说明找到有向环 for(int x=pre[y];x!=y;x=pre[x])//标记结点x为第几个环 id[x]=cnt;//记录结点所属环号 id[y]=cnt++;//记录结点所属环号并累加 } } if(cnt==0)//无环 break; for(int i=0;i&lt;n;i++)//可能存在独立点 if(id[i]==-1)//环数累加 id[i]=cnt++; //建立新图,缩点重新标记 for(int i=0;i&lt;m;i++){ int x=edge[i].x; int y=edge[i].y; edge[i].x=id[x]; edge[i].y=id[y]; if(id[x]!=id[y])//两点不在同一环内,更新边权值 edge[i].w-=in[y];//x到y的距离为边权-in[y] } n=cnt;//以环数为下次操作的点数,继续上述操作,直到无环 root=id[root]; } return res; } int main(){ int n,m;//n个点m条有向边 scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++){//建图 scanf(&quot;%d%d%d&quot;,&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].w); if(edge[i].x==edge[i].y)//除去自环,即点到自身距离为INF edge[i].w=INF; } int res=zhuLiu(0,n,m); if(res==-1) printf(&quot;No\n&quot;); else printf(&quot;%d\n&quot;,res); return 0; } 模版（邝斌）#include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=4e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; }edge[maxm]; int pre[maxn],id[maxn],vis[maxn],in[maxn]; int zhuliu(int root,int n,int m,Edge edge[]){ int res=0,u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++) if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u; in[edge[i].v]=edge[i].cost; } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int tn=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=tn; id[v]=tn++; } } if(tn==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=tn++; for(int i=0;i&lt;m;){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i++].cost-=in[v]; else swap(edge[i],edge[--m]); } n=tn;root=id[root]; } return res; } int g[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m,ca=0,T;cin&gt;&gt;T; while(T--){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) g[i][j]=INF; int u,v,cost; while(m--){ int u,v,cost;cin&gt;&gt;u&gt;&gt;v&gt;&gt;cost; if(u==v) continue; g[u][v]=min(g[u][v],cost); } int L=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(g[i][j]&lt;INF){ edge[L].u=i;edge[L].v=j;edge[L++].cost=g[i][j]; } int ans=zhuliu(0,n,L,edge); cout&lt;&lt;&quot;Case #&quot;&lt;&lt;ca++&lt;&lt;&quot;: &quot;; if(ans==-1) cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; } } 题目有定根//POJ-3164 有定根的最小树形图 题意：给出 n 个点 m 条有向边，首先给出从 1 号点到 n 号点的笛卡尔坐标，然后再给出 m 条边，1 号点始终为根节点，求最小树形图 思路：朱刘算法第一题。。。边的权值用 double 型，求一下距离直接建图后，然后套模版。。。注意模版需要改为 double 型 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=105; const int maxm=1e4+5; const double INF=0x3f3f3f3f; struct Node{ double x,y; }node[maxn]; struct Edge{ int u,v;double cost; }edge[maxm]; double cal(Node a,Node b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } int pre[maxn],id[maxn],vis[maxn]; double in[maxn]; double zhuliu(int root,int n,int m){ double res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ u=edge[i].u;v=edge[i].v; if(u!=v&amp;&amp;edge[i].cost&lt;in[v]){ pre[v]=u;in[v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int main() { int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;(n+m)){ for(int i=0;i&lt;n;i++) scanf(&quot;%lf%lf&quot;,&amp;node[i].x,&amp;node[i].y); for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v); edge[i].u--;edge[i].v--; if(edge[i].u!=edge[i].v) edge[i].cost=cal(node[edge[i].u],node[edge[i].v]); else edge[i].cost=INF; } double ans=zhuliu(0,n,m); if(ans==-1) printf(&quot;poor snoopy\n&quot;); else printf(&quot;%.2f\n&quot;,ans); } } 无定根//HDU-2121 图不需要自己额外建(即题目给好了N个点,M条边),只是没有给定根 题意：n 个点 m 条有向边，现要在 n 个点中选一个点作为首都，要求首都与其他点是可达的， 给出 m 条道路修建要花费的价格，求最小花费并给出首都的序号，点的标号从 0 开始。 无根最小树形图，构造根节点0，从0到各点建立权值大于整张图权值和的边（此处取sum+1）， 这样一来0为根节点求最小树形图，如果不存在最小树形图或者所得最小树形图的权值和不小于2*(sum+1) 说明原图的最小树形图不存在，至于如何求编号最小的根节点，这个可以在求最短弧集合的时候得到， 即如果一条边被加入最短弧集合且这条边的起点是0，那么这条边的终点就是所求最小树形图的根 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; }edge[maxm+maxn]; int pos;//实际起点 int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; if(edge[i].u==root) pos=i; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; //else swap(edge[i],edge[--m]); } n=cnt;root=id[root]; } return res; } int main() { int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ int sum=0; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].cost); edge[i].u++;edge[i].v++;sum+=edge[i].cost; } sum++;//去掉就WA for(int i=0;i&lt;n;i++){ edge[i+m].u=0;edge[i+m].v=i+1;edge[i+m].cost=sum; } int ans=zhuliu(0,n+1,m+n); ////若差值大于sum说明结点0的出度不止为1,即原图不是连通图 if(ans==-1||ans-sum&gt;=sum) printf(&quot;impossible\n&quot;); else printf(&quot;%d %d\n&quot;,ans-sum,pos-m); printf(&quot;\n&quot;); } } 建图+无定根//HDU-4009 图需要自己建,同时也没有给定根 题意：n户人家，每家对应一个三维坐标(x, y, z)，z代表这家的海拔高度。 每家可以通过挖井获得水，也可以通过从别的人家引一条水渠获得水，其花费如下： 1.挖井花费z*X； 2.从不比自己低的人家引水渠花费Y*两家之间的曼哈顿距离； 3.从比自己低的人家引水渠与2中的相同，但需要多花Z来购买一个水泵 此外有的人家不允许一些人家从他们家引水渠，求使得所有人家都能获得水的最少花费 思路：对应这个题,其初始点就可以设为这n个点,然后权值为在这个点建井的花费,而对于它给的其他边,我们直接在对应的两个点上建边即可,然后跑一下朱刘算法,就可得出答案 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Node{ int x,y,z; }node[maxn]; struct Edge{ int u,v,cost; }edge[maxm+maxn*maxn]; int dis(Node a,Node b){ return abs(a.x-b.x)+abs(a.y-b.y)+abs(a.z-b.z); } int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int main() { int n,X,Y,Z; while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;X,&amp;Y,&amp;Z)&amp;&amp;(n+X+Y+Z)){ for(int i=0;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;node[i].x,&amp;node[i].y,&amp;node[i].z); } int cnt=0,a,b; for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a); while(a--){ scanf(&quot;%d&quot;,&amp;b); edge[cnt].cost=dis(node[i],node[--b])*Y; if(node[b].z&gt;node[i].z) edge[cnt].cost+=Z; edge[cnt].u=i;edge[cnt++].v=b; } } for(int i=0;i&lt;n;i++){ edge[cnt].u=n;edge[cnt].v=i;edge[cnt++].cost=node[i].z*X; } printf(&quot;%d\n&quot;,zhuliu(n,n+1,cnt)); } } 建图+无定根//HYSBZ - 4349 无定根 题意：攻打每一个人的堡垒需要一个代价,而且必须攻打若干次,各个堡垒之间会相互提供援助, 小C只要攻打某个堡垒一次之后，某些堡垒就只需要花更小的代价攻击了,求消灭所有堡垒的最小代价。 思路: 如题目，最小树形图裸题，建立一个虚点，连向所有点，然后跑出每个点都打一次的最小代价。 然后再来以每次都是最小代价的打法，对每个点再打times[i]−1次。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const double INF=0x3f3f3f3f; struct Edge{ int u,v; double cost; Edge(int U=0,int V=0,double C=0):u(U),v(V),cost(C){} }edge[maxn*maxn+maxn]; int pre[maxn],id[maxn],vis[maxn]; double in[maxn]; double zhuliu(int root,int n,int m){ double res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int times[maxn];//times[i] 记录 i 点需要打几次 double cost[maxn];//cost[i] 记录打 i 点的花费 int main() { int n,m; while(~scanf(&quot;%d&quot;,&amp;n)){ int cnt=0; for(int i=1;i&lt;=n;i++){ scanf(&quot;%lf%d&quot;,&amp;cost[i],&amp;times[i]); edge[cnt++]=Edge(0,i,cost[i]);//建 0-&gt;i 初始花费的边(设0为虚根) } scanf(&quot;%d&quot;,&amp;m); int u,v;double c; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%lf&quot;,&amp;u,&amp;v,&amp;c); edge[cnt++]=Edge(u,v,c);//建 u-&gt;v 较小花费的边 cost[v]=min(cost[v],c); } double ans=0; for(int i=1;i&lt;=n;i++) ans+=(times[i]-1)*cost[i];//需要打times[i]次，所以需要加上(time[i]-1)次 * 较小花费 printf(&quot;%.2f\n&quot;,zhuliu(0,n+1,cnt)+ans);//0-&gt;根 n+1个点 cnt条边 } } /* 3 10 1 1.8 1 2.5 2 2 1 3 2 3 2 1.5 3 10 1 9 1 8 1 0 */ 建图+无定根+多点(一个课程好多点)题意：给你n门课的最高等级及m条升级方法，开始时你每门课的等级都在等级0，升级方法的5个参数代表，你要上这门课，你的课程c的等级至少要到达L1i， 你才能达到课程d的等级L2i，同时花费金钱moi，现在问你，每门课的等级都要到达最高等级所需要花费的最小费用是多少，如果不能都达到最高级别，输出-1 思路：图论的题，精华都是在构图，这道题很明显是一道有向的最小生成树，也就是最小树形图，那么问题来了，因为条件中是至少到达，这样如果中间断开， 按正常的建边就不能使得这棵树完整，那么精妙的方法就来了，外面把所有的边都往反向建一次，及课程a的等级i+1连向i，这就可以保证， 如果我已经达到了等级i+1，就不用再对i作花费，同时，等级i如果能连向终点，也可以直接在树的结构中体现出来。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; Edge(int U=0,int V=0,int C=0):u(U),v(V),cost(C){} }edge[maxn*maxn+maxn]; int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int a[maxn],sum[maxn]; int main() { int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n+m)){ sum[0]=0; for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);a[i]++;//a[i]表示一个课程的a[i]++(0~a[i])个等级，共a[i]++个点 sum[i+1]=sum[i]+a[i];//sum[i]~sum[i+1]-1记录i课程的a[i]个点的序号 } int cnt=0; for(int i=0;i&lt;n;i++){ for(int j=sum[i+1]-1;j&gt;sum[i];j--){ edge[cnt++]=Edge(j,j-1,0); }//将所有等级作为一个节点，对于等级i,可以建一条对等级i-1的边，边权为0 edge[cnt++]=Edge(sum[n],sum[i],0); }//其中sum[n]为虚拟的跟，指向所有的课程的level0的点 int c,d,l1,l2,mo; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%d%d%d&quot;,&amp;c,&amp;l1,&amp;d,&amp;l2,&amp;mo); edge[cnt++]=Edge(sum[c-1]+l1,sum[d-1]+l2,mo); }//建立c课程的level0+l1 到 d课程的level0+l1 之间的边 权值为价格 printf(&quot;%d\n&quot;,zhuliu(sum[n],sum[n]+1,cnt)); } } 代补题：UVA - 11865 ----&gt;二分加最小树形图 CodeForces - 240E -------&gt;最小树形图+路径输出 (自己独立思考出这个题就应该能完全掌握最小树形图)]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斯特灵数 & 卡特兰数]]></title>
    <url>%2F2019%2F12%2F25%2F%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E4%B8%8E%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[斯特灵数第一类斯斯特灵： s[n,k] 表示 n 个元素分成 k 个环的方案数： s[n,k]=s[n-1,k-1]+(n-1)*s[n-1,k] 理解：考虑从n-1个元素推过来，如果两个空环肯定是不符合的空一个环则单独成环，如果n−1的时候就没有空环就任意放在一个元素前 性质：n!=∑i:0-&gt;n s[n,i] 第二类斯斯特灵： S[n,k] 表示 n 个元素分成 k 个等价类的方案数：S[n,k]=S[n-1,k-1]+k*S[n-1,k] 也可以理解为 n 个有区别的小球丢进 k 个无区别的盒子的方案数 性质：k^n=∑i：0-&gt;k S[n,i]∗i!∗C(k,i) S[0][0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i+1;j++) S[i][j]=(S[i-1][j-1]+j*s[i-1][j])%mod; 卡特兰数1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012 h(0)=h(1)=1 h(n) = h(n-1)*(4*n-2)/(n+1) = C[2*n,n]-C[2*n,n-1] = C[2*n,n]/(n+1) = ∑ f(i)∗f(n−i−1) (i: 0 -&gt; n-1) 卡特兰数的应用：(待补) https://blog.csdn.net/wookaikaiko/article/details/81105031 http://blog.leanote.com/post/denghaoyu/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斯坦纳树]]></title>
    <url>%2F2019%2F12%2F25%2F%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91%2F</url>
    <content type="text"><![CDATA[斯坦纳树斯坦纳树问题是组合优化问题，是最短网络的一种 其实最小生成树是最小斯坦纳树的一种特殊情况 最小生成树是在给定点集和边中寻求最短网络使所有点连通。 而最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。 复杂度 O(n*3^k+cE*2^k) c为SPFA复杂度中的常数，E为边的数量，但几乎达不到全部边的数量，甚至非常小。3^k来自于子集的转移sum{C(i,n)*2^i} (1&lt;=i&lt;=n)，用二项式展开求一下和。 Blog: https://www.cnblogs.com/ECJTUACM-873284962/p/7643445.html 题目WC2008 游览计划 (网格图)这题需要输出一个方案 const int maxn=10; int dx[]={0,1,0,-1}; int dy[]={1,0,-1,0}; int max_S,n,m; int mp[maxn][maxn],st[maxn][maxn],vis[maxn][maxn],cnt; int dp[maxn][maxn][1&lt;&lt;maxn],pre[maxn][maxn][1&lt;&lt;maxn]; bool in[maxn][maxn][1&lt;&lt;maxn]; queue&lt;int&gt; Q; void SPFA(){ int x,y,s,tx,ty,ts; while(!Q.empty()){ x=Q.front()/100000; y=(Q.front()-x*100000)/10000; s=Q.front()-x*100000-y*10000; Q.pop();in[x][y][s]=0; for(int i=0;i&lt;4;i++){ int tx=x+dx[i],ty=y+dy[i]; if(tx&gt;=n||ty&gt;=m||tx&lt;0||ty&lt;0) continue; int ts=s|st[tx][ty]; if(dp[x][y][s]+mp[tx][ty]&lt;dp[tx][ty][ts]){ dp[tx][ty][ts]=dp[x][y][s]+mp[tx][ty]; pre[tx][ty][ts]=x*100000+y*10000+s; if(!in[tx][ty][ts]&amp;&amp;s==ts) in[tx][ty][ts]=1,Q.push(tx*100000+ty*10000+ts); } } } } void steinerTree(){ for(int k=1;k&lt;max_S;k++){ for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++){ if(st[i][j]&amp;&amp;!(st[i][j]&amp;k)) continue; for(int x=(k-1)&amp;k;x;x=(x-1)&amp;k){ int t=dp[i][j][x|st[i][j]]+dp[i][j][(k-x)|st[i][j]]-mp[i][j]; if(t&lt;dp[i][j][k]) dp[i][j][k]=t,pre[i][j][k]=i*100000+j*10000+(x|st[i][j]); } if(dp[i][j][k]&lt;inf) Q.push(i*100000+j*10000+k),in[i][j][k]=1; } SPFA(); } } void gao(int x,int y,int s){ vis[x][y]=1; int t=pre[x][y][s]; if(!t) return; int tx=t/100000,ty=(t-tx*100000)/10000,ts=t-tx*100000-ty*10000; gao(tx,ty,ts); if(x==tx&amp;&amp;y==ty) gao(x,y,(s-ts)|st[x][y]); } void Print(){ for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(st[i][j]){ cout&lt;&lt;dp[i][j][max_S-1]&lt;&lt;endl; gao(i,j,max_S-1); for(int x=0;x&lt;n;x++){ for(int y=0;y&lt;m;y++){ if(st[x][y]) cout&lt;&lt;&quot;x&quot;; else if(vis[x][y]) cout&lt;&lt;&quot;o&quot;; else cout&lt;&lt;&quot;_&quot;; } cout&lt;&lt;endl; } return; } } int main() { fastinout;cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++){ cin&gt;&gt;mp[i][j]; if(!mp[i][j]) st[i][j]=1&lt;&lt;(cnt++); } max_S=1&lt;&lt;cnt; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++){ for(int k=0;k&lt;max_S;k++) dp[i][j][k]=inf; if(st[i][j]) dp[i][j][st[i][j]]=0; } steinerTree(); Print(); }]]></content>
      <categories>
        <category>图论</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数位dp]]></title>
    <url>%2F2019%2F12%2F25%2F%E6%95%B0%E4%BD%8Ddp%2F</url>
    <content type="text"><![CDATA[数位DPNB网友Blog https://blog.csdn.net/wust_zzwh/article/details/52100392 看到那种给你两个数，让你求这两个数之间符合条件的数的个数，且这两个数非常大，这样的题目一般就是数位DP 数位DP一般用于计数 两种实现方式： 1.DP预处理+乱搞 2.记忆化搜索(较简单) 模版： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int state=20; int a[20]; ll dp[20][state];//不同题目状态不同 ll dfs(int pos,/*state变量*/,bool lead/*前导零*/,bool limit/*数位上界变量*/)//不是每个题都要判断前导零 { //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了 if(pos==-1) return 1;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */ //第二个就是记忆化(在此前可能不同题目还能有一些剪枝) if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/ int up=limit?a[pos]:9;//根据limit判断枚举的上界up;这个的例子前面用213讲过了 ll ans=0; //开始计数 for(int i=0;i&lt;=up;i++)//枚举，然后把不同情况的个数加到ans就可以了 { if() ... else if()... ans+=dfs(pos-1,/*状态转移*/,lead &amp;&amp; i==0,limit &amp;&amp; i==a[pos]) //最后两个变量传参都是这样写的 /*这里还算比较灵活，不过做几个题就觉得这里也是套路了 大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论 去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目 要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类， 前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/ } //计算完，记录状态 if(!limit &amp;&amp; !lead) dp[pos][state]=ans; /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/ return ans; } ll solve(ll x) { int pos=0; while(x)//把数位都分解出来 { a[pos++]=x%10;//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行 x/=10; } return dfs(pos-1/*从最高位开始枚举*/,/*一系列状态 */,true,true);//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛 } int main() { ll le,ri; while(~scanf(&quot;%lld%lld&quot;,&amp;le,&amp;ri)) { //初始化dp数组为-1,这里还有更加优美的优化,后面讲 printf(&quot;%lld\n&quot;,solve(ri)-solve(le-1)); } } 例题HDU-2089 不要62#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=20; typedef long long ll; int a[maxn],dp[maxn][2];//dp[i][0]-&gt;当前第i位，前一位不是6 dp[i][1]-&gt;当前第i位，前一位是6 int dfs(int pos,int pre,int sta,int limit){ if(pos==-1) return 1;//遍历完了 返回1 if(!limit&amp;&amp;dp[pos][sta]!=-1) return dp[pos][sta];//无上界且已遍历过 int up=limit?a[pos]:9;//根据上一位是否到上界判定这一位的最大值 int tmp=0; for(int i=0;i&lt;=up;i++){ if(pre==6&amp;&amp;i==2) continue;//上一位为6，这一位为2 剪枝 if(i==4) continue;//这一位为4 剪枝 tmp+=dfs(pos-1,i,i==6,limit&amp;&amp;i==a[pos]);//dfs(下一位，该位变为上一位，该位是否为6，是否到了上界) } if(!limit) dp[pos][sta]=tmp;//没到上界 记忆化存储 这里加!limit 是因为边界(如560)的选择比较少(不会是0-9) 无法记录所有的可能 return tmp; } int solve(int x){ int pos=0; while(x){ a[pos++]=x%10;x/=10; } return dfs(pos-1,-1,0,true); } int main() { ios::sync_with_stdio(0);cin.tie(0); int l,r; while(cin&gt;&gt;l&gt;&gt;r,l+r){ memset(dp,-1,sizeof(dp)); cout&lt;&lt;solve(r)-solve(l-1)&lt;&lt;endl; } } HDU-4734 F(x)题意：定义十进制数x的权值为f(x)=a(n)*2^(n-1)+a(n-1)*2(n-2)+...a(2)*2+a(1)*1，a(i)表示十进制数x中第i位的数字。题目给出a，b，求出0~b有多少个不大于f(a)的数。 思路：已知fa，开dp[pos][sum]-&gt;枚举到pos位，后面还需凑sum的权值和的个数 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF=0x3f3f3f3f; const int maxn=1e4+5; int dp[12][maxn],fa,a[12]; int f(int x){ if(x==0) return 0; int ans=f(x/10); return ans*2+x%10; } int dfs(int pos,int sum,bool limit){ if(pos==-1) return sum&lt;=fa; if(sum&gt;fa) return 0; if(!limit&amp;&amp;dp[pos][fa-sum]!=-1) return dp[pos][fa-sum]; int up=limit?a[pos]:9; int ans=0; for(int i=0;i&lt;=up;i++){ ans+=dfs(pos-1,sum+i*(1&lt;&lt;pos),limit&amp;&amp;i==a[pos]); } if(!limit) dp[pos][fa-sum]=ans; return ans; } int solve(int x){ int pos=0; while(x){ a[pos++]=x%10;x/=10; } return dfs(pos-1,0,true); } int main() { int T,ca=1;scanf(&quot;%d&quot;,&amp;T); memset(dp,-1,sizeof(dp)); while(T--){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); fa=f(a);int ans=solve(b); printf(&quot;Case #%d: %d\n&quot;,ca++,ans); } } POJ-3252 Round Numbers题意：一个数的二进制中0的数量不能少于1的数量，求这样的数有多少个。 思路：dp[pos][num]-&gt;枚举到pos位，0的数量比1的数量多num个，可能有负数整体右移32位即可，注意前导0的影响 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int INF=0x3f3f3f3f; int dp[35][70],fa,a[70]; int dfs(int pos,int sum,bool lead,bool limit){ if(pos==-1) return sum&gt;=32; if(!limit&amp;&amp;!lead&amp;&amp;dp[pos][sum]!=-1) return dp[pos][sum]; int up=limit?a[pos]:1; int ans=0; for(int i=0;i&lt;=up;i++){ if(lead&amp;&amp;i==0) ans+=dfs(pos-1,sum,lead,limit&amp;&amp;i==a[pos]); else ans+=dfs(pos-1,sum+(i==0?1:-1),lead&amp;&amp;i==0,limit&amp;&amp;i==a[pos]); } if(!limit&amp;&amp;!lead) dp[pos][sum]=ans; return ans; } int solve(int x){ int pos=0; while(x){ a[pos++]=x&amp;1;x&gt;&gt;=1; } return dfs(pos-1,32,true,true); } int main() { memset(dp,-1,sizeof(dp)); int a,b; while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b)){ printf(&quot;%d\n&quot;,solve(b)-solve(a-1)); } } HDU 3709 Balanced Number思路:枚举中点，左边力矩为正右边力矩为负 枚举到当前位就把这一位产生的贡献加上，若力矩之和为负，则退出，因为后面会一直加上一个负值，剪枝 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=20; ll dp[maxn][maxn][2000]; int a[maxn]; ll dfs(int pos,int point,int sub,bool limit){ if(pos==-1) return sub==0; if(sub&lt;0) return 0; if(!limit&amp;&amp;dp[pos][point][sub]!=-1) return dp[pos][point][sub]; ll ans=0;int up=limit?a[pos]:9; for(int i=0;i&lt;=up;i++) ans+=dfs(pos-1,point,sub+(pos-point)*i,limit&amp;&amp;i==a[pos]); if(!limit) dp[pos][point][sub]=ans; return ans; } ll solve(ll x){ int pos=0; while(x){a[pos++]=x%10;x/=10;} ll ans=0; for(int i=0;i&lt;pos;i++) ans+=dfs(pos-1,i,0,1); return ans-pos; } int main() { memset(dp,-1,sizeof(dp)); int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ ll l,r;scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r); printf(&quot;%lld\n&quot;,solve(r)-solve(l-1)); } } B-number HDU-3652题意:统计区间 [1,n] 中含有 &apos;13&apos; 且模 13 为 0 的数字有多少个。 思路:dp[pos][mod][sta] //sta=0 -&gt; 不含13且末尾不是1 sta=1 -&gt; 不含13且末尾是1 sta=2 -&gt; 含13 于是只有弄清楚三种状态之间的转化 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=15; int a[maxn]; ll dp[maxn][13][3]; ll dfs(int pos,int mod,int sta,bool limit){ if(pos==-1) return mod==0&amp;&amp;sta==2; if(!limit&amp;&amp;dp[pos][mod][sta]!=-1) return dp[pos][mod][sta]; int up=limit?a[pos]:9; ll ans=0; for(int i=0;i&lt;=up;i++){ int newsta=sta,newmod=(mod*10+i)%13;//秦九韶算法获得新的模数 if(sta==0&amp;&amp;i==1) newsta=1; else if(sta==1&amp;&amp;i!=1&amp;&amp;i!=3) newsta=0; else if(sta==1&amp;&amp;i==3) newsta=2; ans+=dfs(pos-1,newmod,newsta,limit&amp;&amp;i==a[pos]); } if(!limit) dp[pos][mod][sta]=ans; return ans; } ll solve(ll x){ int pos=0; while(x){a[pos++]=x%10;x/=10;} return dfs(pos-1,0,0,1); } int main() { ll n;memset(dp,-1,sizeof(dp)); while(~scanf(&quot;%lld&quot;,&amp;n)){ printf(&quot;%lld\n&quot;,solve(n)); } } HDU 4507 恨7不成妻题解：https://blog.csdn.net/chenxiaoran666/article/details/82950881 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll mod=1e9+7; struct Node{ ll cnt,sum,sqsum; }dp[20][10][10]; int bit[20]; ll p[20]; Node dfs(int pos,int presum,int prenum,bool limit){ if(pos==-1){ Node tmp; tmp.cnt=(presum!=0&amp;&amp;prenum!=0); tmp.sum=tmp.sqsum=0; return tmp; } if(!limit&amp;&amp;dp[pos][presum][prenum].cnt!=-1) return dp[pos][presum][prenum]; int up=limit?bit[pos]:9; Node ans,tmp;ans.cnt=ans.sqsum=ans.sum=0; for(int i=0;i&lt;=up;i++){ if(i==7) continue; tmp=dfs(pos-1,(presum+i)%7,(prenum*10+i)%7,limit&amp;&amp;i==bit[pos]); ans.cnt+=tmp.cnt;ans.cnt%=mod;//不含7的数字的个数 ans.sum+=(tmp.sum+((p[pos]*i)%mod)*tmp.cnt%mod)%mod;ans.sum%=mod;//不含7的数字的和 ans.sqsum+=(tmp.sqsum+((p[pos]*i*2)%mod)*tmp.sum)%mod;ans.sqsum%=mod;//不含7的数字的平方和 ans.sqsum+=((tmp.cnt*p[pos])%mod*p[pos]%mod*i*i%mod);ans.sqsum%=mod; } if(!limit) dp[pos][presum][prenum]=ans; return ans; } ll solve(ll n){ int pos=0; while(n){bit[pos++]=n%10;n/=10;} return dfs(pos-1,0,0,true).sqsum; } int main() { ios::sync_with_stdio(0);cin.tie(0); int T;cin&gt;&gt;T; p[0]=1;for(int i=1;i&lt;20;i++) p[i]=(p[i-1]*10)%mod; for(int i=0;i&lt;20;i++) for(int j=0;j&lt;10;j++) for(int k=0;k&lt;10;k++) dp[i][j][k].cnt=-1; while(T--){ ll l,r;cin&gt;&gt;l&gt;&gt;r; ll ans=solve(r)-solve(l-1); cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl; } } Little Elephant and Elections CodeForces-258B题意：给你一个数字m(7&lt;=m&lt;=1e9)，从中任取7个不同的正整数，求其中一个数的4和7的个数严格大于其他6个数的4和7的个数之和的方法总数。 思路：对于区间[1,1e9]内有多少个数字包含的4和7的个数为x(x=0,1,...,10)个，我们可以利用数位dp简单的处理出来。 至于怎么挑，我们枚举我们选的数字中4和7的个数，然后进行搜索，保证搜剩下的6个数中的4和7的个数之和小于我们选的数即可。 注意，0不计算在内，计算包含的4和7的个数为0的数字个数时要减1。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll mod=1e9+7; ll dp[15][20][20],cnt[20]; int a[15],pos; ll dfs(int pos,int num,int k,bool limit){ if(pos==-1) return num==k; if(!limit&amp;&amp;dp[pos][num][k]!=-1) return dp[pos][num][k]; int up=limit?a[pos]:9; ll ans=0; for(int i=0;i&lt;=up;i++){ ans+=dfs(pos-1,num+(i==4||i==7),k,limit&amp;&amp;i==a[pos]);ans%=mod; } if(!limit) dp[pos][num][k]=ans; return ans; } void solve(ll n){ pos=0;memset(dp,-1,sizeof(dp)); while(n){a[pos++]=n%10;n/=10;} for(int i=0;i&lt;=pos;i++) cnt[i]=dfs(pos-1,0,i,true); cnt[0]--;//除去数字0的贡献 } ll cal(int n,int c){ if(c&lt;=0) return 1; ll ans=0; for(int i=0;i&lt;=n;i++){ if(cnt[i]&lt;=0) continue; cnt[i]--; ans=(ans+(1+cnt[i])*cal(n-i,c-1))%mod; cnt[i]++; } return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); ll m; while(cin&gt;&gt;m){ solve(m); ll ans=0; for(int i=0;i&lt;=pos;i++) ans=(ans+cnt[i]*cal(i-1,6))%mod; cout&lt;&lt;ans&lt;&lt;endl; } } 待补[BZOJ1833][ZJOI2010] count 数字计数 [BZOJ3209]花神的数论题 https://www.cnblogs.com/HDUjackyan/p/9142156.html]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斜率dp]]></title>
    <url>%2F2019%2F12%2F25%2F%E6%96%9C%E7%8E%87dp%2F</url>
    <content type="text"><![CDATA[斜率优化DPNB网友 https://www.cnblogs.com/Paul-Guderian/p/7259491.html 数形结合，利用斜率优化DP转移的复杂度(降一维) 凑成 Y(j)−Y(k)/X(j)−X(k) &lt;(或&gt;) f(i)形式，最后套套模版 一种是维护凸包(理解起来容易，好像是IO选手最爱？)： 取 &lt; 或&lt;= 时，需要维护一个右下凸包 求最小值 取 &gt; 或&gt;= 时，需要维护一个左上凸包 求最大值 我比较容易接受另一种方法：优化式子(利用决策的单调性)，下面的题基本上都是这样做的 题目HDU-3507 一维下凸包题意：要输出N个数字a[N]，输出的时候可以连续连续的输出，每连续输出一串，它的费用是&quot;这串数字和的平方加上一个常数M&quot;。 思路：dp[i]表示输出到i的时候最少的花费，sum[i]表示从a[1]到a[i]的数字和。于是方程就是：dp[i]=min(dp[j]+M+(sum[i]-sum[j])^2)； 很显然这个是一个二维的。题目的数字有500000个，二维铁定超时了。需要斜率优化降成一维的。 #include&lt;bits/stdc++.h&gt; #define fi first #define se second #define pb(x) push_back(x) #define eb(x) emplace_back(x) #define mem(a,b) memset(a,b,sizeof(a)) #define all(x) x.begin(),x.end() #define fastinout ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); using namespace std; typedef unsigned long long ull; typedef long long ll; typedef double db; typedef pair&lt;int,int&gt; pii; typedef pair&lt;ll,ll&gt; pll; typedef vector&lt;int&gt; vi; typedef vector&lt;ll&gt; vl; const double eps=1e-6; const int inf=0x3f3f3f3f; const ll INF=0x3f3f3f3f3f3f3f3f; const int mod=998244353; const int maxn=5e5+5; const int maxk=2005; /***********************************************/ int dp[maxn],sum[maxn],q[maxn],n,m; int getdp(int i,int j){ return dp[j]+(sum[i]-sum[j])*(sum[i]-sum[j])+m; } int getup(int j,int k){ return (dp[j]+sum[j]*sum[j])-(dp[k]+sum[k]*sum[k]); } int getdown(int j,int k){ return (sum[j]-sum[k])*2; } void solve(){ int head=0,tail=0;q[tail++]=0; for(int i=1;i&lt;=n;i++){ while(head+1&lt;tail&amp;&amp;getup(q[head+1],q[head])&lt;=sum[i]*getdown(q[head+1],q[head])) head++; dp[i]=getdp(i,q[head]); while(head+1&lt;tail&amp;&amp;getup(i,q[tail-1])*getdown(q[tail-1],q[tail-2])&lt;=getup(q[tail-1],q[tail-2])*getdown(i,q[tail-1])) tail--; q[tail++]=i; } cout&lt;&lt;dp[n]&lt;&lt;endl; } int main(){ fastinout; while(cin&gt;&gt;n&gt;&gt;m){ sum[0]=0;dp[0]=0; for(int i=1;i&lt;=n;i++){ int t;cin&gt;&gt;t; sum[i]=sum[i-1]+t; } solve(); } } HDU-2829 二维下凸包题意：一条直线上n站,炸铁路使得定义的和最小。 思路：用dp[i][x]表示前i个点，炸掉x条边可以破坏的最大值，答案就是tot-dp[n][m] dp[i][x]=max{dp[j][x-1]+sum[j]*(sum[i]-sum[j])} x-1&lt;j&lt;i 假设在计算i时，k&lt;j,j比k点优,dp[k][x-1]+sum[k]*(sum[i]-sum[k])&lt;=dp[j][x-1]+sum[j]*(sum[i]-sum[j]) 化简得 ((sum[j]*sum[j]-dp[j][x-1])-(sum[k]*sum[k]-dp[k][x-1]))/(sum[j]-sum[k]&lt;=sum[i] yj=sum[j]*sum[j]-dp[j][x-1] xj=sum[j] (yj-yk)/(xj-xk)&lt;=sum[i] 维护下凸包 const int maxn=1005; int dp[maxn][maxn],sum[maxn],a[maxn],q[maxn],n,m,tot; int getdp(int i,int x,int j){ return dp[j][x-1]+sum[j]*(sum[i]-sum[j]); } int getup(int j,int x,int k){ return sum[j]*sum[j]-dp[j][x-1]-(sum[k]*sum[k]-dp[k][x-1]); } int getdown(int j,int k){ return sum[j]-sum[k]; } void solve(){ memset(dp,0,sizeof(dp)); int head=0,tail=0; for(int x=1;x&lt;=m;x++){ head=tail=0;q[tail++]=x; for(int i=x+1;i&lt;=n;i++){ while(head+1&lt;tail&amp;&amp;getup(q[head+1],x,q[head])&lt;=sum[i]*getdown(q[head+1],q[head])) head++; dp[i][x]=getdp(i,x,q[head]); while(head+1&lt;tail&amp;&amp;getup(i,x,q[tail-1])*getdown(q[tail-1],q[tail-2])&lt;=getup(q[tail-1],x,q[tail-2])*getdown(i,q[tail-1])) tail--; q[tail++]=i; } } cout&lt;&lt;tot-dp[n][m]&lt;&lt;endl; } int main() { fastinout; while(cin&gt;&gt;n&gt;&gt;m){ if(n==0&amp;&amp;m==0) break; sum[0]=0;tot=0; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum[i]=sum[i-1]+a[i]; for(int i=n;i&gt;1;i--) tot+=a[i]*sum[i-1]; solve(); } } 玩具装箱 一维下凸包https://loj.ac/problem/10188 题意：太多了，说不清楚，就是一维下凸包 思路：dp[i]=Min{dp[j]+(sum[i]-sum[j]+i-j-L-1)^2} [0&lt;=j&lt;i] 下面就是化简了，L+1-&gt;L sum[i]+i-&gt;sum[i] sum[j]+j-&gt;sum[j] 于是 dp[i]=Min{dp[j]+(sum[i]-(sum[j]+L))^2} [0&lt;=j&lt;i] 假设 k&lt;j 且j比k更优 为什么这样做呢？ 因为 sum[j]&gt;sum[k] 留个疑问 下面解释 由假设可得：dp[j]+(sum[i]-(sum[j]+L))^2 &lt;= dp[k]+(sum[i]-(sum[k]+L))^2 化简之后：(dp[j]+(sum[j]+L)^2)-(dp[k]+(sum[k]+L)^2) &lt;= sum[i]*(sum[j]-sum[k]) 下面要把 (sum[j]-sum[k]) 除到左边去 上面的疑问这里就得到了解答 因为不用变号hhh 接下来就是斜率优化的套路了，getdp、getup、getdown三件套 + solve(优先队列维护右下凸包(直接用上面的就好了) ) 注意爆int const int maxn=5e4+5; ll dp[maxn],sum[maxn],L; int q[maxn],n; ll getdp(int i,int j){ return dp[j]+(sum[i]-sum[j]-L)*(sum[i]-sum[j]-L); } ll getup(int j,int k){ return (dp[j]+(sum[j]+L)*(sum[j]+L))-(dp[k]+(sum[k]+L)*(sum[k]+L)); } ll getdown(int j,int k){ return (sum[j]-sum[k])*2; } void solve(){ int head=0,tail=0;q[tail++]=0; for(int i=1;i&lt;=n;i++){ while(head+1&lt;tail&amp;&amp;getup(q[head+1],q[head])&lt;=sum[i]*getdown(q[head+1],q[head])) head++; dp[i]=getdp(i,q[head]); while(head+1&lt;tail&amp;&amp;getup(i,q[tail-1])*getdown(q[tail-1],q[tail-2])&lt;=getup(q[tail-1],q[tail-2])*getdown(i,q[tail-1])) tail--; q[tail++]=i; } cout&lt;&lt;dp[n]&lt;&lt;endl; } int main(){ fastinout; while(cin&gt;&gt;n&gt;&gt;L){ sum[0]=0;dp[0]=0;L++; for(int i=1;i&lt;=n;i++) cin&gt;&gt;sum[i]; for(int i=1;i&lt;=n;i++) sum[i]+=sum[i-1]; for(int i=1;i&lt;=n;i++) sum[i]+=i; solve(); } } 仓库建设 一维下凸包https://loj.ac/problem/10189 const int maxn=1e6+5; ll dp[maxn]; int q[maxn],n; ll x[maxn],c[maxn],p[maxn],g[maxn]; ll getdp(int i,int j){ return dp[j]+x[i]*(p[i-1]-p[j])+g[i-1]-g[j]+c[i]; } ll getup(int j,int k){ return (dp[j]-g[j])-(dp[k]-g[k]); } ll getdown(int j,int k){ return p[j]-p[k]; } void solve(){ int head=0,tail=0;q[tail++]=0; for(int i=1;i&lt;=n;i++){ while(head+1&lt;tail&amp;&amp;getup(q[head+1],q[head])&lt;=x[i]*getdown(q[head+1],q[head])) head++; dp[i]=getdp(i,q[head]); while(head+1&lt;tail&amp;&amp;getup(i,q[tail-1])*getdown(q[tail-1],q[tail-2])&lt;=getup(q[tail-1],q[tail-2])*getdown(i,q[tail-1])) tail--; q[tail++]=i; } cout&lt;&lt;dp[n]&lt;&lt;endl; } int main(){ fastinout;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i]; for(int i=1;i&lt;=n;i++) g[i]+=g[i-1]-x[i]*p[i]; for(int i=1;i&lt;=n;i++) p[i]+=p[i-1]; solve(); } 土地购买 一维下凸包https://vjudge.net/problem/HYSBZ-1597 题意：买n块矩形土地，同时买几块的花费取决于这几块中的 最大长*最大宽 求最小花费 思路：这种不是序列的dp，往往我们要把数据变成一个有序序列，那怎么sort呢？ 观察一下，设一个长度很大的土地长a宽b，另一块土地长c宽d,且a&gt;b，若c&lt;d那就另一块不会产生贡献，丢掉就行了，否则存下来后面dp。 所以首先按长排个序，然后向上面一样去掉无用的，那剩下来的土地的宽将是降序的，下面dp。 长升序，宽降序。dp[i]=Min{dp[j]+node[i].a*node[j+1].b} 设j&gt;k且j比k优 列式移项化简得到：(dp[j]-dp[k])/(node[k+1].b-node[j+1].b)&lt;=node[i].a; 注意分子分母的区别，但是不影响，依然维护一个下凸包 const int maxn=5e4+5; struct Node{ ll a,b; bool operator&lt; (const Node&amp; y)const {return a==y.a?b&lt;y.b:a&lt;y.a;} }node[maxn]; ll dp[maxn];int q[maxn],n; ll getdp(int i,int j){ return dp[j]+node[i].a*node[j+1].b; } ll getup(int j,int k){ return dp[j]-dp[k]; } ll getdown(int j,int k){ return node[k+1].b-node[j+1].b; } void solve(){ int head=0,tail=0;q[tail++]=0; for(int i=1;i&lt;=n;i++){ while(head+1&lt;tail&amp;&amp;getup(q[head+1],q[head])&lt;=node[i].a*getdown(q[head+1],q[head])) head++; dp[i]=getdp(i,q[head]); while(head+1&lt;tail&amp;&amp;getup(i,q[tail-1])*getdown(q[tail-1],q[tail-2])&lt;=getup(q[tail-1],q[tail-2])*getdown(i,q[tail-1])) tail--; q[tail++]=i; } cout&lt;&lt;dp[n]&lt;&lt;endl; } int main() { fastinout;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;node[i].a&gt;&gt;node[i].b; sort(node+1,node+1+n);int t=0; for(int i=1;i&lt;=n;i++){ while(t&amp;&amp;node[t].b&lt;=node[i].b)t--;node[++t]=node[i]; }n=t; solve(); } 特别行动队 一维上凸包题意：n个士兵分为若干组，使得战斗力总和最大。每组战斗力 X = a*x*x + b*x + c(其中x是这组士兵战斗力之和，X是定义的战斗力) 思路：n-&gt;1e6 显然斜率dp。dp[i]-&gt;前i个人组成的军队的最大战斗力，dp[i]=Max{dp[j]+a*x*x+b*x+c};其中x=sum[i]-sum[j] 假设 j&gt;k 且 j优于k 那么：dp[j]+a*(sum[i]-sum[j])*(sum[i]-sum[j])+b*(sum[i]-sum[j])+c &gt;= dp[k]+a*(sum[i]-sum[k])*(sum[i]-sum[k])+b*(sum[i]-sum[k])+c 化简移项：(dp[j]+a*sum[j]*sum[j]-b*sum[j])-(dp[k]+a*sum[k]*sum[k]-b*sum[k]) &gt;= 2*a*sum[i]*(sum[j]-sum[k]) 然后就是单调队列优化了 做了这几题也发现了一个规律：在入队出队的过程中符号与上面的式子相同 如本题的 &gt;= const int maxn=1e5+5; ll dp[maxn],sum[maxn],x[maxn],a,b,c; int q[maxn],n; ll getdp(int i,int j){ return dp[j]+a*(sum[i]-sum[j])*(sum[i]-sum[j])+b*(sum[i]-sum[j])+c; } ll getup(int j,int k){ return (dp[j]+a*sum[j]*sum[j]-b*sum[j])-(dp[k]+a*sum[k]*sum[k]-b*sum[k]); } ll getdown(int j,int k){ return sum[j]-sum[k]; } void solve(){ int head=0,tail=0;q[tail++]=0; for(int i=1;i&lt;=n;i++){ while(head+1&lt;tail&amp;&amp;getup(q[head+1],q[head])&gt;=2*a*sum[i]*getdown(q[head+1],q[head])) head++; dp[i]=getdp(i,q[head]); while(head+1&lt;tail&amp;&amp;getup(i,q[tail-1])*getdown(q[tail-1],q[tail-2])&gt;=getup(q[tail-1],q[tail-2])*getdown(i,q[tail-1])) tail--; q[tail++]=i; } cout&lt;&lt;dp[n]&lt;&lt;endl; } int main() { fastinout;cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]; for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+x[i]; solve(); } 待补防御准备 序列分割 BZOJ-3437 BZOJ-4518]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典树与01字典树]]></title>
    <url>%2F2019%2F12%2F25%2F%E5%AD%97%E5%85%B8%E6%A0%91%E4%B8%8E01%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[字典树与01字典树字典树Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。 典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。 Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。 字典树的构建 假设有b，abc，abd，bcd，abcd，efg，hii这6个单词，我们构建的树就是如上图这样的。 我们可以看到，trie树每一层的节点数是26^i级别的。所以为了节省空间。 我们用动态链表，或者用数组来模拟动态。空间的花费，不会超过单词数×单词长度。 字典树的查询顺着字典树查就完事儿了。 模版： const int maxnode = 4e5+100; const int sigma_size = 26; struct Trie { int ch[maxnode][sigma_size]; int val[maxnode]; int sz;//节点总数 Trie(){sz=1;memset(ch[0],0,sizeof(ch[0]));}//初始时只有根节点 int idx(char c) {return c-&apos;a&apos;;}//字符c的编号 void init(){ memset(ch,0,sizeof(ch)); memset(val,0,sizeof(val)); } //插入s，附加信息为v。注意v必须为非0，因为0代表&quot;本节点不是单词节点&quot; void insert(char *s,int v){ int u = 0, n = strlen(s); for(int i = 0; i &lt; n; ++i){ int c = idx(s[i]); if(!ch[u][c]){节点不存在 memset(ch[sz],0,sizeof(ch[sz])); val[sz] = 0;//中间节点附加信息为0 ch[u][c] = sz++;//新建节点 } u = ch[u][c];//往下走 } val[u] = v;//字符串的最后一个字符的附加信息为v } int query(char *s,int t){ int sum = 0; int u = 0,n = strlen(s); for(int i = 0; i &lt; n; ++i){ int c = idx(s[i]); if(ch[u][c]){ if(val[ch[u][c]]) sum = (sum+ans[i+t+1]) % mod; } else return sum; u = ch[u][c]; } return sum; } }; 01字典树01字典树在异或问题的查询上十分高效。 01字典树是按位插入和查询的。因为如果一个数，它的高位值较大，那么这个数的值较大。 所以我们插入和查询时是从最高位开始进行的。可以开一个辅助数组val来记录原数值。 对于区间异或问题，因为X^X=0，0^Y=0,所以[l,r]=[1,r]^[1,l-1] ,O(n)的算一遍前缀异或和， 并把每一项插入01字典树，插入之前query一下以i结尾的区间[1,i]的最大异或值。 注意一开始应该插入一个0进去，不然树就是空的(好像不插也没什么关系，NB网友们都插了我也插1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 模版： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1005; const int maxnode=maxn*32; const int sigama=32; struct Trie&#123; ll next[maxnode][2],val[maxnode]; int cnt[maxnode],tot,root; int newnode()&#123; next[tot][0]=next[tot][1]=-1; val[tot++]=0;return tot-1; &#125; void init()&#123; for(int i=0;i&lt;=tot;i++)&#123; val[i]=cnt[i]=0; next[i][0]=next[i][1]=-1; &#125; tot=0;root=newnode(); &#125; void ins(ll x)&#123; int now=root; for(int i=sigama;i&gt;=0;i--)&#123; int id=((x&gt;&gt;i)&amp;1); if(next[now][id]==-1) next[now][id]=newnode(); now=next[now][id];cnt[now]++; &#125; val[now]=x; &#125; void del(ll x)&#123; int now=root; for(int i=sigama;i&gt;=0;i--)&#123; int id=((x&gt;&gt;i)&amp;1); cnt[next[now][id]]--; now=next[now][id]; &#125; &#125; ll query(ll x)&#123;//查询最大异或值 int now=root; for(int i=sigama;i&gt;=0;i--)&#123; int id=((x&gt;&gt;i)&amp;1); if(next[now][id^1]!=-1)&#123; if(cnt[next[now][id^1]]) now=next[now][id^1]; else now=next[now][id]; &#125; else&#123; if(cnt[next[now][id]]) now=next[now][id]; else now=next[now][id^1]; &#125; &#125; return val[now]^x; &#125; &#125;;##### HDU-4825 字典树裸题 题意：给一串n长数组，m次询问，每次询问一个数字t和数组中的哪一个异或值最大。 思路：拿数组建01字典树，每次在树上查询即可 注意32位的要开ll 31以下可以不开；忘了改数组大小，返回TLE~ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+5; const int maxnode=maxn*32; const int sigama=32; struct Trie{ ll next[maxnode][2],val[maxnode]; int tot,root; int newnode(){ next[tot][0]=next[tot][1]=-1; val[tot++]=0;return tot-1; } void init(){ for(int i=0;i&lt;=tot;i++){ val[i]=0; next[i][0]=next[i][1]=-1; } tot=0;root=newnode(); } void ins(ll x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id]==-1) next[now][id]=newnode(); now=next[now][id]; } val[now]=x; } ll query(ll x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id^1]!=-1) now=next[now][id^1]; else now=next[now][id]; } return val[now]; } }Ta; int main() { ios::sync_with_stdio(0);cin.tie(0); int T;cin&gt;&gt;T;int ca=1; while(T--){ int n,m;cin&gt;&gt;n&gt;&gt;m; Ta.init(); for(int i=0;i&lt;n;i++){ ll t;cin&gt;&gt;t;Ta.ins(t); } cout&lt;&lt;&quot;Case #&quot;&lt;&lt;ca++&lt;&lt;&quot;:&quot;&lt;&lt;endl; while(m--){ ll t;cin&gt;&gt;t;cout&lt;&lt;Ta.query(t)&lt;&lt;endl; } } } CF-706D Vasiliy’s Multiset题意：多重集合可以插入数字也可以删除，还可以查询与 x 异或值最大的数 思路：01字典树模版，需要添加删除操作 注意初始时已包含了0！注意把换行符吃掉！ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+5; const int maxnode=maxn*32; const int sigama=32; struct Trie{ ll next[maxnode][2],val[maxnode]; int cnt[maxnode],tot,root; int newnode(){ next[tot][0]=next[tot][1]=-1; val[tot++]=0;return tot-1; } void init(){ for(int i=0;i&lt;=tot;i++){ val[i]=cnt[i]=0; next[i][0]=next[i][1]=-1; } tot=0;root=newnode(); } void ins(ll x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id]==-1) next[now][id]=newnode(); now=next[now][id];cnt[now]++; } val[now]=x; } void del(ll x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); cnt[next[now][id]]--; now=next[now][id]; } } ll query(ll x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id^1]!=-1){ if(cnt[next[now][id^1]]) now=next[now][id^1]; else now=next[now][id]; } else{ if(cnt[next[now][id]]) now=next[now][id]; else now=next[now][id^1]; } } return val[now]^x; } }Ta; int main() { int q;scanf(&quot;%d&quot;,&amp;q);Ta.init();Ta.ins(0); while(q--){ getchar(); char ch;ll x;scanf(&quot;%c %lld&quot;,&amp;ch,&amp;x); if(ch==&apos;+&apos;) Ta.ins(x); else if(ch==&apos;-&apos;) Ta.del(x); else cout&lt;&lt;Ta.query(x)&lt;&lt;endl; } } HDU-5536 Chip Factory题意&amp;思路：带有删除的01字典树，先把每个元素插入字典树中，然后O(n2)的复杂度枚举两个相加， 并且把它们从字典树中暂时去掉，然后查询，然后取最大值 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1005; const int maxnode=maxn*32; const int sigama=32; struct Trie{ ll next[maxnode][2],val[maxnode]; int cnt[maxnode],tot,root; int newnode(){ next[tot][0]=next[tot][1]=-1; val[tot++]=0;return tot-1; } void init(){ for(int i=0;i&lt;=tot;i++){ val[i]=cnt[i]=0; next[i][0]=next[i][1]=-1; } tot=0;root=newnode(); } void ins(ll x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id]==-1) next[now][id]=newnode(); now=next[now][id];cnt[now]++; } val[now]=x; } void del(ll x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); cnt[next[now][id]]--; now=next[now][id]; } } ll query(ll x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id^1]!=-1){ if(cnt[next[now][id^1]]) now=next[now][id^1]; else now=next[now][id]; } else{ if(cnt[next[now][id]]) now=next[now][id]; else now=next[now][id^1]; } } return val[now]^x; } }Ta; int a[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int T;cin&gt;&gt;T; while(T--){ int n;cin&gt;&gt;n;ll ans=0;Ta.init(); for(int i=0;i&lt;n;i++) {cin&gt;&gt;a[i];Ta.ins(a[i]);} for(int i=0;i&lt;n;i++){ for(int j=i+1;j&lt;n;j++){ Ta.del(a[i]);Ta.del(a[j]); ans=max(ans,Ta.query(a[i]+a[j])); Ta.ins(a[i]);Ta.ins(a[j]); } } cout&lt;&lt;ans&lt;&lt;endl; } } HYSBZ-4260 Codechef REBXOR题意：让你在长为n的数组里找两个不相交的连续区间，使得两个区间分别的异或和求和之后最大 思路：反正看到连续区间异或和最大，我只会一个套路，就是01字典树了， 先正着来一遍前缀异或和，同时dp[i]表示到i为止，前面的区间异或和最大是多少，然后倒着来一遍后缀异或和， ans=max(ans,query(suf[i])+dp[i−1])即可,并且这题不会爆int，其实好像上面的题也不会爆int，但是这题全开LL会MLE #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e5+5; const int maxnode=maxn*32; const int sigama=32; struct Trie{ int next[maxnode][2],val[maxnode]; int tot,root; int newnode(){ next[tot][0]=next[tot][1]=-1; val[tot++]=0;return tot-1; } void init(){ for(int i=0;i&lt;=tot;i++){ val[i]=0; next[i][0]=next[i][1]=-1; } tot=0;root=newnode(); } void ins(int x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id]==-1) next[now][id]=newnode(); now=next[now][id]; } val[now]=x; } int query(int x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id^1]!=-1) now=next[now][id^1]; else now=next[now][id]; } return val[now]^x; } }Ta; int a[maxn],pre[maxn],suf[maxn],dp[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int n,ans=0;cin&gt;&gt;n;pre[0]=suf[n+1]=0; for(int i=1;i&lt;=n;i++) {cin&gt;&gt;a[i];dp[i]=0;} for(int i=1;i&lt;=n;i++) pre[i]=pre[i-1]^a[i]; for(int i=n;i&gt;=1;i--) suf[i]=suf[i+1]^a[i]; Ta.init();Ta.ins(pre[0]); for(int i=1;i&lt;=n;i++){ dp[i]=max(dp[i-1],Ta.query(pre[i])); Ta.ins(pre[i]); } Ta.init();Ta.ins(suf[n+1]); for(int i=n;i&gt;=1;i--){ ans=max(ans,Ta.query(suf[i])+dp[i-1]); Ta.ins(suf[i]); } cout&lt;&lt;ans&lt;&lt;endl; } POJ-3764 The xor-longest Path题意：给定一棵 n 个点的带权树，定义树上一条路径的长度为路径上所有边权的异或和，求树上最长路径的长度。 思路：这题是树上的最大异或和路径，但是其实也是一样的套路，在dfs的时候，把从根到当前节点的异或和， 去01字典树里查询，找到一条路径和当前路径异或和最大，这找到的绝对是两条相连的， 因为你往01字典树里扔的，就是从根到当前节点的异或和。 不知道vector为什么不给为过 又T又WA AC代码： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; using namespace std; const int maxn=1e5+5; const int maxnode=maxn*32; const int sigama=32; struct Trie{ int next[maxnode][2],val[maxnode]; int tot,root; inline int newnode(){ next[tot][0]=next[tot][1]=-1; val[tot++]=0;return tot-1; } inline void init(){ for(int i=0;i&lt;=tot;i++){ val[i]=0; next[i][0]=next[i][1]=-1; } tot=0;root=newnode(); } inline void ins(int x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id]==-1) next[now][id]=newnode(); now=next[now][id]; } val[now]=x; } inline int query(int x){ int now=root; for(int i=sigama;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id^1]!=-1) now=next[now][id^1]; else now=next[now][id]; } return val[now]^x; } }Ta; struct Edge{ int v,w,next; }edge[maxn*2]; int head[maxn],tot,ans; inline void add(int u,int v,int w){ edge[tot].v=v;edge[tot].w=w;edge[tot].next=head[u];head[u]=tot++; } inline void dfs(int u,int fa,int c){ Ta.ins(c); for(int i=head[u];~i;i=edge[i].next){ int v=edge[i].v,w=edge[i].w; if(v==fa) continue; ans=max(ans,Ta.query(c^w)); dfs(v,u,c^w); } } inline int read() { int x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;){if(ch==&apos;-&apos;)f=-1;ch=getchar();} while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;) x=x*10+ch-48,ch=getchar(); return x*f; } int main() { int n; while(~scanf(&quot;%d&quot;,&amp;n)){ ans=0;Ta.init();tot=0; memset(head,-1,sizeof(head)); for(int i=0;i&lt;n-1;i++){ int u,v,w;u=read();v=read();w=read(); //cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; //scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w);add(v,u,w); } dfs(0,-1,0); printf(&quot;%d\n&quot;,ans); } } Vector WA了： int ans=0; struct Edge{int v,w;}; vector&lt;Edge&gt; G[maxn]; void dfs(int u,int fa,int c){ Ta.ins(c); for(int i=0;i&lt;G[u].size();i++){ int v=G[u][i].v,w=G[u][i].w; if(v==fa) continue; ans=max(ans,Ta.query(c^w)); dfs(v,u,c^w); } } int main() { int n; while(~scanf(&quot;%d&quot;,&amp;n)){ ans=0;Ta.init(); for(int i=0;i&lt;n;i++) G[i].clear(); for(int i=0;i&lt;n-1;i++){ int u,v,w;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); G[u].push_back({v,w}); G[v].push_back({u,w}); } dfs(0,-1,0); cout&lt;&lt;ans&lt;&lt;endl; } } HDU-6625 three arrays题意：给两个长度都为n的数组，可以改变数字的位置，用两个数组对应位置异或得到一个新的数组并使其字典序最小 思路：把两个数组放到两棵01字典树上，从去重后的a数组中取出一个u 放到b树中去匹配到v ,再把v放到a树中去匹配u&apos;, 若u与u&apos;相同，即u与v相互匹配，那么必定为答案，否则再把u&apos;拿到b树中去匹配，如此反复。 复杂度:O(n*logv*logv) #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+5; const int maxnode=maxn*30; struct Trie{ int next[maxnode][2]; int cnt[maxnode]; int root,tot,maxlv; int newnode(){ next[tot][0]=next[tot][1]=-1; cnt[tot++]=0;return tot-1; } void init(int n){ maxlv=n;tot=0;root=newnode(); } void ins(int x){ int now=root; for(int i=maxlv;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(next[now][id]==-1) next[now][id]=newnode(); now=next[now][id]; cnt[now]++; } } void del(int x){ int now=root; for(int i=maxlv;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); now=next[now][id]; assert(now);cnt[now]--;//assert(now)-&gt; if(now&lt;=0) return; } } int match(int x){ int now=root,res=0; for(int i=maxlv;i&gt;=0;i--){ int id=((x&gt;&gt;i)&amp;1); if(cnt[next[now][id]]==0) id^=1; res |=(id&lt;&lt;i);//将res第i位置位(id=1时置1 否则不变) now=next[now][id]; } return res; } }Ta,Tb; vector&lt;int&gt; ans; multiset&lt;int&gt; sa;//将a去重 int main() { ios::sync_with_stdio(0);cin.tie(0); int T;cin&gt;&gt;T; while(T--){ int n;cin&gt;&gt;n;Ta.init(29);Tb.init(29);ans.clear(); for(int i=0;i&lt;n;i++){ int t;cin&gt;&gt;t;Ta.ins(t);sa.insert(t); } for(int i=0;i&lt;n;i++){ int t;cin&gt;&gt;t;Tb.ins(t); } int u=*sa.begin(),v=Tb.match(u);//从a里取一个数u 在b里匹配到v for(int i=0;i&lt;n;){ int t=Ta.match(v);//把在b里匹配到的数再拿到a里去匹配 if(t!=u) v=Tb.match(u=t);//如果不能相互匹配，再拿把在a里匹配到的数再拿到b里去匹配 else{ //如此反复找到两两配对的，存进答案，再把两棵树里的数字删掉 ans.push_back(u^v); sa.erase(sa.find(u)); Ta.del(u);Tb.del(v); u=*sa.begin();v=Tb.match(u); i++; } } sort(ans.begin(),ans.end()); for(int i=0;i&lt;n-1;i++) cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;ans[n-1]&lt;&lt;endl; } }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化并查集]]></title>
    <url>%2F2019%2F12%2F25%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[可持久化并查集可持久化并查集 = 可持久化数组 + 并查集 = 主席树 + 并查集 以一个题目引入：n个集合m次操作(合并a,b所在集合、回到第k次操作之后的状态、询问a,b是否属于同一集合) 询问历史版本需要上主席树，集合操作需要并查集 ，结合起来就是可持久化并查集 主席树中维护每个节点的父亲节点，并查集的合并只能按秩合并(不能路径压缩,可以构造数据让路径压缩爆掉-网友说的*_*) 先建一棵主席树，权值为fa[i]=i 模版//P3402 【模板】可持久化并查集 https://www.luogu.org/problem/P3402 //1.a b 合并a,b所在集合 //2.k 回到第k次操作之后的状态(查询算作操作) //3.a b 询问a,b是否属于同一集合，是则输出1否则输出0 const int maxn=2e5+5; int n,m,cnt,last; int fa[maxn*40],ls[maxn*40],rs[maxn*40],deep[maxn*40],root[maxn*40]; struct Persistant_Union_Set{ #define mid ((l+r)&gt;&gt;1) #define lson ls[rt],l,mid #define rson rs[rt],mid+1,r inline void build(int &amp;rt,int l,int r){ if(!rt) rt=++cnt; if(l==r){fa[rt]=l;return;} build(lson);build(rson); } inline void merge(int last,int &amp;rt,int l,int r,int pos,int Fa){ rt=++cnt;ls[rt]=ls[last];rs[rt]=rs[last]; if(l==r){ fa[rt]=Fa;deep[rt]=deep[last];return; } if(pos&lt;=mid) merge(ls[last],lson,pos,Fa); else merge(rs[last],rson,pos,Fa); } inline void update(int rt,int l,int r,int pos){ if(l==r){deep[rt]++;return;} if(pos&lt;=mid) update(lson,pos); else update(rson,pos); } inline int query(int rt,int l,int r,int pos){ if(l==r) return rt; if(pos&lt;=mid) return query(lson,pos); else return query(rson,pos); } inline int find(int rt,int pos){ int now=query(rt,1,n,pos); if(fa[now]==pos) return now; return find(rt,fa[now]); } }S; int main() { fastinout;cin&gt;&gt;n&gt;&gt;m;S.build(root[0],1,n); for(int i=1;i&lt;=m;i++){ int op,x,y;cin&gt;&gt;op&gt;&gt;x; if(op==1){ cin&gt;&gt;y;root[i]=root[i-1]; int posx=S.find(root[i],x),posy=S.find(root[i],y); if(fa[posx]!=fa[posy]){ if(deep[posx]&gt;deep[posy]) swap(posx,posy); S.merge(root[i-1],root[i],1,n,fa[posx],fa[posy]); if(deep[posx]==deep[posy]) S.update(root[i],1,n,fa[posy]); } } else if(op==2) root[i]=root[x]; else if(op==3){ cin&gt;&gt;y;root[i]=root[i-1]; int posx=S.find(root[i],x),posy=S.find(root[i],y); if(fa[posx]==fa[posy]) cout&lt;&lt;1&lt;&lt;endl; else cout&lt;&lt;0&lt;&lt;endl; } } }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化线段树 & 数组]]></title>
    <url>%2F2019%2F12%2F25%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[可持久化线段树(主席树)学习主席树之前先要学习权值线段树。 什么是权值线段树呢？就是多个&quot;桶&quot;组成的线段树，节点维护区间范围内元素的个数， 要查询一棵树的第k大首先根据区间内元素的个数判定查询往左走还是往右走。 但是权值线段树只能查全体元素的第k大，而不能查询区间第k大 那什么是主席树呢？就是多棵权值线段树的组合，每插入一个新的元素就保留一个历史版本的权值线段树存储[1,i]的信息， 于是主席树就可以查询区间第k大了 比如要查询[l,r]区间的第k大，只要在查询过程中将第r棵权值线段树的信息减去第l-1棵权值线段树的信息即可 但这样建树是不是会内存爆炸呢？是的。但是我们可以发现，每次添加一个元素只会改变树中一条链的信息，其他信息继承上一版本的就可以了，下面偷来的图就是一棵主席树 模版//POJ-2104 主席树模版-求任意区间第k大 #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int maxn=1e5+5; int n,m,cnt,rt[maxn],a[maxn]; vector&lt;int&gt; v; struct node{int l,r,sum;}T[maxn*40]; inline int getid(int x){ return lower_bound(v.begin(),v.end(),x)-v.begin()+1; } inline void Build(int &amp;rt,int l,int r){ rt=++cnt; int mid=(l+r)&gt;&gt;1; if(l==r) return; Build(T[rt].l,l,mid); Build(T[rt].r,mid+1,r); } inline void update(int &amp;rt,int last,int l,int r,int pos){ rt=++cnt;T[rt]=T[last];T[rt].sum++; if(l==r) return; int m=(l+r)&gt;&gt;1; if(m&gt;=pos) update(T[rt].l,T[last].l,l,m,pos); else update(T[rt].r,T[last].r,m+1,r,pos); } inline int query(int rt1,int rt2,int l,int r,int k){ if(l==r) return l; int m=(l+r)&gt;&gt;1; int sum=T[T[rt1].l].sum-T[T[rt2].l].sum; if(sum&gt;=k) return query(T[rt1].l,T[rt2].l,l,m,k); else return query(T[rt1].r,T[rt2].r,m+1,r,k-sum); } inline void init(){ cnt=0;Build(rt[0],1,n); for(int i=1;i&lt;=n;i++) update(rt[i],rt[i-1],1,n,getid(a[i])); } int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],v.push_back(a[i]); sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end()); init(); for(int i=1;i&lt;=m;i++){ int x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k; printf(&quot;%d\n&quot;,v[query(rt[y],rt[x-1],1,n,k)-1]); } } 可持久化数组可持久化数组支持单点修改和单点查询。 单点修改和单点查询这种东西不是直接数组就能解决了吗？干嘛要可持久化？ 因为要用到历史版本啊！ 模版//https://www.luogu.org/problem/P3919 #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN=1e6+2333; int n,m; int a[MAXN]; struct Persistable_Segment_Tree{ struct Node{ int val,L,R; }t[MAXN*20]; int cnt,rt[MAXN*20]; void build_tree(int &amp;root,int l,int r){ root=++cnt; if (l==r) return (void)(t[root].val=a[l]); int mid=l+r&gt;&gt;1; build_tree(t[root].L,l,mid); build_tree(t[root].R,mid+1,r); } void update(int &amp;root,int las,int l,int r,int q,int opt){ root=++cnt; t[root]=t[las]; if (l==r) return (void)(t[root].val=opt); int mid=l+r&gt;&gt;1; if (q&lt;=mid) update(t[root].L,t[las].L,l,mid,q,opt); else update(t[root].R,t[las].R,mid+1,r,q,opt); } int query(int root,int l,int r,int q){ if (l==r) return t[root].val; int mid=l+r&gt;&gt;1; if (q&lt;=mid) return query(t[root].L,l,mid,q); else return query(t[root].R,mid+1,r,q); } }T; int read(){ int x=0,f=1; char ch=getchar(); while (!isdigit(ch)){ if (ch==&apos;-&apos;) f=-1; ch=getchar(); } while (isdigit(ch)) x=x*10+ch-&apos;0&apos;,ch=getchar(); return x*f; } int main(){ n=read(),m=read(); for (int i=1;i&lt;=n;i++) a[i]=read(); T.cnt=0,T.build_tree(T.rt[0],1,n); int x,opt,y,z; for (int i=1;i&lt;=m;i++){ x=read(),opt=read(); if (opt==1){ y=read(),z=read(); T.update(T.rt[i],T.rt[x],1,n,y,z); } else { y=read(); T.rt[i]=T.rt[x]; printf(&quot;%d\n&quot;,T.query(T.rt[x],1,n,y)); } } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化01字典树]]></title>
    <url>%2F2019%2F12%2F25%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[可持久化01字典树(最大异或和)From https://blog.csdn.net/calabash_boy/article/details/77806849 可持久化01字典树：可以理解成在字典树的每个节点上弄了个前缀和一样的东西吧，重点在空间复用。 每个字典树节点增加sum域，记录前边数字中有多少个数字走到这个节点。 每次加入一个新的数字，都开一个“全新”的字典树，把每个树的根都记下来。 这个新的字典树包括了之前加入的所有数字，也包括当前数字，但是这样超级浪费空间，怎么办呢？ 我们知道 加入一个新的数字，和上一棵树最多只会有32个点不同。 那么新树和上一个树不变的点就直接用上一棵树的就行了（两个树相同的部分重合起来，不需要新开点来存了），把新的点的sum给更新了就行了。 查询：查询区间[l,r]时，同时查root[l-1]和root[r]这两棵树，同时往下走，如果sum不同， 说明[l,r]区间内的某个数字出现在这条链路上，那么就可以往这个方向走。 然后取抑或最大操作和普通01字典树无异，都是贪心的高位能取不同就不同， 否则取相同（相同和不同必然可以取一个，要不然岂不是说明这个区间内没有数字了。。。） 模版： /* 给出一个长度为N的正整数数组A，再给出Q个查询，每个查询包括3个数，L, R, X (L &lt;= R)。 求A[L] 至 A[R] 这R - L + 1个数中，与X 进行异或运算(Xor)，得到的最大值是多少？ */ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+5; const int sigama=31; struct Trie_Endurance{ //next每个节点指向的两个节点的位置，sum每个节点出现的次数，root每棵01Trie根节点的位置 int next[maxn&lt;&lt;5][2],sum[maxn&lt;&lt;5],root[maxn],sz=0; void init(){ for(int i=0;i&lt;sz;i++) next[i][0]=next[i][1]=sum[i]=root[i]=0; sz=0; } void insert(int val,int &amp;x,int pre){ x=++sz;int now=x;//新建一个版本 for(int i=sigama;i&gt;=0;i--){ //当前版本的Trie节点指向前一个Trie版本的节点，复制，节省空间 next[now][0]=next[pre][0];next[now][1]=next[pre][1]; sum[now]=sum[pre]+1; int id=((val&gt;&gt;i)&amp;1); next[now][id]=++sz;//新开的节点 now=next[now][id];pre=next[pre][id]; } sum[now]=sum[pre]+1; } int query(int val,int x,int y){ int ans=0; for(int i=sigama;i&gt;=0;i--){ int id=((val&gt;&gt;i)&amp;1); if(sum[next[y][id^1]]-sum[next[x][id^1]]&gt;0){//说明比之前的版本大 ans|=(1&lt;&lt;i);x=next[x][id^1];y=next[y][id^1];//当前位两者异或一定为1,找最大值嘛 }//实际上 ans|=(1&lt;&lt;i) &lt;=&gt; ans+=(1&lt;&lt;i) else{ x=next[x][id];y=next[y][id]; } } return ans; } }Ta; int main() { int n,m,x;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){//以元素下标作为版本号 scanf(&quot;%d&quot;,&amp;x);Ta.insert(x,Ta.root[i],Ta.root[i-1]); } while(m--){ int l,r;scanf(&quot;%d%d%d&quot;,&amp;x,&amp;l,&amp;r); l++;r++; printf(&quot;%d\n&quot;,Ta.query(x,Ta.root[l-1],Ta.root[r])); } } 题目HYSBZ-3261 最大异或和题意：给定一个非负整数序列{a}，初始长度为N。 有M个操作，有以下两种操作类型： 1.A x：添加操作，表示在序列末尾添加一个数x，序列的长度N+1。 2.Q l r x：询问操作，你需要找到一个位置p，满足l&lt;=p&lt;=r，使得： a[p]^a[p+1]^.^a[N]^x 最大，输出最大是多少。 思路：可持久化01字典树中维护a[1]^a[2]^..^a[i]; 查询时 传入a[1]^[2]^...a[n]^x即可 得到[l,r]中p-&gt;a[p]^a[p+1]^.^a[N]^x 最大 因为(a[1]^a[2]^..^a[i])^(a[1]^[2]^...a[n]^x)=(a[i+1]^[i+2]^...a[n]^x) #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=6e5+5;//n+m const int sigama=23; struct Trie_Endurance{ int next[maxn&lt;&lt;5][2],sum[maxn&lt;&lt;5],root[maxn],tot; void init(){ for(int i=0;i&lt;=tot;i++) next[i][0]=next[i][1]=sum[i]=root[i]=0; tot=0; } void insert(int val,int &amp;x,int pre){ x=++tot;int now=x; for(int i=sigama;i&gt;=0;i--){ next[now][0]=next[pre][0];next[now][1]=next[pre][1]; sum[now]=sum[pre]+1; int id=((val&gt;&gt;i)&amp;1); next[now][id]=++tot; now=next[now][id];pre=next[pre][id]; } sum[now]=sum[pre]+1; } int query(int val,int x,int y){ int ans=0; for(int i=sigama;i&gt;=0;i--){ int id=((val&gt;&gt;i)&amp;1); if(sum[next[y][id^1]]-sum[next[x][id^1]]&gt;0){ ans|=(1&lt;&lt;i);x=next[x][id^1];y=next[y][id^1]; } else{ x=next[x][id];y=next[y][id]; } } return ans; } }Ta; int a[maxn]; int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);Ta.init(); Ta.insert(a[1],Ta.root[1],Ta.root[1]); int now=2; for(;now&lt;=n+1;now++){ int t;scanf(&quot;%d&quot;,&amp;t);a[now]=a[now-1]^t; Ta.insert(a[now],Ta.root[now],Ta.root[now-1]); } now=n+1; while(m--){ char op[2];scanf(&quot;%s&quot;,op); if(op[0]==&apos;A&apos;){ int t;scanf(&quot;%d&quot;,&amp;t);a[now]=a[now-1]^t; Ta.insert(a[now],Ta.root[now],Ta.root[now-1]); } else{ int l,r,x;scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x); printf(&quot;%d\n&quot;,Ta.query(a[now]^x,Ta.root[l-1],Ta.root[r])); } } } HDU-6191 dfs序 + 可持久化01字典树题意：给你一棵树，每个点都有权值，q次询问，每次询问给你u和x，问以u为根的子树与x的异或值最大为多少 思路：按照dfs序建可持久化字典树，以u为根的子树的字典树=以u为根的子树的最后一个节点的字典树-u按照dfs的前一个节点的字典树。然后就可以在线查询了。 下面模版来自CSL 我用之前的模版不知道为啥会T *.* #include&lt;bits/stdc++.h&gt; #define clr(a,x) memset(a,x,sizeof(a)) using namespace std; typedef long long ll; const int maxn=1e5+5; const int sigama=30; struct Trie_Endurance{ int next[maxn&lt;&lt;5][2],sum[maxn&lt;&lt;5],root[maxn],tot; inline int newnode(){ clr(next[tot],0);sum[tot]=0;return tot++; } inline void init(){ tot=0;clr(root,0);root[0]=newnode(); } inline void insert(int val,int now,int pre){ root[now]=newnode(); int u=root[now],v=root[pre]; for(int i=sigama;i&gt;=0;i--){ int id=((val&gt;&gt;i)&amp;1); sum[u]=sum[v]+1; next[u][id]=newnode(); next[u][id^1]=next[v][id^1]; u=next[u][id];v=next[v][id]; } sum[u]=sum[v]+1; } inline int query(int val,int x,int y){//返回区间[x,y]中与x异或值最大的那个值 ans∈[x,y] int ans=0,u=root[x],v=root[y]; for(int i=sigama;i&gt;=0;i--){ int id=((val&gt;&gt;i)&amp;1); int t=sum[next[v][id^1]]-sum[next[u][id^1]]; if(t&gt;0) id^=1;ans |=id&lt;&lt;i; u=next[u][id];v=next[v][id]; } return ans; } }Ta; int n,q,dfn,a[maxn],in[maxn],out[maxn]; vector&lt;int&gt; G[maxn]; inline void dfs(int u){ Ta.insert(a[u],dfn+1,dfn);in[u]=++dfn; for(auto &amp;v:G[u]) dfs(v); out[u]=dfn; } int main() { while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;q)){ Ta.init();dfn=0; for(int i=1;i&lt;=n;i++) G[i].clear(); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=2;i&lt;=n;i++){ int v;scanf(&quot;%d&quot;,&amp;v); G[v].push_back(i); } dfs(1); while(q--){ int u,x;scanf(&quot;%d%d&quot;,&amp;u,&amp;x); int l=in[u],r=out[u]; printf(&quot;%d\n&quot;,x^Ta.query(x,l-1,r)); } } } 之前的模版TLE了: #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+5; const int sigama=30; struct Trie_Endurance{ int next[maxn&lt;&lt;5][2],sum[maxn&lt;&lt;5],root[maxn],tot; void init(){ for(int i=0;i&lt;=tot;i++) next[i][0]=next[i][1]=sum[i]=root[i]=0; tot=0; } void insert(int val,int &amp;x,int pre){ x=++tot;int now=x; for(int i=sigama;i&gt;=0;i--){ next[now][0]=next[pre][0];next[now][1]=next[pre][1]; sum[now]=sum[pre]+1; int id=((val&gt;&gt;i)&amp;1); next[now][id]=++tot; now=next[now][id];pre=next[pre][id]; } sum[now]=sum[pre]+1; } int query(int val,int x,int y){ int ans=0; for(int i=sigama;i&gt;=0;i--){ int id=((val&gt;&gt;i)&amp;1); if(sum[next[y][id^1]]-sum[next[x][id^1]]&gt;0){ ans|=(1&lt;&lt;i);x=next[x][id^1];y=next[y][id^1]; } else{ x=next[x][id];y=next[y][id]; } } return ans; } }Ta; int n,q,tot,a[maxn],in[maxn],num[maxn],out[maxn]; vector&lt;int&gt; G[maxn]; void dfs(int u,int pre){ in[u]=++tot;num[tot]=u; for(auto &amp;v:G[u]){ if(v==pre) continue; dfs(v,u); } out[u]=tot; } int main() { ios::sync_with_stdio(0);cin.tie(0); while(cin&gt;&gt;n&gt;&gt;q){ for(int i=0;i&lt;=n;i++) G[i].clear(); for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=2;i&lt;=n;i++){ int v;cin&gt;&gt;v; G[v].push_back(i); } tot=0;dfs(1,0);Ta.init(); for(int i=1;i&lt;=n;i++){ Ta.insert(num[i],Ta.root[i],Ta.root[i-1]); } while(q--){ int u,x;cin&gt;&gt;u&gt;&gt;x; int l=in[u],r=out[u];//cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl; cout&lt;&lt;Ta.query(x,Ta.root[l-1],Ta.root[r])&lt;&lt;endl; } } }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈常见模型]]></title>
    <url>%2F2019%2F12%2F25%2F%E5%8D%9A%E5%BC%88%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Bash Game(巴什博奕)1堆物品有n,两个人轮流取,每次至少取1个,最多m个,取完者胜。 结论：n%(m+1)!=0 先手必胜，这个可以用SG函数证明. 比如n=10,m=3;先手先取2个,后手取x个，先手再取4-x个，如此往复，先手必胜 Bash Game变形:每次取的个数在[p,q]之间(HDU2897,取完的输，注意) 通过n%(p+q)判断胜负； 1.n=k∗(p+q)时，先手第一次取q个，随后的回合若后手取x个，先手再取p+q−x个，那么最后就会留给后手p个，先手胜。 2.n=k∗(p+q)+s时，则要分情况考虑： 若s在[1,p]之间，先手取x，后手可以取p+q−x，最后留给先手s个，后手胜； 若s在(p,p+q)之间，先手任取x个(1≤s−x&lt;p)，后手取y个，先手可以再取p+q−y，最后留给后手s-x 个，先手胜； #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n,p,q; while(~scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;p,&amp;q)){ if(n%(p+q)==0||n%(p+q)&gt;p) cout&lt;&lt;&quot;WIN&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;LOST&quot;&lt;&lt;endl; } } Wythoff’s Game(威佐夫博弈)有两堆石子，一堆有m个，另一堆有n个。 双方轮流取走一些石子，合法的取法有如下两种： 1. 在一堆石子中取走任意多颗； 2. 在两堆石子中取走相同多的任意颗. 取走最后一颗石子的人为赢家。 (1,2)与(2,1)视为同一状态，第k个必败状态是(⌊(√5+1)/2∗k⌋+k,⌊(√5+1)/2∗k⌋)。 拓展性质： 1.令(m(k),n(k))=(⌊(√5+1)/2∗k⌋+k,⌊(√5+1)/2∗k⌋)则m(k)也表示前k个必败状态中没出现的自然数。 2.每个自然数都会出现在必败状态中且仅会出现一次。 /HDU 1527 模板题 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b ; while(cin&gt;&gt;a&gt;&gt;b){ if(a&lt;b) swap(a,b); int k=a-b; int n=(int)(k*(sqrt(5.0)+1.0)/2); bool win=(n!=b) ; cout&lt;&lt;win&lt;&lt;endl ; } return 0; } HDU-2177 加强版 //待补。。。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+5; bool check(int n,int m){ if(n&lt;m) swap(n,m); int k=n-m; int t=(int)(k*(sqrt(5)+1.0)/2.0); return t==n; } int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m; while(cin&gt;&gt;n&gt;&gt;m,n+m){ if(!check(n,m)) cout&lt;&lt;0&lt;&lt;endl; else{ } } } Fibonacci’s Game(斐波那契博弈)//详见：https://blog.csdn.net/acdreamers/article/details/8586135 有一堆个数为n&gt;=2的石子。 双方轮流取石子，满足以下条件： 1. 先手不能在第一次把所有的石子取完； 2. 之后每次可以取的石子数介于 1 到对手刚取的石子数的 2 倍之间（包含 1 和对手刚取的石子数的 2 倍） 取走最后一个石子的人为赢家。如果 n 是斐波那契数，则后手胜；反之，先手胜。 Zeckendorf定理：任何正整数可以表示为若干个不连续的 Fibonacci 数之和。 \\HDU 2516 模板题 #include&lt;bits/stdc++.h&gt; using namespace std; const string win[2]= { &quot;Second win&quot; , &quot;First win&quot; } ; long long fib[100] ; int init() { fib[0] = 1 ; fib[1] = 1 ; for ( int i = 2 ; i &lt; 100 ; i++ ) { fib[i] = fib[i-1] + fib[i-2] ; if ( fib[i] &gt; ( 1LL &lt;&lt; 35 ) ) return i ; } return 100 ; } int main() { int n ; int len = init() ; while ( cin &gt;&gt; n &amp;&amp; n ) { int ok = 1 ; for ( int i = 0 ; i &lt;= len ; i++ ) { if ( fib[i] == n ) { ok = 0 ; break ; } } cout &lt;&lt; win[ok] &lt;&lt; endl ; } return 0; } Nim博弈(尼姆博弈)有n堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 把每一项异或起来，结果为0则先手必败，否则先手胜利。 //HDU-2176 如果先手胜利，则输出第一次它可以取哪一堆，即在一堆中取走若干使得剩下的数字异或之和为0 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+5; int a[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int n; while(cin&gt;&gt;n,n){ int ans=0; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i];ans^=a[i]; } if(ans==0) cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; else{ cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; for(int i=0;i&lt;n;i++){ int t=ans;t^=a[i]; if(t&lt;=a[i]) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl; } } } }]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路与分层图最短路]]></title>
    <url>%2F2019%2F12%2F25%2F%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[最短路字面意思。。。Prim、Dijkstra、SPFA 优秀的Dijkstra + 优先队列优化(nlogn) 单源最短路、无负权边 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+5; const int INF=0x3f3f3f3f; struct Edge{ int from,to,dist; Edge(int u,int v,int d):from(u),to(v),dist(d) {} }; struct Dijkstra{ int n,m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn],p[maxn]; typedef pair&lt;int,int&gt; pii; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int dist){ edges.push_back(Edge(from,to,dist)); m=edges.size();G[from].push_back(m-1); } void dijkstra(int s){ priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q; for(int i=0;i&lt;n;i++) d[i]=INF; memset(vis,0,sizeof(vis)); q.push(pii(0,s));d[s]=0; while(!q.empty()){ pii x=q.top();q.pop(); int u=x.second; if(vis[u]) continue; vis[u]=true; for(int i=0;i&lt;G[u].size();i++){ Edge&amp; e=edges[G[u][i]]; if(d[e.to]&gt;d[u]+e.dist){ d[e.to]=d[u]+e.dist; p[e.to]=G[u][i]; q.push(pii(d[e.to],e.to)); } } } } }; int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); Dijkstra Dij; Dij.init(n); for(int i=0;i&lt;m;i++){ int u,v,d; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;d); Dij.AddEdge(u,v,d); } Dij.dijkstra(0); int x; while(scanf(&quot;%d&quot;,&amp;x)) cout&lt;&lt;Dij.d[x]&lt;&lt;endl; } 次短路字面意思。。。算法同上,开两个数组记录当前最短路和次短路即可 #include&lt;bits/stdc++.h&gt; using namespace std; const int INF=0x3f3f3f3f; const int maxn=5005; int n,m,u,v,w; int dis[maxn],dis2[maxn]; struct node{ int to,cost; node(int t,int c):to(t),cost(c) {} bool operator &lt; (const node &amp;a) const{ return cost&gt;a.cost; } }; vector&lt;node&gt; edge[maxn]; void Dijkstra() { priority_queue&lt;node&gt; que; memset(dis,INF,sizeof(dis)); memset(dis2,INF,sizeof(dis2)); dis[1]=0;que.push(node{1,0}); while(!que.empty()) { node x=que.top();que.pop(); int v=x.to,d=x.cost; if(dis2[v]&lt;d) continue; for(int i=0; i&lt;edge[v].size(); i++) { node y=edge[v][i];int d2=d+y.cost; if(dis[y.to]&gt;d2){ swap(dis[y.to],d2); que.push(node{y.to,dis[y.to]}); } if(dis2[y.to]&gt;d2 &amp;&amp; dis[y.to]&lt;d2){ dis2[y.to]=d2; que.push(node{y.to,dis2[y.to]}); } } } } int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;=n;i++) edge[i].clear(); for(int i=1;i&lt;=m;i++) { cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; edge[u].push_back(node{v,w}); edge[v].push_back(node{u,w}); } Dijkstra(); cout&lt;&lt;dis2[n]&lt;&lt;endl; return 0; } K短路字面意思。。。Dijkstra/SPFA + A*算法 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #define mem(a,b) sizeof(a,b,sizeof(b)) using namespace std; const int maxn=1005; const int INF=0x3f3f3f3f; struct node{ int to,val; node(){} node(int a,int b):to(a),val(b){} }; vector&lt;node&gt; a[maxn],b[maxn]; int n,m,k,dis[maxn]; bool vis[maxn]; void AddEdge(int x,int y,int val){ a[x].push_back(node(y,val)); b[y].push_back(node(x,val)); } priority_queue&lt;node&gt; q; void Dijkstra(int s,int t){ while(!q.empty()) q.pop(); mem(dis,INF);mem(vis,0); while(!q.empty()){ node t=q.top();q.pop();int u=t.to; if(vis[u]) continue;vis[u]=1; for(int i=0;i&lt;b[u].size();i++){ node v=b[u][i]; if(dis[v.to]&gt;dis[u]+v.val){ dis[v.to]=dis[u]+v.val; q.push(v.to); } } } } struct Anode{ int h,g,id; Anode(int a,int b,int c):h(a),g(b),id(c){} bool operator &lt;(const Anode&amp; a)const{ return h+g&gt;a.h+a.g; } }; priority_queue&lt;Anode&gt; Q; int Astar(int s,int t){ while(!Q.empty()) Q.pop(); Q.push(Anode(0,dis[s],s)); int num=0; while(!Q.empty()){ Anode u=Q.top();Q.pop(); if(u.id==t) num++; if(num&gt;=k) return u.h; for(int i=0;i&lt;a[u.id].size();i++){ node v=a[u.id][i]; //Q.emplace(u.h+v.val,dis[v.to],v.to); Q.push(Anode(u.h+v.val,dis[v.to],v.to)); } } return -1; } int main(){ ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;maxn;i++) a[i].clear(),b[i].clear(); int x,y,v,s,t; for(int i=0;i&lt;m;i++){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;AddEdge(x,y,v); } cin&gt;&gt;s&gt;&gt;t&gt;&gt;k; if(s==t) k++; Dijkstra(s,t); cout&lt;&lt;Astar(s,t)&lt;&lt;endl; } 分层图最短路字面(STOP!) 敲打.jpg 分层图最短路就是在分层图上解决最短路问题 一般模型为：在一张图上，有k次机会修改某条边的权值(置0/减半)，再求从起点到终点的最短路线 一般解决方法：多开一维记录状态，多开的维度记录状态的种类数即为分层数。DP dis[i][j] -&gt; 到了第i个点，修改了j次边权后的最短路 用to表示要到的点，x表示父亲节点，于是 dis[to][j]=min(dis[x][j]+val(x,to),dis[x][j-1]) 前者表示没修改/后者表示修改了 #include&lt;bits/stdc++.h&gt; #define pii pair&lt;int,int&gt; using namespace std; const int maxn=1e5+5; const int maxk=15; const int INF=0x3f3f3f3f; int n,m,s,t,k,d[maxn][maxk]; bool vis[maxn][maxk]; vector&lt;pii&gt; Edge[maxn]; void init(){ for(int i=0;i&lt;=n*2;i++) Edge[i].clear(); memset(d,0x3f,sizeof(d)); memset(vis,0,sizeof(vis)); } void Dijkstra(int s){ d[s][0]=0;priority_queue&lt;pii&gt; que;que.push({0,s}); while(!que.empty()){ int u=que.top().second;que.pop(); int c=u/n;u%=n; if(vis[u][c]) continue;vis[u][c]=1; for(int j=0;j&lt;Edge[u].size();j++){ int v=Edge[u][j].first; if(!vis[v][c]&amp;&amp;d[v][c]&gt;d[u][c]+Edge[u][j].second){ d[v][c]=d[u][c]+Edge[u][j].second;que.push({-d[v][c],v+c*n}); } } if(c&lt;k){ for(int j=0;j&lt;Edge[u].size();j++){ int v=Edge[u][j].first; if(!vis[v][c+1]&amp;&amp;d[v][c+1]&gt;d[u][c]){ d[v][c+1]=d[u][c];que.push({-d[v][c+1],v+(c+1)*n}); } } } } } /* int main() { ios::sync_with_stdio(0);cin.tie(0);关同步WA+RE while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;k){ init();cin&gt;&gt;s&gt;&gt;t;//s=1;t=n; int a,b,x; while(m--){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;x; for(int i=0;i&lt;=k;i++){ Edge[a].push_back({b,x}); Edge[b].push_back({a,x}); } } Dijkstra(s);int ans=INF; for(int i=0;i&lt;=k;i++) ans=min(ans,d[t][i]); cout&lt;&lt;ans&lt;&lt;endl; } } */ int main() { while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k)){ init();scanf(&quot;%d%d&quot;,&amp;s,&amp;t);int a,b,x; while(m--){ scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;x); for(int i=0;i&lt;=k;i++){ Edge[a].push_back({b,x}); Edge[b].push_back({a,x}); } } Dijkstra(s);int ans=INF; for(int i=0;i&lt;=k;i++) ans=min(ans,d[t][i]); printf(&quot;%d\n&quot;,ans); } return 0; } 2018南京网络赛L题：Magical Girl Haze(最短路分层图) //开long long , 有向图 #include&lt;bits/stdc++.h&gt; typedef long long ll; #define pii pair&lt;ll,ll&gt; using namespace std; const int maxn=1e5+5; const int maxk=15; //const int INF=0x3f3f3f3f; const ll INF=1e15; int n,m,s,t,k; ll d[maxn][maxk]; bool vis[maxn][maxk]; vector&lt;pii&gt; Edge[maxn]; void init(){ for(int i=0;i&lt;=n*2;i++) Edge[i].clear(); for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=k;j++) d[i][j]=INF; memset(vis,0,sizeof(vis)); } void Dijkstra(int s){ d[s][0]=0;priority_queue&lt;pii&gt; que;que.push({0,s}); while(!que.empty()){ int u=que.top().second;que.pop(); ll c=u/n;u%=n; if(vis[u][c]) continue;vis[u][c]=1; for(int j=0;j&lt;Edge[u].size();j++){ ll v=Edge[u][j].first; if(!vis[v][c]&amp;&amp;d[v][c]&gt;d[u][c]+Edge[u][j].second){ d[v][c]=d[u][c]+Edge[u][j].second;que.push({-d[v][c],v+c*n}); } } if(c&lt;k){ for(int j=0;j&lt;Edge[u].size();j++){ ll v=Edge[u][j].first; if(!vis[v][c+1]&amp;&amp;d[v][c+1]&gt;d[u][c]){ d[v][c+1]=d[u][c];que.push({-d[v][c+1],v+(c+1)*n}); } } } } } int main() { int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); init();int a,b;ll x; while(m--){ scanf(&quot;%d%d%lld&quot;,&amp;a,&amp;b,&amp;x); for(int i=0;i&lt;=k;i++){ Edge[a].push_back({b,x}); //Edge[b].push_back({a,x}); } } Dijkstra(1);ll ans=INF; for(int i=0;i&lt;=k;i++) ans=min(ans,d[n][i]); printf(&quot;%lld\n&quot;,ans); } return 0; } P2939 [USACO09FEB]改造路Revamping Trails 交上面那份ll就错 ， 交int模版就过 ？？？？？？？？？？ https://www.luogu.org/problem/P2939 待补P3063 [USACO12DEC]牛奶的路由Milk Routing 与上面不同的是允许把边权减半 HDU 3499 分层图最短路+Trie树 给n个城市和m条无向边，然后给了起点和终点，然后你有一次机会使得其中的一张票价减半，问最小花费是多少 NEFU 1132 分层图最短路 https://blog.csdn.net/dan__ge/article/details/51702663 #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; typedef pair&lt;int,int&gt; P; const int inf=0x3f3f3f3f; const ll INF=0x3f3f3f3f3f3f3f3fll; const int maxn=10010; struct edge{ int to,cost; edge(int a,int b){to=a;cost=b;} }; vector&lt;edge&gt;G[maxn]; int vis[maxn],dis[maxn],n,m,k; int dijkstra(int s,int t){ memset(dis,inf,sizeof(dis)); memset(vis,0,sizeof(vis)); priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt;que; dis[s]=0;que.push(P(0,s)); while (!que.empty()){ P p=que.top();que.pop(); int v=p.second; if (vis[v]) continue; vis[v]=1; for(int i=0;i&lt;G[v].size();i++){ edge e=G[v][i]; if(dis[v]+e.cost&lt;dis[e.to]){ dis[e.to]=dis[v]+e.cost; que.push(P(dis[e.to],e.to)); } } } int ans=inf; for(int i=0;i&lt;=k;i++) ans=min(ans,dis[i*n+t]); if(ans==inf) return -1; return ans; } int U[maxn],V[maxn],COST[maxn],num[110][110]; int main(){ int st,en; while(scanf(&quot;%d%d%d&quot;,&amp;st,&amp;en,&amp;k)!=-1){ for(int i=0;i&lt;maxn;i++) G[i].clear(); st++;en++; n=max(st,en); scanf(&quot;%d&quot;,&amp;m); memset(num,inf,sizeof(num)); for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;U[i],&amp;V[i],&amp;COST[i]); U[i]++;V[i]++;num[U[i]][V[i]]=min(COST[i],num[U[i]][V[i]]); n=max(n,max(U[i],V[i])); } for(int i=1;i&lt;=m;i++){ for(int j=0;j&lt;=k;j++){ G[j*n+U[i]].push_back(edge(j*n+V[i],num[U[i]][V[i]])); if(j&lt;k) G[j*n+U[i]].push_back(edge((j+1)*n+V[i],num[U[i]][V[i]]/2)); } } int ans=dijkstra(st,en); if(ans==-1) printf(&quot;KengDie\n&quot;); else printf(&quot;%d\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SG函数与SG定理]]></title>
    <url>%2F2019%2F12%2F25%2FSG%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[SG函数-引入SG函数用来判断博弈问题的输赢，当SG函数值为0时表示输，不为0表示赢。 定义mex(s)表示不属于s集合的最小非负整数，例如:mex{0,1,2}=3、mex{1,2,3}=0、mex{0,1,3}=2 定义SG函数:SG(x)=mex{SG(y)|y是x的后继,也就是经过操作可以取得的剩下值} S是x后继状态的SG函数值的集合。如x有三个后继状态分别为SG(a),SG(b),SG(c)那么SG(x)=mex{SG(x)}=mex{SG(a,SG(b),SG(c))}。这样集合S的终态必然是空集，所以SG函数的终态为SG(x)=0,当且仅当x为必败点P时。 例如：一堆石子，我们可以取任意个，那么x个石子的石子的sg值是多少呢？ 可以知道，0个石子sg为0，1的时候我们可以取1个，剩下0，而0的sg是0，那么mex{0}就是1，所以1的sg为1。即SG(1)=mex{SG(0)}=mex{0}=1; SG(2)=mex{SG(0),SG(1)}=mex{0,1}=2;SG(3)=mex(SG(0),SG(1),SG(2))=mex{0,1,2}=3 继续往下，当为x的时候我们可以取1~x个，那么剩下的值石子个数就是x-1到0个，他的mex（...）就是x，所以这个例子的x值得sg值就是x，即SG(x)=mex{SG(0),SG(1),SG(2),SG(3),...,SG(x-1)=x; SG函数的作用： Nimm博弈中，对于多堆，只需将每堆的SG值异或一下(每堆的数量)，如果是0则为输，否则为赢 组合游戏在竞赛中，组合游戏的题目一般有以下特点 1.题目描述一般为A,B 2人做游戏 2.A,B交替进行某种游戏规定的操作，每操作一次，选手可以在有限的操作（操作必须合法）集合中任选一种。 3.对于游戏的任何一种可能的局面，合法的操作集合只取决于这个局面本身，不取决于其它因素（跟选手，以前的所有操作无关） 4.如果当前选手无法进行合法的操作，则为负 必胜点与必败点必败点(P点) 前一个(previous player)选手将取胜的点称为必败点 必胜点(N点) 下一个(next player)选手将取胜的点称为必胜点 必胜点和必败点的性质： - 所有的终结点都是必败点 - 从任何必胜点操作，至少有一种方式进入必败点 - 无论如何操作， 从必败点都只能进入必胜点. SG定理游戏和的SG函数等于各个游戏SG函数的Nim和。这样就可以将每一个子游戏分而治之，从而简化了问题。而Bouton定理就是Sprague-Grundy定理在Nim游戏中的直接应用，因为单堆的Nim游戏SG函数满足SG(x)=x。 举栗-取石子游戏有1堆n个的石子，每次只能取{1,3,4}个石子，先取完石子者胜利，那么各个数的SG值为多少？ SG(0)=0,f[]={1,3,4}. x=1时，可以取走1-f[1]个石子,剩余{0}个，所以SG(1)=mex{SG(0)}=mex{0}=1; x=2时，可以取走2-f[1]个石子,剩余{1}个，所以SG(2)=mex{SG(1)}=mex{1}=0; x=3时，可以取走3-f[1,3]个石子,剩余{2,0}个，所以SG(3)=mex{SG(0),SG(2)}=mex{0,0}=0; x=4时，可以取走4-f[1,2,3]个石子,剩余{3,1,0}个，所以SG(4)=mex{SG(3),SG(1),SG(0)}=mex{0,1}=2; x=5时，可以取走5-f[1,2,3]个石子,剩余{4,2,1}个，所以SG(5)=mex{SG(4),SG(2),SG(1)}=mex{2,1,0}=3; 继续推：SG(6)=2、SG(7)=0、SG(8)=1 ..... 编程时只需模拟上述过程计算1~n的SG函数值： 1.使用数组f将 可改变当前状态 的方式记录下来。 2.然后我们使用 另一个数组 将当前状态x的后继状态标记。 3.最后模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x)。 4.我们不断的重复2-3的步骤，就完成了计算1~n的函数值。 //f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理 //SG[]:0~n的SG函数值 //S[]:为x后继状态的集合 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+5; int f[3]={1,2,4},SG[maxn],S[maxn];//S为状态集合 int N=3;//f的个数 void getSG(int n){ memset(SG,0,sizeof(SG)); for(int i=1;i&lt;=n;i++){//因为SG[0]始终等于0，所以i从1开始 memset(S,0,sizeof(S));//每一次都要将上一状态 的 后继集合 重置 for(int j=0;f[j]&lt;=i&amp;&amp;j&lt;=N;j++) S[SG[i-f[j]]]=1;//将后继状态的SG函数值进行标记 for(int j=0;;j++) //查询当前后继状态SG值中最小的非零值 if(!S[j]){SG[i]=j;break;} } } int main() { ios::sync_with_stdio(0);cin.tie(0); int n,x;cin&gt;&gt;n;getSG(n); while(cin&gt;&gt;x){ cout&lt;&lt;SG[x]&lt;&lt;endl; } } 题目HDU-4388(找1个数的奇偶性)(博弈+找规律)//HDU-4388 Stone Game II 题意：给出n堆物品，每堆物品都有若干件，现在A和B进行游戏，每人每轮操作一次，按照如下规则： 1. 任意选择一个堆，假设该堆有x个物品，从中选择k个，要保证0&lt;k&lt;x且0&lt;(x^k)&lt;k。 2. 再增加一个大小为x^k的堆，另外有一个技能，可以将这个大小为x^k的堆变成(2*k)^x的堆，但是这个技能每个人只有一次机会可以使用。 现在问两人轮流操作，都采取最优策略，最后不能操作的人输，问谁会赢。 思路：不考虑技能的话，一堆x分为k和k^x，实际上在二进制下x中1的个数与k和k^x中1的个数的奇偶性保持一致。 考虑技能，一堆x分为k和(k&lt;&lt;1)^x,其中二者之间的奇偶性也没变，可以写一个试一下。 游戏终止的条件是一堆不能再分了，即分到最后每堆中1的个数都为1，于是原来的n堆可以分为n个数中1(二进制下)的个数之和堆(设为cnt)， 需要分(cnt-n)次才行，于是变成了判断(cnt-n)的奇偶性，为奇数时先手赢否则先手输。 ^.^貌似和SG没啥关系。。。但是大佬的博客把这一题归在SG #include&lt;bits/stdc++.h&gt; using namespace std; int cal(int x){ int ans=0; while(x){ ans+=(x&amp;1); x&gt;&gt;=1; } return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); int T;cin&gt;&gt;T;int ca=1; while(T--){ int n,ans=0;cin&gt;&gt;n; while(n--){ int t;cin&gt;&gt;t;ans+=cal(t)-1; } cout&lt;&lt;&quot;Case &quot;&lt;&lt;ca++&lt;&lt;&quot;: &quot;; if(ans&amp;1) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } }]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)为什么printf()用%f输出double型，而scanf却用%lf]]></title>
    <url>%2F2019%2F12%2F25%2Fprintf%2F</url>
    <content type="text"><![CDATA[问：有人告诉我不能在printf中使用%lf。为什么printf()用%f输出double型，而scanf却用%lf呢？ 答：printf的%f说明符的确既可以输出float型又可以输出double型。 根据”默认参数提升”规则（在printf这样的函数的可变参数列表中 ，不论作用域内有没有原型，都适用这一规则）float型会被提升为double型。因此printf()只会看到双精度数。参见问题15.2。 对于scanf，情况就完全不同了，它接受指针，这里没有类似的类型提升。（通过指针）向float存储和向double存储大不一样，因此，scanf区别%f和%lf。 下表列出了printf和scanf对于各种格式说明符可以接受的参数类型。 （严格地讲，%lf在printf下是未定义的，但是很多系统可能会接受它。要确保可移植性，就要坚持使用%f。）]]></content>
  </entry>
  <entry>
    <title><![CDATA[LCA]]></title>
    <url>%2F2019%2F12%2F25%2FLCA%2F</url>
    <content type="text"><![CDATA[LCA解决树上两点间的最近公共祖先，三种方式： 1.Tarjan 离线算法 O(n+q) 2.倍增 在线算法 O((n+q)*logn) 3.RMQ(ST表) 优秀的在线算法 O(nlogn+q) TarjanTarjan 算法求 LCA 的时间复杂度为 O(n+q) ，是一种离线算法，要用到并查集。（注：这里的复杂度其实应该不是 O(n+q) ，还需要考虑并查集操作的复杂度 ，但是由于在多数情况下，路径压缩并查集的单次操作复杂度可以看做 O(1)，所以写成了 O(n+q) 。） Tarjan 算法基于 dfs ，在 dfs 的过程中，对于每个节点位置的询问做出相应的回答。 dfs 的过程中，当一棵子树被搜索完成之后，就把他和他的父亲合并成同一集合；在搜索当前子树节点的询问时，如果该询问的另一个节点已经被访问过， 那么该编号的询问是被标记了的，于是直接输出当前状态下，另一个节点所在的并查集的祖先；如果另一个节点还没有被访问过，那么就做下标记，继续 dfs 。 板子1(NBWY)//离线Tarjan O(n+q) from NBWY //POJ-1470 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; const int maxn=905; vector&lt;int&gt; G[maxn],query[maxn]; int ans[maxn],fa[maxn]; bool vis[maxn],in[maxn]; int n,m; void init(){ for(int i=1;i&lt;=n;i++){ G[i].clear();query[i].clear(); fa[i]=i;in[i]=0;ans[i]=0;vis[i]=0; } } int find(int x){return fa[x]==x?x:find(fa[x]);} void add_edge(int u,int v){G[u].push_back(v);} void add_query(int u,int v){query[u].push_back(v);} void Tarjan(int u){ vis[u]=1; int size=query[u].size(); for(int i=0;i&lt;size;i++){ int v=query[u][i]; if(vis[v]) ans[find(v)]++; } size=G[u].size(); for(int i=0;i&lt;size;i++){ int v=G[u][i]; if(!vis[v]){ Tarjan(v);fa[v]=u; } } } int main() { while(~scanf(&quot;%d&quot;,&amp;n)){ init(); int u,v; for(int i=0;i&lt;n;i++){ scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;m); while(m--){ scanf(&quot;%d&quot;,&amp;v);in[v]=1; add_edge(u,v);add_edge(v,u); } } scanf(&quot;%d&quot;,&amp;m); while(m--){ scanf(&quot; (%d %d)&quot;,&amp;u,&amp;v); add_query(u,v);add_query(v,u); } for(int i=1;i&lt;=n;i++) if(!in[i]){ Tarjan(i);break; } for(int i=1;i&lt;=n;i++) if(ans[i]) printf(&quot;%d:%d\n&quot;,i,ans[i]); } } 板子2(Kuangbin)/* POJ 1470 离线处理 G++ 1204ms 8788K C++ 954ms 8304K */ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;math.h&gt; #include&lt;vector&gt; using namespace std; const int MAXN=1000; const int MAXM=500000;//最大查询数 int F[MAXN];//并查集 int r[MAXN];//并查集中集合的个数 bool vis[MAXN];//访问标记 int ancestor[MAXN];//祖先 struct Node { int to,next; }edge[MAXN*2]; int head[MAXN]; int tol; void addedge(int a,int b) { edge[tol].to=b; edge[tol].next=head[a]; head[a]=tol++; edge[tol].to=a; edge[tol].next=head[b]; head[b]=tol++; } struct Query { int q,next; int index;//查询编号 }query[MAXM*2];//查询数 int answer[MAXM];//查询结果 int cnt; int h[MAXM]; int tt; int Q;//查询个数 void add_query(int a,int b,int i) { query[tt].q=b; query[tt].next=h[a]; query[tt].index=i; h[a]=tt++; query[tt].q=a; query[tt].next=h[b]; query[tt].index=i; h[b]=tt++; } void init(int n) { for(int i=1;i&lt;=n;i++) { F[i]=-1; r[i]=1; vis[i]=false; ancestor[i]=0; tol=0; tt=0; cnt=0;//已经查询到的个数 } memset(head,-1,sizeof(head)); memset(h,-1,sizeof(h)); } int find(int x) { if(F[x]==-1)return x; return F[x]=find(F[x]); } void Union(int x,int y)//合并 { int t1=find(x); int t2=find(y); if(t1!=t2) { if(r[t1]&lt;=r[t2]) { F[t1]=t2; r[t2]+=r[t1]; } else { F[t2]=t1; r[t1]+=r[t2]; } } } void LCA(int u) { // if(cnt&gt;=Q)return;//这个不能加，加了就WR了 ancestor[u]=u; vis[u]=true;//这个一定要放在前面 for(int i=head[u];i!=-1;i=edge[i].next) { int v=edge[i].to; if(vis[v])continue; LCA(v); Union(u,v); ancestor[find(u)]=u; } for(int i=h[u];i!=-1;i=query[i].next) { int v=query[i].q; if(vis[v]) { answer[query[i].index]=ancestor[find(v)]; cnt++;//已经找到的答案数 } } } int Count_num[MAXN]; bool flag[MAXN]; int main() { // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int N; int u,v,m; char ch; while(scanf(&quot;%d&quot;,&amp;N)!=EOF) { init(N); memset(flag,false,sizeof(flag)); for(int i=1;i&lt;=N;i++) { scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;m); while(m--) { scanf(&quot;%d&quot;,&amp;v); flag[v]=true; addedge(u,v); } } scanf(&quot;%d&quot;,&amp;Q); for(int i=0;i&lt;Q;i++) { cin&gt;&gt;ch; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); cin&gt;&gt;ch; add_query(u,v,i); } int root; for(int i=1;i&lt;=N;i++) if(!flag[i]) { root=i; break; } LCA(root); memset(Count_num,0,sizeof(Count_num)); for(int i=0;i&lt;Q;i++) Count_num[answer[i]]++; for(int i=1;i&lt;=N;i++) if(Count_num[i]&gt;0) printf(&quot;%d:%d\n&quot;,i,Count_num[i]); } return 0; } 倍增我们可以用倍增来在线求 LCA ，时间和空间复杂度分别是 O((n+q)logn) 和 O(nlogn) 。 对于这个算法，我们从最暴力的算法开始： 1.如果 a 和 b 深度不同，先把深度调浅，使他变得和浅的那个一样 2.现在已经保证了 a 和 b 的深度一样，所以我们只要把两个一起一步一步往上移动，直到他们到达同一个节点，也就是他们的最近公共祖先了。 板子1(zhouzhendong)//在线倍增 O((n+q)logn) #include&lt;bits/stdc++.h&gt; using namespace std; const int N=10000+5; vector &lt;int&gt; son[N]; int T,n,depth[N],fa[N][20],in[N],a,b; void dfs(int prev,int rt){ depth[rt]=depth[prev]+1; fa[rt][0]=prev; for (int i=1;i&lt;20;i++) fa[rt][i]=fa[fa[rt][i-1]][i-1]; for (int i=0;i&lt;son[rt].size();i++) dfs(rt,son[rt][i]); } int LCA(int x,int y){ if (depth[x]&lt;depth[y]) swap(x,y); for (int i=19;i&gt;=0;i--) if (depth[x]-(1&lt;&lt;i)&gt;=depth[y]) x=fa[x][i]; if (x==y) return x; for (int i=19;i&gt;=0;i--) if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; } int main(){ scanf(&quot;%d&quot;,&amp;T); while (T--){ scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) son[i].clear(); memset(in,0,sizeof in); for (int i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;a,&amp;b); son[a].push_back(b); in[b]++; } depth[0]=-1; int rt=0; for (int i=1;i&lt;=n&amp;&amp;rt==0;i++) if (in[i]==0) rt=i; dfs(0,rt); scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\n&quot;,LCA(a,b)); } return 0; } 板子2(Kuangbin)//倍增(Kuangbin) POJ1330 #include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1e4+5; const int h=20; struct Edge{int to,nxt;}edge[maxn*2]; int head[maxn],tot; void add_edge(int u,int v){edge[tot].to=v;edge[tot].nxt=head[u];head[u]=tot++;} void init(){tot=0;mem(head,-1);} int fa[maxn][h];//fa[i][j]表示结点i的第2^j个祖先 int depth[maxn];//深度数组 void bfs(int r){ queue&lt;int&gt; que;depth[r]=0; fa[r][0]=r;que.push(r); while(!que.empty()){ int tmp=que.front();que.pop(); for(int i=1;i&lt;h;i++) fa[tmp][i]=fa[fa[tmp][i-1]][i-1]; for(int i=head[tmp];i!=-1;i=edge[i].nxt){ int v=edge[i].to;if(v==fa[tmp][0]) continue; depth[v]=depth[tmp]+1;fa[v][0]=tmp; que.push(v); } } } int LCA(int u,int v){ if(depth[u]&gt;depth[v]) swap(u,v); int hu=depth[u],hv=depth[v]; int tu=u,tv=v; for(int det=hv-hu,i=0;det;det&gt;&gt;=1,i++) if(det&amp;1) tv=fa[tv][i]; if(tu==tv) return tu; for(int i=h-1;i&gt;=0;i--){ if(fa[tu][i]==fa[tv][i]) continue; tu=fa[tu][i];tv=fa[tv][i]; } return fa[tu][0]; } bool flag[maxn]; int main() { int T,n,u,v;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;n);init();mem(flag,0); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v);add_edge(u,v);add_edge(v,u);flag[v]=1; } int root; for(int i=1;i&lt;=n;i++) if(!flag[i]){root=i;break;} bfs(root); scanf(&quot;%d%d&quot;,&amp;u,&amp;v); printf(&quot;%d\n&quot;,LCA(u,v)); } } RMQ(ST)一种O(nlogn)预处理+O(1)查询的在线算法(优秀) 一个子树中深度最浅的节点必定是该子树的树根。两个节点的 LCA 不仅是两个节点的最近公共祖先， 而且是囊括这两个节点的最小子树的根，即囊括这两个节点的最小子树中的深度最小的节点 如何得到这个子树根节点呢？ 现在，我们稍微修改一下 dfs 序，搞一个欧拉序。 欧拉序，就是每次从 father(x) 进入节点 x 或者从子节点回溯到 x 都要把 x 这个编号扔到一个数组的最后。 这样最终会得到一个长度约为 2n 的数列。（考虑每一个节点贡献为 2 ，分别是从其父亲进入该节点，和从该节点回到其父亲） 下图这棵树的一个欧拉序为 8,5,9,5,8,4,6,15,6,7,6,4,10,11,10,16,3,16,12,16,10,2,10,4,8,1,14,1,13,1,8 再注意到，一对点的 LCA 不仅是囊括这两个节点的最小子树中的深度最小的节点，还是连接这对点的简单路径上深度最小的点。 而且从离开 a 到进入 b 的这段欧拉序必然包括所有这对点之间的简单路径上的所有点，所以我们考虑求得这段欧拉序中所包含的节点中的 深度最小的点即其 LCA 。 从 a 到 b 的这段欧拉序会包含这棵子树中的其他节点，但是不会影响这个最浅点的求得，因为“一对点的 LCA 是囊括这两个节点的最小子树中的深度最小的节点”。 显然， a 到 b 这段欧拉序是个连续区间。 你可以用线段树维护，但是线段树太 low 了。 现在我们考虑通过预处理来 O(1) 获得这个最浅点。 于是我们要学习一个叫做 ST表 的东西来搞定这个。（和之前倍增中处理的 fa 数组差不多） 板子1(Vector from CSL)//RMQ O(nlogn+q) CSL #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e4+5; vector&lt;int&gt; edge[maxn],sp; int dep[maxn],dfn[maxn]; pair&lt;int,int&gt; dp[21][maxn&lt;&lt;1]; void init(int n){ for(int i=0;i&lt;=n;i++) edge[i].clear(); sp.clear(); } void dfs(int u,int fa){ dep[u]=dep[fa]+1; dfn[u]=sp.size();//欧拉序列 sp.push_back(u); for(auto&amp; v:edge[u]){ if(v==fa) continue; dfs(v,u);sp.push_back(u); } } void initrmq(){ int n=sp.size(); for(int i=0;i&lt;n;i++) dp[0][i]={dfn[sp[i]],sp[i]}; for(int i=1;(1&lt;&lt;i)&lt;=n;i++)//注意从1开始 ST表维护最小时间戳 for(int j=0;j+(1&lt;&lt;i)-1&lt;n;j++) dp[i][j]=min(dp[i-1][j],dp[i-1][j+(1&lt;&lt;(i-1))]); } int lca(int u,int v){ int l=dfn[u],r=dfn[v]; if(l&gt;r) swap(l,r); int k=31-__builtin_clz(r-l+1); return min(dp[k][l],dp[k][r-(1&lt;&lt;k)+1]).second; } int main() { /* */ } 验板子(HDU - 2586 Vector)//RMQ O(nlogn+q) CSL #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=5e4+5; struct Edge{ int to,w; Edge(int t,int W):to(t),w(W){} }; vector&lt;Edge&gt; edge[maxn]; vector&lt;int&gt; sp; int dep[maxn],dfn[maxn]; pair&lt;int,int&gt; dp[21][maxn&lt;&lt;1]; int dist[maxn]; void init(int n){ for(int i=0;i&lt;=n;i++) {edge[i].clear();dep[i]=dist[i]=0;} sp.clear(); } void dfs(int u,int fa){ dep[u]=dep[fa]+1; dfn[u]=sp.size(); sp.push_back(u); for(auto&amp; v:edge[u]){ if(v.to==fa) continue; dist[v.to]=dist[u]+v.w; dfs(v.to,u);sp.push_back(u); } } void initrmq(){ int n=sp.size(); for(int i=0;i&lt;n;i++) dp[0][i]={dfn[sp[i]],sp[i]}; for(int i=1;(1&lt;&lt;i)&lt;=n;i++) for(int j=0;j+(1&lt;&lt;i)-1&lt;n;j++) dp[i][j]=min(dp[i-1][j],dp[i-1][j+(1&lt;&lt;(i-1))]); } int lca(int u,int v){ int l=dfn[u],r=dfn[v]; if(l&gt;r) swap(l,r); int k=31-__builtin_clz(r-l+1); return min(dp[k][l],dp[k][r-(1&lt;&lt;k)+1]).second; } int main() { int T;scanf(&quot;%d&quot;,&amp;T); int u,v,w; while(T--){ int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(n); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); edge[u].push_back(Edge(v,w)); edge[v].push_back(Edge(u,w)); } dfs(1,0);initrmq(); while(m--){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v); printf(&quot;%d\n&quot;,dist[u]+dist[v]-2*dist[lca(u,v)]); } } } 验板子(HDU - 2586 前向星)#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e4+5; struct Edge{ int to,w,nxt; }edge[maxn&lt;&lt;1]; int tot,head[maxn]; vector&lt;int&gt; sp; int dep[maxn],dfn[maxn]; pair&lt;int,int&gt; dp[21][maxn&lt;&lt;1]; int dist[maxn]; void Addedge(int u,int v,int w){ edge[tot].to=v;edge[tot].w=w;edge[tot].nxt=head[u];head[u]=tot++; } void init(int n){ for(int i=0;i&lt;=n;i++) {head[i]=-1;dep[i]=dist[i]=0;} sp.clear();tot=0; } void dfs(int u,int fa){ dep[u]=dep[fa]+1; dfn[u]=sp.size(); sp.push_back(u); for(int i=head[u];i!=-1;i=edge[i].nxt){ int v=edge[i].to; if(v==fa) continue; dist[v]=dist[u]+edge[i].w; dfs(v,u);sp.push_back(u); } } void initrmq(){ int n=sp.size(); for(int i=0;i&lt;n;i++) dp[0][i]={dfn[sp[i]],sp[i]}; for(int i=1;(1&lt;&lt;i)&lt;=n;i++) for(int j=0;j+(1&lt;&lt;i)-1&lt;n;j++) dp[i][j]=min(dp[i-1][j],dp[i-1][j+(1&lt;&lt;(i-1))]); } int lca(int u,int v){ int l=dfn[u],r=dfn[v]; if(l&gt;r) swap(l,r); int k=31-__builtin_clz(r-l+1); return min(dp[k][l],dp[k][r-(1&lt;&lt;k)+1]).second; } int main() { int T;scanf(&quot;%d&quot;,&amp;T); int u,v,w; while(T--){ int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(n); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); Addedge(u,v,w);Addedge(v,u,w); } dfs(1,0);initrmq(); while(m--){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v); printf(&quot;%d\n&quot;,dist[u]+dist[v]-2*dist[lca(u,v)]); } } } 题目总结LCA题目总结 好像LCA的题目并不多，现在就做了10道左右，但是找不到别的了，在此做个小总结，将来有更好的题目会不断更新 解决LCA问题，一般用3种方法 1.朴素方法：两个点都一直沿路径往上走，直到有某一个节点被经过两次并且是第一次出现这样的点，那么这个就是LCA 此方法最好理解，但是用得不多，但不代表没作用，有些题目还是需要用到的 2.LCA转RMQ（在线算法）：一般是将LCA转为RMQ问题，用ST算法求解，当然求解RMQ问题有很多方法，不过ST比较常用而已，这样做能及时回答每一个询问 3.Tarjan算法（离线算法）：利用Tarjan算法，不过要先读入所有询问再一并回答，建议认真学习Tarjan算法本质 ******具体问题具体分析，但是可以使用Tarjan算法的时候推荐使用Tarjan算法，代码量少速度快，另外Tarjan算法容易产生变形，值得深究************* 待补题poj 1986 Distance Queries 模板题，直接求LCA hdu 2874 Connections between cities 模板题，不过不是树是森林，所以某些点不存在LCA，要做判断 zoj 3195 Design the city 任然算是模板题，上面的题要求两点间的最短距离，这里要求3点间的最短距离，其实就是两两之间求一次LCA并计算出距离，然后相加除以2即可 hdu 3078 Network LCA + 修改点权值 + 排序：每个点有初始的权值，一边查询一边伴随着修改某些点的权值，查询是从a到b路径中第k大的权值是多少。不需要太多的技巧，修改操作就直接修改，查询操作先求LCA，然后从a走到b保存下所有的权值，排序，然后直接输出即可 poj 2763 Housewife Wind LCA + 修改边权：一边查询两点间的距离，一边修改某些边权。对于修改了某些边的边权，就要从此开始遍历下面的子孙后代更改他们的dir值（点到根的距离）。也不需要太多技巧，直接按题意实现即可，不过时间比较糟糕，用线段树或树状数组可以对修改操作进行优化，时间提升很多 poj 3694 Network 连通分量 + LCA ： 先缩点，再求LCA，并且不断更新，这题用了朴素方法来找LCA，并且在路径上做了一些操作 poj 3417 Network LCA + Tree DP : 在运行Tarjan处理完所有的LCA询问后，进行一次树DP，树DP不难，但是要想到用树DP并和这题结合还是有点难度 poj 3728 The merchant LCA + 并查集的变形，优化：好题，难题，思维和代码实现都很有难度，需要很好地理解Tarjan算法中并查集的本质然后灵活变形，需要记录很多信息（有点dp的感觉） hdu 3830 Checkers LCA + 二分：好题，有一定思维难度。先建立出二叉树模型，然后将要查询的两个点调整到深度一致，然后二分LCA所在的深度，然后检验]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F12%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++ STL]]></title>
    <url>%2F2019%2F12%2F25%2FC%2B%2B%20STL%2F</url>
    <content type="text"><![CDATA[1.set 与 multiset头文件#include&lt;set&gt; #include&lt;multiset&gt; 红黑树维护 set和multiset会根据特定的排序原则将元素排序(自动排序，时刻保证序列中的数是有序的)。 两者不同之处在于，multisets允许元素重复，而set不允许重复。 multiset:它可以插入重复的元素,如果删除的话，相同的也一起删除了；如果查找的话，返回该元素的迭代器的位置，若有相同，返回第一个元素的地址； 和所有的标准关联容器类似，sets和multisets通常以平衡二叉树完成。 自动排序的主要优点在于使二叉树搜寻元素具有良好的性能，在其搜索函数算法具有对数复杂度。 但是自动排序也造成了一个限制，不能直接改变元素值，因为这样会打乱原有的顺序，要改变元素的值，必须先删除旧元素，再插入新元素。 所以sets和multisets具有以下特点： 1.不提供直接用来存取元素的任何操作元素 2.通过迭代器进行元素的存取。 可以插入自定义类型，但同时需要定义类型变量之间小于关系的含义~ 相关函数1.定义：set&lt;int&gt; s; multiset&lt;int&gt; s; set&lt;int&gt;::iterator it; multiset&lt;int&gt;::iterator it; 2.插入元素：s.insert(10); 3.删除元素：s.erase(elem);//mutiset返回被移除的元素个数。 s.erase(pos)//移除迭代器pos所指位置元素，无返回值。 4.清空集合：s.clear(); 5.集合元素个数：s.size(); 6.判断集合为是否空：s.empty();//等同于0==size(),效率更高 7.查找集合中是否有元素10，有的话返回10，没有返回s.end(): it=s.find(10); 8.判断两个集合之间的关系：c1==c2(同理有!= &gt; &lt; &gt;= &lt;=) 特殊的搜寻函数: sets和multisets在元素快速搜寻方面做了优化设计，提供了特殊的搜寻函数，所以应优先使用这些搜寻函数，可获得对数复杂度，而非STL的线性复杂度。 比如在1000个元素搜寻，对数复杂度平均十次，而线性复杂度平均需要500次。 1. s.count(elem) 返回元素值为elem的个数 2. s.find(elem) 返回元素值为elem的第一个元素，如果没有返回end() 3. lower_bound(elem) 返回元素值为elem的第一个可安插位置，也就是元素值&gt;=elem的第一个元素位置 4. upper_bound(elem) 返回元素值为elem的最后一个可安插位置，也就是元素值&gt;elem的第一个元素位置 5. equal_range(elem) 返回elem可安插的第一个位置和最后一个位置，也就是元素值==elem的区间 赋值： 1. c1=c2 将c2的元素全部给c1 2. c1.swap(c2) 将c1和c2 的元素互换 3. swap(c1,c2) 同上，全局函数 需要注意的点： 1.是以中序遍历去遍历整个集合的，在插入的时候自动调整 2.遍历的时候需要判断一下集合是否为空； 3.插入的数默认从小到大排序 set&lt;int&gt;::iterator it; 4.如果要从大到小的话 set&lt;int&gt;::reverse_iterator rit; for(rit=s.rbegin();rit!=s.rend();rit++){ cout&lt;&lt;*rit&lt;&lt;&quot; &quot;; } 2.位运算操作之 __builtin_1. __builtin_popcount(unsigned int n) 判断n的二进制中有多少个1 int n = 15; //二进制为1111 cout&lt;&lt;__builtin_popcount(n)&lt;&lt;endl;//输出4 2. __builtin_parity(unsigned int n) 判断n的二进制中1的个数的奇偶性 int n = 15;//二进制为1111 int m = 7;//111 cout&lt;&lt;__builtin_parity(n)&lt;&lt;endl;//偶数个，输出0 cout&lt;&lt;__builtin_parity(m)&lt;&lt;endl;//奇数个，输出1 3. __builtin_ffs(unsigned int n) 返回n的二进制末尾最后一个1的位置，从一开始 int n = 1;//1 int m = 8;//1000 cout&lt;&lt;__builtin_ffs(n)&lt;&lt;endl;//输出1 cout&lt;&lt;__builtin_ffs(m)&lt;&lt;endl;//输出4 4. __builtin_ctz(unsigned int n) 返回n的二进制末尾后面0的个数，当n为0时，和n的类型有关 int n = 1;//1 int m = 8;//1000 cout&lt;&lt;__builtin_ctzll(n)&lt;&lt;endl;//输出0 cout&lt;&lt;__builtin_ctz(m)&lt;&lt;endl;//输出3 5. __builtin_clz(unsigned int n) 返回前导的0的个数 int n = 15//1111 cout&lt;&lt;__builtin_clz(n)&lt;&lt;endl;//输出28 int是32位的32-4=28 3.位运算操作之 bitset头文件#include&lt;bitset&gt; bitset可以看看作一个多位二进制数，每8位占用一个字节，相当于采用了状态压缩的二进制数组，并支持基本的位运算， 在估算程序的运行的时间时，我们一般以32位正数的运算次数为基准，因此n位bitset执行一次位运算的复杂度可视为n/32，效率较高。 相关函数须先声明大小： bitset&lt;10000&gt; bt;//表示一个10000位二进制数，&lt;&gt;中填写位数 初始化： |格式|说明| |------|------| |bitset b| b有n位，每位都为0| |bitset b(u)| b是unsigned long型u的一个副本| |bitset b(s)| b是string对象s中含有的位串的副本| |bitset b(s, pos, n)| b是s中从位置pos开始的n个位的副本| bitset&lt;10&gt; a(&quot;1001&quot;) bt&lt;&lt;1;//b整体左移 bt|=10; //b或 1010``` 1. b.any()//b中是否存在置为1的二进制位？ b.none()//b中不存在置为1的二进制位吗？ 2. b.count();//b中置为1的二进制位的个数 3. b.size();//b中二进制位的个数 4. b[pos]//访问b中在pos处的二进制位 5. b.test(pos)//b中在pos处的二进制位是否为1？ 6. b.set()//把b中所有二进制位都置为1 7. b.set(pos)//把b中在pos处的二进制位置为1 8. b.reset()//把b中所有二进制位都置为0 9. b.reset(pos)//把b中在pos处的二进制位置为0 10. b.flip()//把b中所有二进制位逐位取反 11. b.flip(pos)//把b中在pos处的二进制位取反 12. b.to_ulong()//用b中同样的二进制位返回一个unsigned long值 13. os&lt;&lt;b//把b中的位集输出到os流 4.位运算操作之 &amp;|^~&lt;&lt;&gt;&gt;常见操作： 1. 在一个数指定位上置1 int j=0; j |= 1&lt;&lt;10; 2. 判断指定位上是0还是1 (j&amp;(1&lt;&lt;10)) 3. lowbit运算 lowbit(n) 取出非负整数n在二进制表示下最低位的1以及后边的0构成的数值。 lowbit(n) = n &amp; (~n+1) = n &amp; -n 4. 取出整数n在二进制表示下的第k位: (n&gt;&gt;k) &amp; 1 5. 取出整数n在二进制表示下第0~k-1位（后k位: n &amp; ((1&lt;&lt;k)-1) 6. 把整数n在二进制表示下的第k位取反:n ^ (1&lt;&lt;k) 7. 对整数n在二进制表示下的第k位赋值为1: n \| (1&lt;&lt;k) 8. 对整数n在二进制表示下的第k位赋值为0: n &amp; (~(1&lt;&lt;k))]]></content>
      <categories>
        <category>C++ 杂项</category>
      </categories>
      <tags>
        <tag>C++ 杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-SAT问题]]></title>
    <url>%2F2019%2F12%2F25%2F2-SAT%2F</url>
    <content type="text"><![CDATA[2-SAT问题大牛博客：https://blog.csdn.net/jarjingx/article/details/8521690 https://blog.csdn.net/litble/article/details/80404751 2-SAT问题是适应性问题的一种特殊分支。什么是适应性(Satisfiability)问题呢？就是确定一个满足所有条件的方案。 通俗的SAT问题是：有很多集合，每个集合里有k元素，现给出一些取元素的规则，要我们判断是否可行，若可行给出一个可行方案,这就是k-SAT问题。 当k=2就是2-SAT问题，这一类问题可以通过 暴力DFS 或 转化成连通图问题 解决，而当k&gt;=3就变成了一类NP问题了 主要通过具体题目来理解两种算法，学习如何解决此类问题。 暴力DFS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263先建好图，根据条件来连边，这种算法复杂度爆炸，但是如果题目要求的是字典序最小的方案的话，那就只能选择这个算法了。模版：//HDU-3062#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+5;struct TwoSAT&#123; int n;//原始图的节点数(未翻倍) vector&lt;int&gt; G[maxn*2];//G[i]==j表示如果mark[i]=true,那么mark[j]也要=true bool mark[maxn*2];//标记 int S[maxn*2],c;//S和c用来记录一次dfs遍历的所有节点编号 void init(int n)&#123; this-&gt;n=n; for(int i=0;i&lt;2*n;i++) G[i].clear(); memset(mark,0,sizeof(mark)); &#125; //加入(x,xval)或(y,yval)条件 //xval=0表示假，yval=1表示真 void add_clause(int x,int xval,int y,int yval)&#123; x=x*2+xval;y=y*2+yval; G[x].push_back(y); // G[y^1].push_back(x); &#125; //从x执行dfs遍历,途径的所有点都标记 //如果不能标记,那么返回false bool dfs(int x)&#123; if(mark[x^1]) return false;//这两句的位置不能调换 if(mark[x]) return true; mark[x]=true;S[c++]=x; for(int i=0;i&lt;G[x].size();i++) if(!dfs(G[x][i])) return false; return true; &#125; //判断当前2-SAT问题是否有解 bool solve()&#123; for(int i=0;i&lt;2*n;i+=2) if(!mark[i] &amp;&amp; !mark[i+1])&#123; c=0; if(!dfs(i))&#123; while(c&gt;0) mark[S[--c]]=false; if(!dfs(i+1)) return false; &#125; &#125; return true; &#125;&#125;TS;int main()&#123; ios::sync_with_stdio(0);cin.tie(0); int n,m; while(cin&gt;&gt;n&gt;&gt;m)&#123; TS.init(n); for(int i=0;i&lt;m;i++)&#123; int a,b,c,d;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; TS.add_clause(a,c,b,d^1); TS.add_clause(b,d,a,c^1); &#125; if(!TS.solve()) cout&lt;&lt;"NO"&lt;&lt;endl; else cout&lt;&lt;"YES"&lt;&lt;endl; &#125;&#125; 连通图-Tarjan123456789101112131415161718192021222324252627282930313233343536373839解决一个点数较多的2-SAT问题，我们只能把它转化成连通图，然后用Tarjan (O(n+m))解决了若选A必须选B，那A,B必须在同一个连通分量中，同时A和B'不能在同一个连通分量中否则A,B必定不在同一个连通分量中，同时A和B'一定在同一个连通分量中构图 -&gt; 缩点 -&gt; 判可行 -&gt; 记录矛盾 -&gt; 拓扑排序 -&gt; 构造方案1. 构图2. 缩点：Tarjan算法缩点，将所有的边反过来(因为"选择"标记没有传递,"不选择"标记传递了)3. 判可行：枚举集合的两个元素，看其是否处于不同的块内，若否的话则给出不可行信息4. 记录矛盾：这里所说的矛盾不是题中给出的两个人之间有仇恨，那样的边是实际存在， 我们这里说的矛盾是指若两个块分别含有两个对立节点，也就是说一个集合的两个元素分布在了两个不同的块中，那么这两个块就是矛盾的，即不可能同时被选择， 这样一种矛盾关系是不存在于边中的，是不依赖于输入的数据的，我们要找到与一个块对立的块，并把它们保存下来。5. 拓扑排序：将缩点后的图进行拓扑排序（排的是连通分支而不是节点）6. 构造方案：按照拓扑序列的顺序，依次访问所有块，若一个块未被标记，将其标记为“选择”，不传递“选择”标记，将被选块的对立块标记为“不选择”，将其“不选择”标记沿着边正向传递。vector&lt;int&gt; G[maxn];int dfn[maxn],low[maxn],st[maxn],color[maxn];int a[maxn],b[maxn],n,m,cnt,idx,top;bool ins[maxn];void Tarjan(int u)&#123; dfn[u]=low[u]=++idx; st[++top]=u;ins[u]=1; for(auto &amp;v:G[u])&#123; if(!dfn[v])&#123; Tarjan(v); if(low[v]&lt;low[u]) low[u]=low[v]; &#125; else if(ins[v]) if(dfn[v]&lt;low[u]) low[u]=dfn[v]; &#125; if(low[u]==dfn[u])&#123; cnt++;int t; do&#123; t=st[top--]; color[t]=cnt; ins[t]=0; &#125;while(u!=t); &#125;&#125; 题目边转化为点-缩点-判可行12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//POJ-3207题意：平面上，一个圆，圆的边上按顺时针放着n个点。现在要连m条边，比如a，b，那么a到b可以从圆的内部连接，也可以从圆的外部连接。给你的信息中，每个点最多只会连接的一条边。问能不能连接这m条边，使这些边都不相交。思路：题意可能刚开始不是很好理解，比如1 5连边，2，6连边，由于点是顺序排列的，一画图就可以发现，这两条边必须一个从圆外面连，一个从内部连，否则就会相交。如果再加入3 7这条边，那么就必须相交了。这样，就可以转化成标准的2-sta问题：1：每个边看成2个点：分别表示在内部连接和在外部连接，只能选择一个。计作点i和点i'2：如果两条边i和j必须一个画在内部，一个画在外部（一个简单判断就可以）那么连边：i-&gt;j’, 表示i画内部的话，j只能画外部，即j’j-&gt;i’，同理 i’-&gt;j，同理 j’-&gt;i，同理然后就是2-sat算法了，tarjan一下，如果有i和i'同属于一个强联通，返回false，否则就成立。vector&lt;int&gt; G[maxn];int dfn[maxn],low[maxn],st[maxn],color[maxn];int a[maxn],b[maxn],n,m,cnt,idx,top;bool ins[maxn];void Tarjan(int u)&#123; dfn[u]=low[u]=++idx; st[++top]=u;ins[u]=1; for(auto &amp;v:G[u])&#123; if(!dfn[v])&#123; Tarjan(v); if(low[v]&lt;low[u]) low[u]=low[v]; &#125; else if(ins[v]) if(dfn[v]&lt;low[u]) low[u]=dfn[v]; &#125; if(low[u]==dfn[u])&#123; cnt++;int t; do&#123; t=st[top--]; color[t]=cnt; ins[t]=0; &#125;while(u!=t); &#125;&#125;int main()&#123; fastinout;cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;=m-1;i++)&#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; if(a[i]&gt;b[i]) swap(a[i],b[i]); &#125; for(int i=0;i&lt;=m-1;i++)&#123; for(int j=i+1;j&lt;=m-1;j++)&#123; if(a[i]&lt;a[j]&amp;&amp;b[i]&gt;a[j]&amp;&amp;b[i]&lt;b[j]||b[i]&gt;b[j]&amp;&amp;a[i]&gt;a[j]&amp;&amp;a[i]&lt;b[j])&#123; G[i*2].push_back(j*2+1);G[i*2+1].push_back(j*2); G[j*2].push_back(i*2+1);G[j*2+1].push_back(i*2); &#125; &#125; &#125; for(int i=0;i&lt;=2*m-1;i++) if(!dfn[i]) Tarjan(i); for(int i=0;i&lt;=2*m-1;i++) if(color[i]==color[i^1])&#123; cout&lt;&lt;"the evil panda is lying again"&lt;&lt;endl; return 0; &#125; cout&lt;&lt;"panda is telling the truth..."&lt;&lt;endl;&#125; 判可行-输出方案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116题意：有n对新人要举行仪式，每对都有两个时间段可以选择，问是否可以所有新人的仪式时间不重叠思路：2-sat，把仪式可以选择的两个时间段看成两个点，仪式时间重叠的即为矛盾关系//POJ-3683#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define mem(a,b) memset(a,b,sizeof(a))const int maxn=3005;using namespace std;vector&lt;int&gt; G[maxn],DAG[maxn];int dfn[maxn],low[maxn],st[maxn],num[maxn];int n,m,scc,idx,top;bool ins[maxn];int s[maxn],e[maxn],l[maxn],color[maxn],ha[maxn];int ind[maxn];queue&lt;int&gt; que;void init()&#123; idx=scc=top=0; mem(ins,0);mem(ind,0);mem(dfn,0);mem(low,0);mem(st,0);mem(num,0);mem(ha,0); for(int i=0;i&lt;maxn;i++) G[i].clear(),DAG[i].clear(); while(!que.empty()) que.pop();&#125;bool check(int lx,int ly,int rx,int ry)&#123;//判断时间是否重叠 if(lx&gt;=rx&amp;&amp;lx&lt;=ry) return 0; if(ly&gt;=rx&amp;&amp;ly&lt;=ry) return 0; if(rx&gt;=lx&amp;&amp;rx&lt;=ly) return 0; if(ry&gt;=lx&amp;&amp;ry&lt;=ly) return 0; return 1;&#125;void build()&#123; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++)&#123;//如果重叠，则连边，注意时间的传入&amp;加边的方式 //第一个if 如果i开头与j开头冲突，那么i开头与j结尾联结("必须"正向传递)(i与j+n连边) 同时 j结尾与i开头联结(j与i+n连边) if(check(s[i],s[i]+l[i]-1,s[j],s[j]+l[j]-1)==0) G[i].push_back(j+n),G[j].push_back(i+n); if(check(s[i],s[i]+l[i]-1,e[j]-l[j],e[j]-1)==0) G[i].push_back(j),G[j+n].push_back(i+n); if(check(e[i]-l[i],e[i]-1,s[j],s[j]+l[j]-1)==0) G[i+n].push_back(j+n),G[j].push_back(i); if(check(e[i]-l[i],e[i]-1,e[j]-l[j],e[j]-1)==0) G[i+n].push_back(j),G[j+n].push_back(i); &#125;&#125;void Tarjan(int u)&#123; dfn[u]=low[u]=++idx; st[++top]=u;ins[u]=1; for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i]; if(!dfn[v])&#123;Tarjan(v);low[u]=min(low[u],low[v]);&#125; else if(ins[v]) low[u]=min(low[u],dfn[v]); &#125; if(low[u]==dfn[u])&#123; scc++;int t; do&#123; t=st[top--];color[t]=scc;ins[t]=0; &#125;while(u!=t); &#125;&#125;void build_DAG()&#123; for(int u=1;u&lt;=2*n;u++)&#123; for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i]; if(color[u]==color[v]) continue; DAG[color[v]].push_back(color[u]);//反向建图 ind[color[u]]++; &#125; &#125;&#125;void Topsort()&#123; for(int i=1;i&lt;=scc;i++) if(ind[i]==0) que.push(i); while(!que.empty())&#123; int u=que.front();que.pop(); if(!num[u]) num[u]=1,num[ha[u]]=2;//拓扑排序 选择在哪个集合 for(int i=0;i&lt;DAG[u].size();i++)&#123; int v=DAG[u][i];ind[v]--; if(ind[v]==0) que.push(v); &#125; &#125;&#125;void solve()&#123; for(int i=1;i&lt;=2*n;i++) if(!dfn[i]) Tarjan(i); for(int i=1;i&lt;=n;i++) if(color[i]==color[i+n])&#123;printf("NO\n");return;&#125; else ha[color[i]]=color[i+n],ha[color[i+n]]=color[i];//两个连通块也是对立的 build_DAG();Topsort();printf("YES\n"); for(int i=1;i&lt;=n;i++) if(num[color[i]]==1)&#123; int h1,h2,m1,m2; h1=s[i]/60;h2=(s[i]+l[i])/60; m1=s[i]%60;m2=(s[i]+l[i])%60; printf("%02d:%02d %02d:%02d\n",h1,m1,h2,m2); &#125; else&#123; int h1,h2,m1,m2; h1=(e[i]-l[i])/60;h2=e[i]/60; m1=(e[i]-l[i])%60;m2=e[i]%60; printf("%02d:%02d %02d:%02d\n",h1,m1,h2,m2); &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; init(); for(int i=1;i&lt;=n;i++)&#123; int h,m; scanf("%d:%d",&amp;h,&amp;m);s[i]=h*60+m; scanf("%d:%d",&amp;h,&amp;m);e[i]=h*60+m; scanf("%d",&amp;l[i]); &#125; build(); solve(); &#125;&#125; 判可行-输出方案//POJ-3648 这题和上面的是一样的 题意：有一对新娘新郎要准备婚礼，邀请了n-1对夫妇，有一对长桌，新娘和新郎首先坐在长桌的两侧。 其次对于每对夫妇有如下要求，即丈夫和妻子不能坐在同一侧。 其次其中m对夫妇有通奸关系，有通奸关系的不能同时坐在新娘的对面（可以同性）， 求新娘这边一种合理的座位方式。 思路： 很明显的模型了，由于新娘看的是对面的情况，所以就需要对新娘对面的人来分析建图，n对夫妇是2 *n个点， n对夫妇每对夫妇只能挑一个到新娘对面坐下，这很符合2-sat的初始的状态。然后又有一些不正常关系，就需要分别建图了。 并且初始时应该是丈夫坐在新娘对面的，新娘编号为0，丈夫为1的话，必须加一条（0,1）的边表示丈夫必然坐在对面。 建完图后缩点，判断有没有解后，需要建新图，即缩点后的逆序图，然后进行拓扑排序，染色。 注意，我们需要将每对夫妻两者各自代表的强连通分量映射起来，表示这两个强连通分量是不可以在一块的。 这样在新图染色的时候，每染到一个点，根据刚才存储的映射将对应的点染为别的颜色。最后输出解时，找跟新娘同色的解即为和新娘同一排的人。 #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #define mem(a,b) memset(a,b,sizeof(a)) const int maxn=100; using namespace std; vector&lt;int&gt; G[maxn],DAG[maxn]; int dfn[maxn],low[maxn],st[maxn],num[maxn]; int n,m,scc,idx,top; bool ins[maxn]; int color[maxn],ha[maxn]; int ind[maxn]; queue&lt;int&gt; que; void init(){ idx=scc=top=0; mem(ins,0);mem(ind,0);mem(dfn,0);mem(low,0);mem(st,0);mem(num,0);mem(ha,0); for(int i=0;i&lt;maxn;i++) G[i].clear(),DAG[i].clear(); while(!que.empty()) que.pop(); } void Tarjan(int u){ dfn[u]=low[u]=++idx; st[++top]=u;ins[u]=1; for(int i=0;i&lt;G[u].size();i++){ int v=G[u][i]; if(!dfn[v]){Tarjan(v);low[u]=min(low[u],low[v]);} else if(ins[v]) low[u]=min(low[u],dfn[v]); } if(low[u]==dfn[u]){ scc++;int t; do{ t=st[top--];color[t]=scc;ins[t]=0; }while(u!=t); } } void build_DAG(){ for(int u=1;u&lt;=2*n;u++){ for(int i=0;i&lt;G[u].size();i++){ int v=G[u][i]; if(color[u]==color[v]) continue; DAG[color[v]].push_back(color[u]);//反向建图 ind[color[u]]++; } } } void Topsort(){ for(int i=1;i&lt;=scc;i++) if(ind[i]==0) que.push(i); while(!que.empty()){ int u=que.front();que.pop(); if(!num[u]) num[u]=1,num[ha[u]]=2;//拓扑排序 选择在哪个集合 for(int i=0;i&lt;DAG[u].size();i++){ int v=DAG[u][i];ind[v]--; if(ind[v]==0) que.push(v); } } } void solve(){ for(int i=1;i&lt;=2*n;i++) if(!dfn[i]) Tarjan(i); for(int i=1;i&lt;=n;i++) if(color[i]==color[i+n]){cout&lt;&lt;&quot;bad luck&quot;&lt;&lt;endl;return;} else ha[color[i]]=color[i+n],ha[color[i+n]]=color[i];//两个连通块也是对立的 build_DAG();Topsort(); for(int i=2;i&lt;=n;i++) if(num[color[i]]==num[color[1]]) cout&lt;&lt;i-1&lt;&lt;&quot;w &quot;; else cout&lt;&lt;i-1&lt;&lt;&quot;h &quot;; cout&lt;&lt;endl; } int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); while(cin&gt;&gt;n&gt;&gt;m,(n+m)){ init(); int x,y;char cx,cy; for(int i=0;i&lt;m;i++){ cin&gt;&gt;x&gt;&gt;cx&gt;&gt;y&gt;&gt;cy;x++;y++; int a0,a1,b0,b1; if(cx==&apos;h&apos;) a0=x,a1=x+n; else a0=x+n,a1=x; if(cy==&apos;h&apos;) b0=y,b1=y+n; else b0=y+n,b1=y; G[a1].push_back(b0); G[b1].push_back(a0); } G[1].push_back(1+n); solve(); } } 暴力DFS-输出字典序最小//题意：有n队的人，编号从1-2*n，m对的人之间互相不喜欢，每对人中必徐选1个人加入和平委员会，求字典序最小的解 //DFS解法，O(nm) #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=8e3+5; struct TwoSAT{ int n; vector&lt;int&gt; G[maxn*2]; bool mark[maxn*2]; int S[maxn*2],c; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;2*n;i++) G[i].clear(); memset(mark,0,sizeof(mark)); } void add_clause(int x,int y){ G[x].push_back(y); } bool dfs(int x){ if(mark[x^1]) return false;//这两句的位置不能调换 if(mark[x]) return true; mark[x]=true;S[c++]=x; for(int i=0;i&lt;G[x].size();i++) if(!dfs(G[x][i])) return false; return true; } //判断当前2-SAT问题是否有解 bool solve(){ for(int i=0;i&lt;2*n;i+=2) if(!mark[i] &amp;&amp; !mark[i+1]){ c=0; if(!dfs(i)){ while(c&gt;0) mark[S[--c]]=false; if(!dfs(i+1)) return false; } } return true; } }TS; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n,m; while(cin&gt;&gt;n&gt;&gt;m){ TS.init(n); for(int i=0;i&lt;m;i++){//a^1-&gt; 若a=2*k+1 则a^1=2*k ,若a=2*k 则a^1=2*k+1 int a,b,c,d;cin&gt;&gt;a&gt;&gt;b;a--,b--;//a,b不能共存 TS.add_clause(a,b^1);//a只能和b^1共存 TS.add_clause(b,a^1);//b只能和a^1共存 } if(!TS.solve()) cout&lt;&lt;&quot;NIE&quot;&lt;&lt;endl; else{ for(int i=0;i&lt;2*n;i+=2) if(TS.mark[i]) cout&lt;&lt;i+1&lt;&lt;endl; else cout&lt;&lt;i+2&lt;&lt;endl; } } } 二分+判可行//POJ-2723 题意：现在有N对钥匙（一共2N把，编号从0到2N-1），每对钥匙只能选其中一把。 另有M扇门，每扇门能够被两把钥匙a，b中的任意一把打开，问能开的最大门数是多少（开门为递增顺序） 思路：2-SAT,找到矛盾关系。 ①如果a，b出现在同一对钥匙里，只能拿a或拿b。 ②如果c，d能打开同一扇门，为了最大化开门数，我们假定，不用c开门或不用d开门。 蕴含式表示形式：a-&gt;!b和b-&gt;!a，!c-&gt;d和!d-&gt;c。按照这个建图，求scc，如果i和i+2*n在一个强连通分量里（即i和!i在同一个主合取范式里）则无解。 由于求的是最大值，所以二分处理。 #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #define mem(a,b) memset(a,b,sizeof(a)) const int maxn=5005; using namespace std; vector&lt;int&gt; G[maxn]; int dfn[maxn],low[maxn],st[maxn],color[maxn]; int n,m,scc,idx,top; bool ins[maxn]; queue&lt;int&gt; que; int a[maxn],b[maxn],X[maxn],Y[maxn]; void init(){ idx=scc=top=0; mem(ins,0);mem(dfn,0);mem(low,0);mem(st,0); for(int i=0;i&lt;maxn;i++) G[i].clear(); while(!que.empty()) que.pop(); } void Tarjan(int u){ dfn[u]=low[u]=++idx; st[++top]=u;ins[u]=1; for(int i=0;i&lt;G[u].size();i++){ int v=G[u][i]; if(!dfn[v]){Tarjan(v);low[u]=min(low[u],low[v]);} else if(ins[v]) low[u]=min(low[u],dfn[v]); } if(low[u]==dfn[u]){ scc++;int t; do{ t=st[top--];color[t]=scc;ins[t]=0; }while(u!=t); } } void build(int bound){建图需要仔细体会理解其中的相互关系 init(); for(int i=1;i&lt;=n;i++){//ab中只能选一把 G[a[i]].push_back(b[i]+2*n);//选a就不能选b G[b[i]].push_back(a[i]+2*n); } for(int i=1;i&lt;=bound;i++){//xy中必须选一把 G[X[i]+2*n].push_back(Y[i]);//不选X就必须选Y G[Y[i]+2*n].push_back(X[i]); } for(int i=1;i&lt;=2*n;i++) if(!dfn[i]) Tarjan(i); } bool check(int n){ for(int i=1;i&lt;=n;i++) if(color[i]==color[i+n]) return 0; return 1; } void solve(){ int ans=0,l=0,r=m; while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; build(mid); if(check(n*2)) ans=max(ans,mid),l=mid+1; else r=mid-1; } cout&lt;&lt;ans&lt;&lt;endl; } int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); while(cin&gt;&gt;n&gt;&gt;m,(n+m)){ for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]&gt;&gt;b[i];a[i]++;b[i]++; } for(int i=1;i&lt;=m;i++){ cin&gt;&gt;X[i]&gt;&gt;Y[i];X[i]++;Y[i]++; } solve(); } }]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络流]]></title>
    <url>%2F2019%2F07%2F30%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[网络流重在建图,再套模版 -最大流、最小割、最大匹配、最大权闭合图 模版模版1(Dinic-SPFA from CSL O(nnm))#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e4+5; struct Edge{ int from,to,cap,flow; Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){} }; struct Dinic{ int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn],cur[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap){ edges.emplace_back(from,to,cap,0); edges.emplace_back(to,from,0,0); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BFS(){ memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); queue&lt;int&gt; q;q.push(s); d[s]=0;vis[s]=1; while(!q.empty()){ int x=q.front();q.pop(); for(int i=0;i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){ vis[e.to]=1;d[e.to]=d[x]+1;q.push(e.to); } } } return vis[t]; } int DFS(int x,int a){ if(x==t||a==0) return a; int flow=0,f; for(int&amp; i=cur[x];i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(d[x]+1==d[e.to]&amp;&amp;(f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){ e.flow+=f;edges[G[x][i]^1].flow-=f; flow+=f;a-=f;if(a==0) break; } } return flow; } int Maxflow(int s,int t){ this-&gt;s=s;this-&gt;t=t; int flow=0; while(BFS()){ memset(cur,0,sizeof(cur)); flow+=DFS(s,INF); } return flow; } }; 模版2(Dijkstr-MCMF from NBWY)#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;int,int&gt; pii; const int maxn=1e4; const int INF=0x7fffffff; struct edge{ int to,capacity,cost,rev; edge(){} edge(int to,int _capacity,int _cost,int _rev):to(to),capacity(_capacity),cost(_cost),rev(_rev) {} }; struct Min_Cost_Max_Flow { int V,H[maxn],dis[maxn+5],PreV[maxn+5],PreE[maxn+5]; vector&lt;edge&gt; G[maxn]; void init(int n){ V=n;for(int i=0;i&lt;=V;++i)G[i].clear(); } void Add_Edge(int from,int to,int cap,int cost){ G[from].push_back(edge(to, cap, cost, G[to].size())); G[to].push_back(edge(from, 0, -cost, G[from].size() - 1)); } //flow是自己传进去的变量，就是最后的最大流，返回的是最小费用 int Min_cost_max_flow(int s,int t,int f,int&amp; flow){ int res=0;fill(H,H+1+V,0); while(f){ priority_queue &lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt; &gt; q; fill(dis,dis+1+V,INF); dis[s]=0;q.push(pair&lt;int,int&gt;(0,s)); while(!q.empty()){ pair&lt;int,int&gt; now=q.top();q.pop(); int v=now.second; if(dis[v]&lt;now.first) continue; for(int i=0;i&lt;G[v].size();++i){ edge&amp; e=G[v][i]; if(e.capacity&gt;0&amp;&amp;dis[e.to]&gt;dis[v]+e.cost+H[v]-H[e.to]){ dis[e.to]=dis[v]+e.cost+H[v]-H[e.to]; PreV[e.to]=v;PreE[e.to]=i; q.push(pair&lt;int,int&gt;(dis[e.to],e.to)); } } } if(dis[t]==INF)break; for(int i=0;i&lt;=V;++i) H[i]+=dis[i]; int d=f; for(int v=t;v!=s;v=PreV[v]) d=min(d,G[PreV[v]][PreE[v]].capacity); f-=d;flow+=d;res+=d*H[t]; for (int v=t;v!=s;v=PreV[v]){ edge&amp; e=G[PreV[v]][PreE[v]]; e.capacity-=d; G[v][e.rev].capacity+=d; } } return res; } int Max_cost_max_flow(int s,int t,int f, int&amp; flow) { int res=0; fill(H,H+1+V,0); while(f){ priority_queue &lt;pair&lt;int, int&gt;&gt; q; fill(dis,dis+1+V,-INF); dis[s]=0; q.push(pair&lt;int,int&gt;(0,s)); while(!q.empty()){ pair&lt;int,int&gt; now=q.top();q.pop(); int v=now.second; if(dis[v]&gt;now.first)continue; for (int i=0;i&lt;G[v].size();i++){ edge&amp; e=G[v][i]; if(e.capacity&gt;0&amp;&amp;dis[e.to]&lt;dis[v]+e.cost+H[v]-H[e.to]){ dis[e.to]=dis[v]+e.cost+H[v]-H[e.to]; PreV[e.to]=v;PreE[e.to]=i; q.push(pair&lt;int,int&gt;(dis[e.to],e.to)); } } } if(dis[t]==-INF)break; for(int i=0;i&lt;=V;i++) H[i]+=dis[i]; int d=f; for(int v=t;v!=s;v=PreV[v]) d=min(d,G[PreV[v]][PreE[v]].capacity); f-=d;flow+=d; res+=d*H[t]; for(int v=t;v!=s;v=PreV[v]){ edge&amp; e=G[PreV[v]][PreE[v]]; e.capacity-=d; G[v][e.rev].capacity+=d; } } return res; } }; int flow,a[maxn]; Min_Cost_Max_Flow MCMF; int main() { int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ int n,k;scanf(&quot;%d%d&quot;,&amp;n,&amp;k); MCMF.init(2*n+2); for(int i=1;i&lt;= n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); MCMF.Add_Edge(i,i+n,1,-a[i]); } for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) if (a[i]&lt;=a[j]) MCMF.Add_Edge(i+n,j,1,0); MCMF.Add_Edge(0,2*n+1,k,0); for(int i=1;i&lt;=n;++i) { MCMF.Add_Edge(2*n+1,i,1,0); MCMF.Add_Edge(i+n,2*n+2,1,0); } cout&lt;&lt;-MCMF.Min_cost_max_flow(0,2*n+2,INF,flow)&lt;&lt;endl; return 0; } } 模版3(Dijkstr-Bellman from CSL)#include&lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int INF=0x3f3f3f3f; const int maxn=2005; struct Edge{ int from,to,cap,flow,cost; Edge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w){} }; struct MCMF { int n,m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn]; int d[maxn]; int p[maxn]; int a[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap,int cost){ edges.emplace_back(from,to,cap,0,cost); edges.emplace_back(to,from,0,0,-cost); int m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BellmanFord(int s,int t,int &amp;flow,ll &amp;cost){ for(int i=0;i&lt;n;i++) d[i]=INF; memset(inq,0,sizeof(inq));d[s]=0;inq[s]=1;p[s]=0;a[s]=INF; queue&lt;int&gt; q;q.push(s); while(!q.empty()){ int u=q.front();q.pop();inq[u]=0; for(int i=0;i&lt;G[u].size();i++){ Edge&amp; e=edges[G[u][i]]; if(e.cap&gt;e.flow&amp;&amp;d[e.to]&gt;d[u]+e.cost){ d[e.to]=d[u]+e.cost;p[e.to]=G[u][i]; a[e.to]=min(a[u],e.cap-e.flow); if(!inq[e.to]){ q.push(e.to);inq[e.to]=1; } } } } if(d[t]==INF) return 0; flow+=a[t]; cost+=(ll)d[t]*(ll)a[t]; for(int u=t;u!=s;u=edges[p[u]].from){ edges[p[u]].flow+=a[t]; edges[p[u]^1].flow-=a[t]; } return 1; } int MincostMAXflow(int s,int t,ll &amp;cost){ int flow=0;cost=0; while(BellmanFord(s,t,flow,cost)); return flow; } }Mc; 模版4(最大匹配)#include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 105; int n, m; vector&lt;int&gt; G[maxn]; int linker[maxn]; bool used[maxn]; inline void init(int n) { for (int i = 0; i &lt;= n; i++) G[i].clear(); } inline void addedge(int u, int v) { G[u].push_back(v); } inline bool dfs(int u) { for (auto &amp;v : G[u]) { if (!used[v]) { used[v] = 1; if (linker[v] == -1 || dfs(linker[v])) { linker[v] = u; return 1; } } } return 0; } inline int hungary() { int ans = 0; memset(linker, -1, sizeof(linker)); for (int u = 1; u &lt;= m; u++) {//左边点的个数 memset(used, 0, sizeof(used)); if (dfs(u)) ans++; } return ans; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int u, v; while (~scanf(&quot;%d%d&quot;, &amp;u, &amp;v)) { addedge(u, v); } printf(&quot;%d\n&quot;, hungary()); } 题目题源：https://loj.ac/problems/search?keyword=%E7%BD%91%E7%BB%9C%E6%B5%81 1.飞行员配对方案问题(最大匹配)题意：每架飞机需要两个驾驶员，一个正驾驶员和一个副驾驶员。由于种种原因，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。两个正驾驶员或两个副驾驶员都不能同机飞行。 思路：拆点跑网络流或二分图最大匹配裸题，备忘两种都写了 1.拆点网络流 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=500; const int INF=0x3f3f3f3f; struct Edge{ int from,to,cap,flow; Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){} }; struct Dinic{ int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn],cur[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap){ edges.emplace_back(from,to,cap,0); edges.emplace_back(to,from,0,0); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BFS(){ memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); queue&lt;int&gt; q;q.push(s); d[s]=0;vis[s]=1; while(!q.empty()){ int x=q.front();q.pop(); for(int i=0;i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){ vis[e.to]=1;d[e.to]=d[x]+1;q.push(e.to); } } } return vis[t]; } int DFS(int x,int a){ if(x==t||a==0) return a; int flow=0,f; for(int&amp; i=cur[x];i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(d[x]+1==d[e.to]&amp;&amp;(f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){ e.flow+=f;edges[G[x][i]^1].flow-=f; flow+=f;a-=f;if(a==0) break; } } return flow; } int Maxflow(int s,int t){ this-&gt;s=s;this-&gt;t=t; int flow=0; while(BFS()){ memset(cur,0,sizeof(cur)); flow+=DFS(s,INF); } return flow; } }Dic; int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int x=0; Dic.init(2*n+2); for(int i=1;i&lt;=n;i++) Dic.AddEdge(i,i+n,1); int u,v; while(~scanf(&quot;%d%d&quot;,&amp;u,&amp;v)){ Dic.AddEdge(u+n,v,1); } for(int i=1;i&lt;=m;i++) Dic.AddEdge(0,i,1); for(int i=m+1;i&lt;=n;i++) Dic.AddEdge(i+n,2*n+1,1); int ans=Dic.Maxflow(0,2*n+1); printf(&quot;%d\n&quot;,ans); } 2.二分图最大匹配 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 105; int n, m; vector&lt;int&gt; G[maxn]; int linker[maxn]; bool used[maxn]; inline void init(int n) { for (int i = 0; i &lt;= n; i++) G[i].clear(); } inline void addedge(int u, int v) { G[u].push_back(v); } inline bool dfs(int u) { for (auto &amp;v : G[u]) { if (!used[v]) { used[v] = 1; if (linker[v] == -1 || dfs(linker[v])) { linker[v] = u; return 1; } } } return 0; } inline int hungary() { int ans = 0; memset(linker, -1, sizeof(linker)); for (int u = 1; u &lt;= m; u++) { memset(used, 0, sizeof(used)); if (dfs(u)) ans++; } return ans; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int u, v; while (~scanf(&quot;%d%d&quot;, &amp;u, &amp;v)) { addedge(u, v); } printf(&quot;%d\n&quot;, hungary()); } 2.太空飞行计划（最大点权闭合子图）最大权闭合子图：给定带权图G(权值可正可负),求一个权和最大的点集，使得起点在该点集中的任意弧，终点也在该点集中 解法：新增源点s和汇点t，从s向所有正权点引一条边，容量为权值；从所有负权点向汇点引一条边，容量为权值的相反数。求出最小割f,S-{s}就是最大权闭合子图。 题意：现已确定了一个可供选择的实验集合 E={E1,E2,⋯,Em}，和进行这些实验需要使用的全部仪器的集合 I={I1,I2,⋯,In}。实验 Ej 需要用到的仪器是 I 的子集 Rj⊆I。 配置仪器 Ik​​ 的费用为 ck​​ 美元。实验 Ej 的赞助商已同意为该实验结果支付 pj 美元。对于给定的实验和仪器配置情况，找出净收益最大的试验计划. 思路：最大权闭合子图。从 S 向每个实验连一条容量为 pi 的边，每个实验向所需要的仪器连一条容量为INF的边，每个仪器向 T 连一条容量为 ci 的边。答案为 ∑pi−maxflow 。 对于输出方案，如果d[i]!=0那么i点显然走过了。输出即可 输入输出太坑了！！！ vector&lt;int&gt; v1,v2; int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;m,&amp;n);Dic.init(n+m+2); int S=0; for(int i=1;i&lt;=m;i++){ int p,v;char ch;scanf(&quot;%d&quot;,&amp;p);S+=p; Dic.AddEdge(0,i,p); while(getchar()==&apos; &apos;){ scanf(&quot;%d&quot;,&amp;v); Dic.AddEdge(i,v+m,INF); } } for(int i=m+1;i&lt;=n+m;i++){ int c;scanf(&quot;%d&quot;,&amp;c); Dic.AddEdge(i,n+m+1,c); } int ans=S-Dic.Maxflow(0,n+m+1); v1.clear();v2.clear(); for(int i=1;i&lt;=m;i++) if(Dic.d[i]!=0) v1.push_back(i); for(int i=1;i&lt;=n;i++) if(Dic.d[i+m]!=0) v2.push_back(i); printf(&quot;%d&quot;,v1[0]);for(int i=1;i&lt;v1.size();i++) printf(&quot; %d&quot;,v1[i]);printf(&quot;\n&quot;); printf(&quot;%d&quot;,v2[0]);for(int i=1;i&lt;v2.size();i++) printf(&quot; %d&quot;,v2[i]);printf(&quot;\n&quot;); printf(&quot;%d\n&quot;,ans); } 3.最小路径覆盖(二分图匹配) 定义：通俗点讲，就是在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。 最小路径覆盖分为最小不相交路径覆盖和最小可相交路径覆盖。 最小不相交路径覆盖：每一条路径经过的顶点各不相同。如图，其最小路径覆盖数为3。即1-&gt;3&gt;4，2，5。 最小可相交路径覆盖：每一条路径经过的顶点可以相同。如果其最小路径覆盖数为2。即1-&gt;3-&gt;4，2-&gt;3&gt;5。 DAG的最小不相交路径覆盖:拆点得二分图，最小路径覆盖=原图节点数-新图最大匹配数 把原图的每个点V拆成Vx和Vy两个点，如果有一条有向边A-&gt;B，那么就加边Ax−&gt;By。这样就得到了一个二分图。那么最小路径覆盖=原图的结点数-新图的最大匹配数 一开始每个点都是独立的为一条路径，总共有n条不相交路径。我们每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，也就相当于路径数减少了1。所以找到了几条匹配边，路径数就减少了多少。所以有最小路径覆盖=原图的结点数-新图的最大匹配数。 DAG的最小可相交路径覆盖：先用floyd求出原图的传递闭包，即如果a到b有路径，那么就加边a-&gt;b。然后就转化成了最小不相交路径覆盖问题。 为了连通两个点，某条路径可能经过其它路径的中间点。比如1-&gt;3-&gt;4，2-&gt;4-&gt;5。但是如果两个点a和b是连通的，只不过中间需要经过其它的点，那么可以在这两个点之间加边，那么a就可以直达b，不必经过中点的，那么就转化成了最小不相交路径覆盖。 题意：给定有向图 G=(V,E)。设 P 是 G 的一个简单路（顶点不相交）的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。 P 中路径可以从 V 的任何一个顶点开始，长度也是任意的， 特别地，可以为 0。G 的最小路径覆盖是 G 的所含路径条数最少的路径覆盖。 求一个有向无环图 G 的最小路径覆盖。 分析：二分图最大匹配。将每个点拆为两个点，在新图中对应连边。二分图的每一个合法匹配都可以视为一种路径覆盖的方式，路径条数为总点数-匹配数。最小不相交路径覆盖即为总点数-二分图最大匹配。（建图方式仅限DAG） 此题需要输出路径，根据匹配找路径即可，注意记录路径 #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 505; vector&lt;int&gt; G[maxn]; int linker[maxn]; bool used[maxn]; inline void init(int n){ for(int i=0;i&lt;=n;i++) G[i].clear(); } inline void addedge(int u,int v){G[u].push_back(v);} inline bool dfs(int u){ for (auto &amp;v:G[u]){ if (!used[v]){ used[v]=1; if(linker[v]==-1||dfs(linker[v])){ linker[v] = u;linker[u]=v;//记录路径 return 1; } } } return 0; } inline int hungary(int n){ int ans=0; memset(linker,-1,sizeof(linker)); for (int u=1;u&lt;=n;u++){//左边点的个数 memset(used,0,sizeof(used)); if(dfs(u)) ans++; } return ans; } inline void print(int u,int n){ printf(&quot; %d&quot;,u-n); if(linker[u-n]!=-1) print(linker[u-n],n); } int main() { int n,m,u,v; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); while(m--){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v+n); } int ans=hungary(n); for(int i=n+1;i&lt;=2*n;i++){ if(linker[i]==-1){ printf(&quot;%d&quot;,i-n); if(linker[i-n]!=-1) print(linker[i-n],n); printf(&quot;\n&quot;); } } printf(&quot;%d\n&quot;,n-ans); } 若使用网络流算法可以根据每两点之间流量的关系找回路径，下面是NB网友的代码： int main() { n=read();m=read();S=0;T=n*2+1; for(int i=1;i&lt;=m;i++) { x=read();y=read(); insert(x,y+n,1); } for(int i=1;i&lt;=n;i++)insert(S,i,1); for(int i=1;i&lt;=n;i++)insert(i+n,T,1); while(bfs()) { for(int i=S;i&lt;=T;i++)cur[i]=first[i]; ans+=dfs(S,inf); } for(int x=1;x&lt;=n;x++) for(int i=first[x];i;i=e[i].next) if(!e[i].flow&amp;&amp;e[i].to)to[x]=e[i].to-n,ind[e[i].to-n]++; for(int x=1;x&lt;=n;x++) if(!ind[x]) { for(int i=x;i;i=to[i])printf(&quot;%d &quot;,i); printf(&quot;\n&quot;); } printf(&quot;%d\n&quot;,n-ans); return 0; } 4.魔术球(待补)#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int from,to,cap,flow; Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){} }; struct Dinic{ int n,m,s,t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn],cur[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap){ edges.emplace_back(from,to,cap,0); edges.emplace_back(to,from,0,0); m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BFS(){ memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); queue&lt;int&gt; q;q.push(s); d[s]=0;vis[s]=1; while(!q.empty()){ int x=q.front();q.pop(); for(int i=0;i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){ vis[e.to]=1;d[e.to]=d[x]+1;q.push(e.to); } } } return vis[t]; } int DFS(int x,int a){ if(x==t||a==0) return a; int flow=0,f; for(int&amp; i=cur[x];i&lt;G[x].size();i++){ Edge&amp; e=edges[G[x][i]]; if(d[x]+1==d[e.to]&amp;&amp;(f=DFS(e.to,min(a,e.cap-e.flow)))&gt;0){ e.flow+=f;edges[G[x][i]^1].flow-=f; flow+=f;a-=f;if(a==0) break; } } return flow; } int Maxflow(int s,int t){ this-&gt;s=s;this-&gt;t=t; int flow=0; while(BFS()){ memset(cur,0,sizeof(cur)); flow+=DFS(s,INF); } return flow; } }Dic; bool check(int x,int y){ int t=sqrt(x+y); return t*t==x+y; } int to[maxn]; int main() { int n; while(~scanf(&quot;%d&quot;,&amp;n)){ int s=0,t=401,cnt=0,ans=0;Dic.init(401); while(1){ ans++;cnt++;Dic.AddEdge(s,ans,1); Dic.AddEdge(ans+200,t,1); for(int i=1;i&lt;ans;i++) if(check(i,ans)) Dic.AddEdge(i,ans+200,1); cnt-=Dic.Maxflow(s,t); if(cnt&gt;n) break; }ans--; printf(&quot;%d\n&quot;,ans); for(int i=1;i&lt;=ans;i++) for(auto &amp;v:Dic.G[i]) if(!Dic.edges[v].flow&amp;&amp;Dic.edges[v].to){ to[i]=Dic.edges[v].to-200;break; } for(int i=1;i&lt;=ans;i++) if(!Dic.vis[i]){ for(int j=i;j;j=to[j]) printf(&quot;%d &quot;,j),Dic.vis[i]=1; printf(&quot;\n&quot;); } } } 5.圆桌聚餐(最大流)题意：来自n个不同单位的代表参加一次国际会议。每个单位的代表数分别为ri。会议餐厅共有m张餐桌，每张餐桌可容纳ci个代表就餐。为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试给出满足要求的代表就餐方案。 思路：最大流。从S向每个单位连一条容量为人数的边，从餐桌向T连接一条容量为餐桌容量的边，从单位向每个餐桌连一条容量为1的边。直接跑最大流求解。 注意判断是否有解应该是将最大流与总人数比较，若最大流等于总人数输出1，否则输出0； int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int s=0,t=n+m+1,sum=0;Dic.init(n+m+1); for(int i=1;i&lt;=n;i++){ int x;scanf(&quot;%d&quot;,&amp;x);Dic.AddEdge(s,i,x);sum+=x; } for(int i=n+1;i&lt;=n+m;i++){ int x;scanf(&quot;%d&quot;,&amp;x);Dic.AddEdge(i,t,x); } for(int i=1;i&lt;=n;i++){ for(int j=n+1;j&lt;=n+m;j++){ Dic.AddEdge(i,j,1); } } int ans=Dic.Maxflow(s,t); if(ans&gt;=sum) printf(&quot;1\n&quot;); else {printf(&quot;0\n&quot;);return 0;} for(int i=1;i&lt;=n;i++){ for(auto &amp;v:Dic.G[i]){ if(Dic.edges[v].flow&gt;0) printf(&quot;%d &quot;,Dic.edges[v].to-n); } printf(&quot;\n&quot;); } } 6.最长递增子序列问题(最大流)题意：给定正整数序列x1∼xn,以下递增均为非严格递增.计算其最长递增子序列的长度s;计算从给定的序列中最多可取出多少个长度为s的递增子序列。 如果允许在取出的序列中多次使用x1​和xn,则从给定序列中最多可取出多少个长度为s的递增子序列。 令fi表示以第i位开头的最长递增子序列长度，可用dp求解。若fi=s,则从S向i连一条容量为1的边;若fi=1,则从i向T连一条容量为1的边； 限定每个点只选一次,拆点，连一条容量为1的边；若i&lt;j且xi&lt;=xj且fi=fj+1，则从i向j连一条容量为1的边。直接跑最大流求解即可。 回答第三问时，把对应边的限制放成 inf，再跑一次最大流。 int main() { int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) {scanf(&quot;%d&quot;,&amp;a[i]);dp[i]=1;} for(int i=n;i&gt;=1;i--){ for(int j=n;j&gt;i;j--){ if(a[j]&gt;=a[i]) dp[i]=max(dp[i],dp[j]+1); } } int MAX=0; for(int i=1;i&lt;=n;i++) MAX=max(MAX,dp[i]); if(MAX==1) {printf(&quot;1\n&quot;);printf(&quot;%d\n&quot;,n);printf(&quot;%d\n&quot;,n);return 0;} int s=0,t=2*n+1;Dic.init(2*n+1); for(int i=1;i&lt;=n;i++){ Dic.AddEdge(i,i+n,1); if(dp[i]==MAX) Dic.AddEdge(s,i,1); if(dp[i]==1) Dic.AddEdge(i+n,t,1); } for(int i=1;i&lt;=n;i++){ for(int j=i+1;j&lt;=n;j++){ if(a[j]&gt;=a[i]&amp;&amp;dp[i]==dp[j]+1) Dic.AddEdge(i,j,1); } } int ans1=Dic.Maxflow(s,t); Dic.init(2*n+1);Dic.AddEdge(1,1+n,INF);Dic.AddEdge(n,n+n,INF); for(int i=2;i&lt;n;i++) Dic.AddEdge(i,i+n,1); for(int i=1;i&lt;=n;i++){ if(dp[i]==MAX){ if(i==1||i==n) Dic.AddEdge(s,i,INF); else Dic.AddEdge(s,i,1); } if(dp[i]==1){ if(i==1||i==n) Dic.AddEdge(i+n,t,INF); else Dic.AddEdge(i+n,t,1); } for(int j=i+1;j&lt;=n;j++){ if(a[j]&gt;=a[i]&amp;&amp;dp[i]==dp[j]+1) Dic.AddEdge(i,j,1); } } int ans2=Dic.Maxflow(s,t); printf(&quot;%d\n&quot;,MAX);printf(&quot;%d\n&quot;,ans1);printf(&quot;%d\n&quot;,ans2); } 7.试题库问题(最大流)题意：假设一个试题库中有n道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。 现要从题库中抽取m道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。 分析：最大流。从S向每种类别连一条容量为需求的边，从题目向T连接一条容量为1的边,从每个类别向题目连一条容量为1的边。直接跑最大流求解即可。 int main() { int k,n,sum=0;scanf(&quot;%d%d&quot;,&amp;k,&amp;n); int s=0,t=n+k+1;Dic.init(n+k+1); for(int i=1;i&lt;=k;i++){ int c;scanf(&quot;%d&quot;,&amp;c);Dic.AddEdge(0,i,c);sum+=c; } for(int i=k+1;i&lt;=k+n;i++){ int c;scanf(&quot;%d&quot;,&amp;c); while(c--){ int x;scanf(&quot;%d&quot;,&amp;x); Dic.AddEdge(x,i,1); } Dic.AddEdge(i,t,1); } int ans=Dic.Maxflow(s,t); if(ans!=sum) {printf(&quot;No Solution!\n&quot;);return 0;} for(int i=1;i&lt;=k;i++){ printf(&quot;%d:&quot;,i); for(auto &amp;v:Dic.G[i]){ if(Dic.edges[v].flow&gt;0) printf(&quot; %d&quot;,Dic.edges[v].to-k); } printf(&quot;\n&quot;); } } 8.机器人路径规划问题 9.方格取数问题(最大点权独立集)最大独立集：从一个图中找出一种点集，任意两点之间没有边，且点的数量最大 最大点权独立集：从一个图中找出一种点集，任意两点之间没有边，每个点有相应的权值，要求所有点的权值和最大。 最小覆盖集：在一个图中找出这么一个点击，使得所有的边的至少一个端点属于这个集合，并要求点的数量最小 最小点权覆盖：在一个图中找出这么一个点击，使得所有的边的至少一个端点属于这个集合，每个点有权值，要求点的权值和最小。 结论：最大独立集+最小覆盖集=总点数 最大点权独立集+最小点权覆盖=总点权和 最小点权覆盖=最大流 二分图建成网络流以后，，可以用最小割的概念去理解，找出最小的边权（实际上是把点权移到边上了）使得二分图的两个点集不连通，而不连通就是满足了题意 ********************************************************** 二分图最小点覆盖和最大独立集都可以转化为最大匹配求解。在这个基础上，把每个点赋予一个非负的权值，这两个问题就转化为：二分图最小点权覆盖和二分图最大点权独立集。 二分图最小点权覆盖：从x或者y集合中选取一些点，使这些点覆盖所有的边，并且选出来的点的权值尽可能小。 建模：原二分图中的边(u,v)替换为容量为INF的有向边(u,v)，设立源点s和汇点t，将s和x集合中的点相连，容量为该点的权值；将y中的点同t相连，容量为该点的权值。在新图上求最大流，最大流量即为最小点权覆盖的权值和。 二分图最大点权独立集：在二分图中找到权值和最大的点集，使得它们之间两两没有边。 其实它是最小点权覆盖的对偶问题。答案=总权值-最小点覆盖集=总权值-最大流。具体证明参考胡波涛的论文。 ********************************************************** 题意：在一个有n×m个方格的棋盘中,每个方格中有一个正整数。现要从方格中取数,使任意 2个数所在方格没有公共边,且取出的数的总和最大。试设计一个满足要求的取数算法。 分析：最大点权独立集。先将棋盘黑白染色，从S向每个黑点连一条容量为黑点数值的边，从白点向T连接一条容量为白点数值的边，从每个黑点向相邻白点连一条容量为INF的边。 答案为总价值-最小割,即总价值-最大流。 为什么要这样做呢？ 可以从最小割来理解，把相邻的黑白点转化为一个二分图，要使其两部分不连通，即连通边隔断，即最小割 注意：在分黑白点时可以按照坐标分，(坐标之和为奇数为黑点，否则是白点，点的下标设为(i-1)*m+j ) int a[35][35]; int dir[4][2]={0,-1,1,0,0,1,-1,0}; int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int s=0,t=n*m+1,sum=0;Dic.init(n*m+1); for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ scanf(&quot;%d&quot;,&amp;a[i][j]);sum+=a[i][j]; if((i+j)&amp;1) Dic.AddEdge(0,(i-1)*m+j,a[i][j]); else Dic.AddEdge((i-1)*m+j,t,a[i][j]); } } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ if((i+j)&amp;1){ for(int k=0;k&lt;4;k++){ int x=i+dir[k][0],y=j+dir[k][1]; if(x&lt;=n&amp;&amp;x&gt;=1&amp;&amp;y&lt;=m&amp;&amp;y&gt;=1) Dic.AddEdge((i-1)*m+j,(x-1)*m+y,INF); } } } } int ans=sum-Dic.Maxflow(s,t); printf(&quot;%d\n&quot;,ans); } 10.餐巾计划问题(最小费用最大流)题意：一个餐厅在相继的 n 天里，每天需用的餐巾数不尽相同。假设第 i 天需要 ri ​​ 块餐巾。餐厅可以购买新的餐巾，每块餐巾的费用为 P 分； 或者把旧餐巾送到快洗部，洗一块需 M 天，其费用为 F 分；或者送到慢洗部，洗一块需 N 天，其费用为 S 分（S&lt;F）。 每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。 但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。 试设计一个算法为餐厅合理地安排好 n 天中餐巾使用计划,使总的花费最小。 分析：把每一天都拆成一对点 xi 和 yi ，xi 表示脏的餐巾，yi 表示干净的餐巾。从 S 向 yi 连一条容量为 inf 费用为 P 的边，代表购买决策； 从 yi 向 T 连一条容量为 ri 费用为 0 的边，代表每天需求；从 S 向 xi 连一条容量为 ri 费用为 0 的边，代表每天剩余的未洗餐巾； 从 xi 向 xi+1 连一条容量为 inf 费用为 0 的边，代表将脏餐巾屯到下一天；从 xi 向 yi+m 连一条容量为 inf 费用为 F 的边，代表快洗决策； 从 xi 向 yi+n 连一条容量为 inf 费用为 S 的边，代表慢洗决策。直接跑最小费用最大流即可。 #include&lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; const int INF=0x3f3f3f3f; const int maxn=2005; struct Edge{ int from,to,cap,flow,cost; Edge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w){} }; struct MCMF { int n,m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn]; int d[maxn]; int p[maxn]; int a[maxn]; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int cap,int cost){ edges.emplace_back(from,to,cap,0,cost); edges.emplace_back(to,from,0,0,-cost); int m=edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool BellmanFord(int s,int t,int &amp;flow,ll &amp;cost){ for(int i=0;i&lt;n;i++) d[i]=INF; memset(inq,0,sizeof(inq));d[s]=0;inq[s]=1;p[s]=0;a[s]=INF; queue&lt;int&gt; q;q.push(s); while(!q.empty()){ int u=q.front();q.pop();inq[u]=0; for(int i=0;i&lt;G[u].size();i++){ Edge&amp; e=edges[G[u][i]]; if(e.cap&gt;e.flow&amp;&amp;d[e.to]&gt;d[u]+e.cost){ d[e.to]=d[u]+e.cost;p[e.to]=G[u][i]; a[e.to]=min(a[u],e.cap-e.flow); if(!inq[e.to]){ q.push(e.to);inq[e.to]=1; } } } } if(d[t]==INF) return 0; flow+=a[t]; cost+=(ll)d[t]*(ll)a[t]; for(int u=t;u!=s;u=edges[p[u]].from){ edges[p[u]].flow+=a[t]; edges[p[u]^1].flow-=a[t]; } return 1; } int MincostMAXflow(int s,int t,ll &amp;cost){ int flow=0;cost=0; while(BellmanFord(s,t,flow,cost)); return flow; } }Mc; int a[1005]; int main() { int n,P,M,F,N,S;scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;P,&amp;M,&amp;F,&amp;N,&amp;S); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); int s=0,t=2*n+1;Mc.init(2*n+2); for(int i=1;i&lt;=n;i++){ Mc.AddEdge(s,i+n,INF,P);Mc.AddEdge(i+n,t,a[i],0); } for(int i=1;i&lt;n;i++){ Mc.AddEdge(s,i,a[i],0);Mc.AddEdge(i,i+1,INF,0); } for(int i=1;i&lt;=n-M;i++) Mc.AddEdge(i,i+n+M,INF,F); for(int i=1;i&lt;=n-N;i++) Mc.AddEdge(i,i+n+N,INF,S); ll cost=0; int ans=Mc.MincostMAXflow(s,t,cost); printf(&quot;%d\n&quot;,cost); }]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数位dp]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%95%B0%E4%BD%8Ddp%2F</url>
    <content type="text"><![CDATA[数位DPNB网友Blog https://blog.csdn.net/wust_zzwh/article/details/52100392 看到那种给你两个数，让你求这两个数之间符合条件的数的个数，且这两个数非常大，这样的题目一般就是数位DP 数位DP一般用于计数 两种实现方式： 1.DP预处理+乱搞 2.记忆化搜索(较简单) 模版： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int state=20; int a[20]; ll dp[20][state];//不同题目状态不同 ll dfs(int pos,/*state变量*/,bool lead/*前导零*/,bool limit/*数位上界变量*/)//不是每个题都要判断前导零 { //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了 if(pos==-1) return 1;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */ //第二个就是记忆化(在此前可能不同题目还能有一些剪枝) if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/ int up=limit?a[pos]:9;//根据limit判断枚举的上界up;这个的例子前面用213讲过了 ll ans=0; //开始计数 for(int i=0;i&lt;=up;i++)//枚举，然后把不同情况的个数加到ans就可以了 { if() ... else if()... ans+=dfs(pos-1,/*状态转移*/,lead &amp;&amp; i==0,limit &amp;&amp; i==a[pos]) //最后两个变量传参都是这样写的 /*这里还算比较灵活，不过做几个题就觉得这里也是套路了 大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论 去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目 要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类， 前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/ } //计算完，记录状态 if(!limit &amp;&amp; !lead) dp[pos][state]=ans; /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/ return ans; } ll solve(ll x) { int pos=0; while(x)//把数位都分解出来 { a[pos++]=x%10;//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行 x/=10; } return dfs(pos-1/*从最高位开始枚举*/,/*一系列状态 */,true,true);//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛 } int main() { ll le,ri; while(~scanf(&quot;%lld%lld&quot;,&amp;le,&amp;ri)) { //初始化dp数组为-1,这里还有更加优美的优化,后面讲 printf(&quot;%lld\n&quot;,solve(ri)-solve(le-1)); } } 例题HDU-2089 不要62#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=20; typedef long long ll; int a[maxn],dp[maxn][2];//dp[i][0]-&gt;当前第i位，前一位不是6 dp[i][1]-&gt;当前第i位，前一位是6 int dfs(int pos,int pre,int sta,int limit){ if(pos==-1) return 1;//遍历完了 返回1 if(!limit&amp;&amp;dp[pos][sta]!=-1) return dp[pos][sta];//无上界且已遍历过 int up=limit?a[pos]:9;//根据上一位是否到上界判定这一位的最大值 int tmp=0; for(int i=0;i&lt;=up;i++){ if(pre==6&amp;&amp;i==2) continue;//上一位为6，这一位为2 剪枝 if(i==4) continue;//这一位为4 剪枝 tmp+=dfs(pos-1,i,i==6,limit&amp;&amp;i==a[pos]);//dfs(下一位，该位变为上一位，该位是否为6，是否到了上界) } if(!limit) dp[pos][sta]=tmp;//没到上界 记忆化存储 这里加!limit 是因为边界(如560)的选择比较少(不会是0-9) 无法记录所有的可能 return tmp; } int solve(int x){ int pos=0; while(x){ a[pos++]=x%10;x/=10; } return dfs(pos-1,-1,0,true); } int main() { ios::sync_with_stdio(0);cin.tie(0); int l,r; while(cin&gt;&gt;l&gt;&gt;r,l+r){ memset(dp,-1,sizeof(dp)); cout&lt;&lt;solve(r)-solve(l-1)&lt;&lt;endl; } } HDU-4734 F(x)题意：定义十进制数x的权值为f(x)=a(n)*2^(n-1)+a(n-1)*2(n-2)+...a(2)*2+a(1)*1，a(i)表示十进制数x中第i位的数字。题目给出a，b，求出0~b有多少个不大于f(a)的数。 思路：已知fa，开dp[pos][sum]-&gt;枚举到pos位，后面还需凑sum的权值和的个数 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int INF=0x3f3f3f3f; const int maxn=1e4+5; int dp[12][maxn],fa,a[12]; int f(int x){ if(x==0) return 0; int ans=f(x/10); return ans*2+x%10; } int dfs(int pos,int sum,bool limit){ if(pos==-1) return sum&lt;=fa; if(sum&gt;fa) return 0; if(!limit&amp;&amp;dp[pos][fa-sum]!=-1) return dp[pos][fa-sum]; int up=limit?a[pos]:9; int ans=0; for(int i=0;i&lt;=up;i++){ ans+=dfs(pos-1,sum+i*(1&lt;&lt;pos),limit&amp;&amp;i==a[pos]); } if(!limit) dp[pos][fa-sum]=ans; return ans; } int solve(int x){ int pos=0; while(x){ a[pos++]=x%10;x/=10; } return dfs(pos-1,0,true); } int main() { int T,ca=1;scanf(&quot;%d&quot;,&amp;T); memset(dp,-1,sizeof(dp)); while(T--){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); fa=f(a);int ans=solve(b); printf(&quot;Case #%d: %d\n&quot;,ca++,ans); } } POJ-3252 Round Numbers题意：一个数的二进制中0的数量不能少于1的数量，求这样的数有多少个。 思路：dp[pos][num]-&gt;枚举到pos位，0的数量比1的数量多num个，可能有负数整体右移32位即可，注意前导0的影响 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int INF=0x3f3f3f3f; int dp[35][70],fa,a[70]; int dfs(int pos,int sum,bool lead,bool limit){ if(pos==-1) return sum&gt;=32; if(!limit&amp;&amp;!lead&amp;&amp;dp[pos][sum]!=-1) return dp[pos][sum]; int up=limit?a[pos]:1; int ans=0; for(int i=0;i&lt;=up;i++){ if(lead&amp;&amp;i==0) ans+=dfs(pos-1,sum,lead,limit&amp;&amp;i==a[pos]); else ans+=dfs(pos-1,sum+(i==0?1:-1),lead&amp;&amp;i==0,limit&amp;&amp;i==a[pos]); } if(!limit&amp;&amp;!lead) dp[pos][sum]=ans; return ans; } int solve(int x){ int pos=0; while(x){ a[pos++]=x&amp;1;x&gt;&gt;=1; } return dfs(pos-1,32,true,true); } int main() { memset(dp,-1,sizeof(dp)); int a,b; while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b)){ printf(&quot;%d\n&quot;,solve(b)-solve(a-1)); } } 待补HDU 3709 Balanced Number HDU 4507 恨7不成妻 [BZOJ1833][ZJOI2010] count 数字计数 [BZOJ3209]花神的数论题 https://www.cnblogs.com/HDUjackyan/p/9142156.html]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形dp]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[树形DP树形DP主要有三种题型： 1.最大独立子集问题(父节点与子节点不能共存) 2.数的直径(一棵树上的两个节点间的路径长度的最大值) 3.树的重心(将节点x去掉后，树所形成的各个连通块的节点数最少) 最大独立子集问题洛谷P1352 没有上司的舞会题意：一棵树，n个点，每人一个权值，父节点与子节点不能同时选，求子集最大权 思路：dfs，在递归的回溯阶段完成计算dp[i][0]-&gt;不选i节点取得的最大值 dp[i][1]-&gt;选i节点取得的最大值 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=6e3+5; int r[maxn],boss[maxn],dp[maxn][2],n,l,k; vector&lt;int&gt; G[maxn]; void dfs(int u){ for(auto &amp;v:G[u]){ dfs(v);//v是u的子节点，回溯需注意 dp[u][0]+=max(dp[v][1],dp[v][0]);//不选u,则v可选或不选 dp[u][1]+=dp[v][0];//选u,则v不能选 } dp[u][1]+=r[u];//选u,需要加上自身的权值 } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;r[i]); while(~scanf(&quot;%d%d&quot;,&amp;l,&amp;k),l+k){ boss[l]=k;G[k].push_back(l); } for(int i=1;i&lt;=n;i++){ if(boss[i]==0){//从树的根出发，即入度为0的点 dfs(i);printf(&quot;%d\n&quot;,max(dp[i][0],dp[i][1]));break; } } } 洛谷P2015 二叉苹果树题意：一棵树(规定每个节点的子节点要么为0、要么为2),每个树枝上有权值，现减边，求保留m条边最多能留住多少权值。 思路：树形DP 要使得一棵树割掉k个节点后整棵树权值和最大。这个题目挺恶心人的处理起来也麻烦。因为虽然这题目保证是二叉树，但是他输入时并没有给我们两个点的先后顺序。也就是他输入u,v,w，你不知道u是v的父亲还是v是u的父亲。网上有很多人写这个题解时为了方便就乱搞，判断什么如果那个点左儿子为空就成为左儿子否则成为右儿子的什么鬼。 正确的姿势应该是用边表存储。像我的做法就是拿边表存储之后弄一个find函数找出每一个节点的父亲。 我还多做了一个其实可以不用这么做的无用功：我又跑了一遍枚举找出每个节点的左右儿子。前面麻烦的事干完，接下来我们就可以考虑dp了。 由于题目给的权值都是边权，我们就可以进行一个骚操作：把每条边的权值都下移到那条边通向的儿子节点上，然后给根节点的权值置0。 因为我们给了根节点1一个0的权值，所以我们要保留的节点数就从q变成q+1了！然后我们可以继续进行骚操作，用dp(i,j)表示保留j个节点，于是我们一开始就dp根节点：dp(1,q+1)。那么这个dp的函数该怎么写呢？ 我们设某一个子树要保留j个节点，而根节点是一定要保存的，因为如果你一开始就把根节点剪掉了就啥都没了嘛。所以根节点的以两个儿子为根的子树就总共要保存j-1个节点。 有了思路，我们就可以设左子树保存k个节点，然后我们来枚举这个k，于是右子树就可以推出来是保存j-k-1个节点啦。然后我们就来找状态转移方程和最大值。 首先我们来想，当j=0时，也就是某棵子树上取0个点时。取0个点答案当然是0。然后我们可以按照刚才的思路，给左儿子分配可以保留k个节点，给右儿子分配可以保留j-k-1个 节点，于是我们就枚举k，然后记忆化搜索一波：如果f[某个子节点][k]==0就说明这个节点还没访问过，答案还没有更新，我们就来把这个节点和这个k值dp一遍，作为待会dp 时需要的条件（dp前必须把需要的东西准备好，这就是在准备东西。）然后就可以推出状态转移方程为： f[i][j]=max(f[i][j],f[son[i][0]][k]+f[son[i][1]][j-k-1]+dis[i]); f[i][j]=max(f[i][j],儿子节点分配后的最大值加上i节点的权值。 #include&lt;bits/stdc++.h&gt; #define pii pair&lt;int,int&gt; using namespace std; const int maxn=105; int fa[maxn],son[maxn][2],dis[maxn],dp[maxn][maxn]; bool vis[maxn]; vector&lt;pii&gt; edge[maxn]; void addedge(int u,int v,int w){ edge[u].push_back(pii(v,w)); } void find(int x){ for(auto &amp;v:edge[x]){ if(vis[v.first]==0){//如果x边的出点还没被标记过 fa[v.first]=x;vis[v.first]=1; find(v.first); } } } void solve(int i,int j){//树形DP的函数 if(j==0) dp[i][j]=0;//如果要保留0个点，最大值当然是0了 else if(son[i][0]==0&amp;&amp;son[i][1]==0) dp[i][j]=dis[i];//如果没有儿子节点，最大值就是它本身的价值。 else{ for(int k=0;k&lt;j;k++){//k不能=j，否则j-k-1就会变成负数，是没有意义的，注意边界。 if(dp[son[i][0]][k]==0) solve(son[i][0],k); if(dp[son[i][1]][j-k-1]==0) solve(son[i][1],j-k-1); dp[i][j]=max(dp[i][j],dp[son[i][0]][k]+dp[son[i][1]][j-k-1]+dis[i]);//状态转移方程 } } } int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;n;i++){ int u,v,w;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); addedge(u,v,w);addedge(v,u,w); } vis[1]=1;find(1); for(int i=1;i&lt;=n;i++){//这是找每个节点的左右儿子的过程 int v=-1; for(auto &amp;j:edge[i]){ if(fa[j.first]==i){//如果i是j.first点的爸爸的话 son[i][++v]=j.first; dis[j.first]=j.second; if(v==1) break;//v==1时说明i节点的两个儿子都找到了，所以就直接break掉减少枚举量 } } } solve(1,m+1); printf(&quot;%d\n&quot;,dp[1][m+1]); } 洛谷P2014 选课题意：有的课程有先修课，每门课有权值，求修m门课能获得的最大权值 思路：不一定是二叉树，实际上是多叉树，需要转换为二叉树，多叉树转换时儿子变为左儿子son[i][0],兄弟变为右儿子；插入兄弟时需要循环查找最后一个兄弟，再插入； #include&lt;bits/stdc++.h&gt; #define pii pair&lt;int,int&gt; using namespace std; const int maxn=305; int fa[maxn],son[maxn][2],val[maxn],dp[maxn][maxn];//son[][0]-&gt;左儿子 son[][1]-&gt;兄弟 vector&lt;pii&gt; edge[maxn]; int dfs(int i,int j){ if(i==0||j==0) return 0;//递归边界返回0 if(dp[i][j]) return dp[i][j];//记忆化 dp[i][j]=dfs(son[i][1],j);//(dfs入口从0节点进入)0节点作为祖先的大儿子，祖先的其他儿子都是他的兄弟(因此不存在森林) for(int k=0;k&lt;j;k++){ dp[i][j]=max(dp[i][j],dfs(son[i][0],k)+dfs(son[i][1],j-k-1)+val[i]);//转移方程 } return dp[i][j];//记得返回 } int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ int u,w;scanf(&quot;%d%d&quot;,&amp;u,&amp;w); val[i]=w; if(son[u][0]==0) son[u][0]=i;//没有左儿子直接插 else{//有左儿子 int x=son[u][0];//x-&gt;左儿子 while(son[x][1]) x=son[x][1];//变为左儿子的兄弟 son[x][1]=i; } } printf(&quot;%d\n&quot;,dfs(son[0][0],m));//递归入口注意-&gt; 0 } HDU-1054(Strategic Game)题意：一棵树求最小边覆盖 思路：二分图最小覆盖(建双向边故最大匹配/2) or 树形dp 实测前者436ms VS 后者182ms #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1505; int n,dp[maxn][2]; bool fa[maxn]; vector&lt;int&gt; G[maxn]; inline void init(int n){ for(int i=0;i&lt;n;i++) G[i].clear(),fa[i]=0,dp[i][0]=0,dp[i][1]=1; } inline void addedge(int u,int v){G[u].push_back(v);} void dfs(int u){ for(auto &amp;v:G[u]){ dfs(v); dp[u][0]+=dp[v][1];//不选u点则其孩子节点必须选 dp[u][1]+=min(dp[v][0],dp[v][1]);//选了u则其孩子可选可不选 } } int main() { while(~scanf(&quot;%d&quot;,&amp;n)){ init(n); for(int i=0;i&lt;n;i++){ int u,v,c; scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;c); while(c--){ scanf(&quot;%d&quot;,&amp;v); addedge(u,v);fa[v]=1; } } int r=0;for(int i=0;i&lt;n;i++) if(!fa[i]) {r=i;break;} dfs(r); printf(&quot;%d\n&quot;,min(dp[r][0],dp[r][1])); } } 树的直径1.两遍bfs，何苦dp 2.树形dp POJ-1985 Cow Marathon求树的直径裸题,边带权，第一次随机找一点bfs看最远能走到哪(比如v),再以v为起点bfs找最远点 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #define pii pair&lt;int,int&gt; using namespace std; const int maxn=1e5+5; int n,m,d[maxn]; bool vis[maxn]; vector&lt;pii&gt; edge[maxn]; int bfs(int s,int f){ memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); queue&lt;int&gt; que;que.push(s); int ans=s,MAX=0; d[s]=0;vis[s]=1; while(!que.empty()){ int t=que.front();que.pop(); for(int i=0;i&lt;edge[t].size();i++){ int v=edge[t][i].first; if(vis[v]) continue; d[v]=d[t]+edge[t][i].second; vis[v]=1;que.push(v); if(MAX&lt;d[v]){ MAX=d[v];ans=v; } } } if(f==0) return ans; else return MAX; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int q=0; for(int i=1;i&lt;=m;i++){ int j,k,l,ch;scanf(&quot;%d %d %d %c&quot;,&amp;j,&amp;k,&amp;l,&amp;ch); edge[j].push_back(pii(k,l)); edge[k].push_back(pii(j,l)); } int v=bfs(1,0); int ans=bfs(v,1); printf(&quot;%d\n&quot;,ans); } 2019牛客多校(四) A-meeting题意：一棵树上有n个点，边权均为1，k个人在不同的k个点上(1&lt;k&lt;=n)求这k个人汇聚到同一点上的最长时间 思路：两遍bfs求关键点子树的半径，先求直径，再除以2向上取整，注意求最远距离时遇到关键点才更新最大值 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+5; vector&lt;int&gt; G[maxn]; bool vis[maxn],vis1[maxn]; int n,k,d1[maxn],vis2[maxn]; int bfs1(int s){ queue&lt;int&gt; que;que.push(s);vis1[s]=1;int ans=s; while(!que.empty()){ int u=que.front();que.pop(); for(auto&amp; v:G[u]){ if(!vis1[v]){ if(vis[v]) ans=v; que.push(v);vis1[v]=1; } } } return ans; } int bfs2(int s){ queue&lt;int&gt; que;que.push(s);vis2[s]=1;int ans=0; while(!que.empty()){ int u=que.front();que.pop(); for(auto&amp; v:G[u]){ if(!vis2[v]){ vis2[v]=vis2[u]+1;que.push(v); if(vis[v]) ans=vis2[v]; } } } return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;n;i++){ int u,v;cin&gt;&gt;u&gt;&gt;v; G[u].push_back(v);G[v].push_back(u); } int t; while(k--) {cin&gt;&gt;t;vis[t]=1;} int s=bfs1(t); double ans=bfs2(s)-1; cout&lt;&lt;ceil(ans/2)&lt;&lt;endl; } HDU-2196 Computer讲解来自NB网友 首先第一个dfs求出所有每个节点i在其子树中的正向最大距离和正向次大距离和dist[i][0]和dist[i][1]（如果i节点在子树中最大距离经过了2号儿子，那么次大距离就是不经过2号儿子的最大距离）。 并且还要标记longest[i]=j表示节点i在其子树中的最大距离经过了节点j（即j是i的一个儿子）。 由上步我们获得了正向最大距离，正向次大距离和最大距离的儿子节点标记。画图可以知道我们建立的这棵树，i节点的最远距离只有两种选择： i节点所在子树的最大距离，或者i节点连接它的父节点所能到达的最大距离。（即前者往下走，后者先往上走之后很可能也往下走） 所以我们只要求出反向最大距离dist[i][2]（即i节点往它的父节点走所能到达的最大距离）就可以知道i节点在整个树中能走的最大距离了。 dist[i][2]求法：i节点往它的父节j点走，如果它的父节点的正向最大距离不经过i的话，那么dist[i][2]要不就是它父节点的反向最大距离+W[i][j]要不就是它父节点的正向最大距离+ W[i][j]. 如果它的父节点的正向最大距离经过i的话，那么dist[i][2]要不就是它父节点的反向最大距离+W[i][j]要不就是它父节点的正向次大距离+ W[i][j]. #include&lt;bits/stdc++.h&gt; #define pii pair&lt;int,int&gt; using namespace std; const int maxn=1e4+5; vector&lt;pii&gt; edge[maxn]; int dp[maxn][3],id[maxn]; void dfs1(int u,int f){//第一个dfs求出子树的最大和次大和 for(auto &amp;v:edge[u]){ if(v.first==f) continue; dfs1(v.first,u); if(dp[u][0]&lt;dp[v.first][0]+v.second){//记录最大和，记录经过哪个儿子最大 dp[u][0]=dp[v.first][0]+v.second;id[u]=v.first; } } for(auto &amp;v:edge[u]){ if(v.first==f||id[u]==v.first) continue;//跳过这个儿子在里面找一个最大的就是这点次大的 dp[u][1]=max(dp[u][1],dp[v.first][0]+v.second); } } void dfs2(int u,int f){//更新先往父亲节点走一步的最大和 for(auto &amp;v:edge[u]){ if(v.first==f) continue; //难点，每个父亲都有两种方式，一个是再往父亲走一步，一个是走父亲的子树，max(dp[u][2], dp[u][1])，这个就体现出这两步了，注意不经过这个点直接走子树最大和的那个点 if(v.first==id[u]) dp[v.first][2]=max(dp[u][2],dp[u][1])+v.second;//这个是针对儿子，所以是dp[v.first][2]=，体现了先走一步父亲，经过就走次大的，再走最大的就重复了一段 else dp[v.first][2]=max(dp[u][2],dp[u][0])+v.second; dfs2(v.first,u);//因为dfs1更新了所有子树的特点，子树的信息可以直接用了，父节点的信息从一步步dfs下去都已经更新好了，上面的也是可以直接用，每一步都看看是不是走父亲的父亲更好，一直更新最优 } } int main() { int n; while(~scanf(&quot;%d&quot;,&amp;n)){ int a,b;memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) edge[i].clear(); for(int i=2;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;a,&amp;b); edge[i].push_back(pii(a,b)); edge[a].push_back(pii(i,b)); } dfs1(1,-1); dfs2(1,-1);//1为根节点 for(int i=1;i&lt;=n;i++) printf(&quot;%d\n&quot;,max(dp[i][0],dp[i][2])); } }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路与分层图最短路]]></title>
    <url>%2F2019%2F07%2F27%2F%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[最短路字面意思。。。Prim、Dijkstra、SPFA 优秀的Dijkstra + 优先队列优化(nlogn) 单源最短路、无负权边 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+5; const int INF=0x3f3f3f3f; struct Edge{ int from,to,dist; Edge(int u,int v,int d):from(u),to(v),dist(d) {} }; struct Dijkstra{ int n,m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; bool vis[maxn]; int d[maxn],p[maxn]; typedef pair&lt;int,int&gt; pii; void init(int n){ this-&gt;n=n; for(int i=0;i&lt;n;i++) G[i].clear(); edges.clear(); } void AddEdge(int from,int to,int dist){ edges.push_back(Edge(from,to,dist)); m=edges.size();G[from].push_back(m-1); } void dijkstra(int s){ priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q; for(int i=0;i&lt;n;i++) d[i]=INF; memset(vis,0,sizeof(vis)); q.push(pii(0,s));d[s]=0; while(!q.empty()){ pii x=q.top();q.pop(); int u=x.second; if(vis[u]) continue; vis[u]=true; for(int i=0;i&lt;G[u].size();i++){ Edge&amp; e=edges[G[u][i]]; if(d[e.to]&gt;d[u]+e.dist){ d[e.to]=d[u]+e.dist; p[e.to]=G[u][i]; q.push(pii(d[e.to],e.to)); } } } } }; int main() { int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); Dijkstra Dij; Dij.init(n); for(int i=0;i&lt;m;i++){ int u,v,d; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;d); Dij.AddEdge(u,v,d); } Dij.dijkstra(0); int x; while(scanf(&quot;%d&quot;,&amp;x)) cout&lt;&lt;Dij.d[x]&lt;&lt;endl; } 次短路字面意思。。。算法同上,开两个数组记录当前最短路和次短路即可 #include&lt;bits/stdc++.h&gt; using namespace std; const int INF=0x3f3f3f3f; const int maxn=5005; int n,m,u,v,w; int dis[maxn],dis2[maxn]; struct node{ int to,cost; node(int t,int c):to(t),cost(c) {} bool operator &lt; (const node &amp;a) const{ return cost&gt;a.cost; } }; vector&lt;node&gt; edge[maxn]; void Dijkstra() { priority_queue&lt;node&gt; que; memset(dis,INF,sizeof(dis)); memset(dis2,INF,sizeof(dis2)); dis[1]=0;que.push(node{1,0}); while(!que.empty()) { node x=que.top();que.pop(); int v=x.to,d=x.cost; if(dis2[v]&lt;d) continue; for(int i=0; i&lt;edge[v].size(); i++) { node y=edge[v][i];int d2=d+y.cost; if(dis[y.to]&gt;d2){ swap(dis[y.to],d2); que.push(node{y.to,dis[y.to]}); } if(dis2[y.to]&gt;d2 &amp;&amp; dis[y.to]&lt;d2){ dis2[y.to]=d2; que.push(node{y.to,dis2[y.to]}); } } } } int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;=n;i++) edge[i].clear(); for(int i=1;i&lt;=m;i++) { cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; edge[u].push_back(node{v,w}); edge[v].push_back(node{u,w}); } Dijkstra(); cout&lt;&lt;dis2[n]&lt;&lt;endl; return 0; } K短路字面意思。。。Dijkstra/SPFA + A*算法 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #define mem(a,b) sizeof(a,b,sizeof(b)) using namespace std; const int maxn=1005; const int INF=0x3f3f3f3f; struct node{ int to,val; node(){} node(int a,int b):to(a),val(b){} }; vector&lt;node&gt; a[maxn],b[maxn]; int n,m,k,dis[maxn]; bool vis[maxn]; void AddEdge(int x,int y,int val){ a[x].push_back(node(y,val)); b[y].push_back(node(x,val)); } priority_queue&lt;node&gt; q; void Dijkstra(int s,int t){ while(!q.empty()) q.pop(); mem(dis,INF);mem(vis,0); while(!q.empty()){ node t=q.top();q.pop();int u=t.to; if(vis[u]) continue;vis[u]=1; for(int i=0;i&lt;b[u].size();i++){ node v=b[u][i]; if(dis[v.to]&gt;dis[u]+v.val){ dis[v.to]=dis[u]+v.val; q.push(v.to); } } } } struct Anode{ int h,g,id; Anode(int a,int b,int c):h(a),g(b),id(c){} bool operator &lt;(const Anode&amp; a)const{ return h+g&gt;a.h+a.g; } }; priority_queue&lt;Anode&gt; Q; int Astar(int s,int t){ while(!Q.empty()) Q.pop(); Q.push(Anode(0,dis[s],s)); int num=0; while(!Q.empty()){ Anode u=Q.top();Q.pop(); if(u.id==t) num++; if(num&gt;=k) return u.h; for(int i=0;i&lt;a[u.id].size();i++){ node v=a[u.id][i]; //Q.emplace(u.h+v.val,dis[v.to],v.to); Q.push(Anode(u.h+v.val,dis[v.to],v.to)); } } return -1; } int main(){ ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;maxn;i++) a[i].clear(),b[i].clear(); int x,y,v,s,t; for(int i=0;i&lt;m;i++){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;AddEdge(x,y,v); } cin&gt;&gt;s&gt;&gt;t&gt;&gt;k; if(s==t) k++; Dijkstra(s,t); cout&lt;&lt;Astar(s,t)&lt;&lt;endl; } 分层图最短路字面(STOP!) 敲打.jpg 分层图最短路就是在分层图上解决最短路问题 一般模型为：在一张图上，有k次机会修改某条边的权值(置0/减半)，再求从起点到终点的最短路线 一般解决方法：多开一维记录状态，多开的维度记录状态的种类数即为分层数。DP dis[i][j] -&gt; 到了第i个点，修改了j次边权后的最短路 用to表示要到的点，x表示父亲节点，于是 dis[to][j]=min(dis[x][j]+val(x,to),dis[x][j-1]) 前者表示没修改/后者表示修改了 #include&lt;bits/stdc++.h&gt; #define pii pair&lt;int,int&gt; using namespace std; const int maxn=1e5+5; const int maxk=15; const int INF=0x3f3f3f3f; int n,m,s,t,k,d[maxn][maxk]; bool vis[maxn][maxk]; vector&lt;pii&gt; Edge[maxn]; void init(){ for(int i=0;i&lt;=n*2;i++) Edge[i].clear(); memset(d,0x3f,sizeof(d)); memset(vis,0,sizeof(vis)); } void Dijkstra(int s){ d[s][0]=0;priority_queue&lt;pii&gt; que;que.push({0,s}); while(!que.empty()){ int u=que.top().second;que.pop(); int c=u/n;u%=n; if(vis[u][c]) continue;vis[u][c]=1; for(int j=0;j&lt;Edge[u].size();j++){ int v=Edge[u][j].first; if(!vis[v][c]&amp;&amp;d[v][c]&gt;d[u][c]+Edge[u][j].second){ d[v][c]=d[u][c]+Edge[u][j].second;que.push({-d[v][c],v+c*n}); } } if(c&lt;k){ for(int j=0;j&lt;Edge[u].size();j++){ int v=Edge[u][j].first; if(!vis[v][c+1]&amp;&amp;d[v][c+1]&gt;d[u][c]){ d[v][c+1]=d[u][c];que.push({-d[v][c+1],v+(c+1)*n}); } } } } } /* int main() { ios::sync_with_stdio(0);cin.tie(0);关同步WA+RE while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;k){ init();cin&gt;&gt;s&gt;&gt;t;//s=1;t=n; int a,b,x; while(m--){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;x; for(int i=0;i&lt;=k;i++){ Edge[a].push_back({b,x}); Edge[b].push_back({a,x}); } } Dijkstra(s);int ans=INF; for(int i=0;i&lt;=k;i++) ans=min(ans,d[t][i]); cout&lt;&lt;ans&lt;&lt;endl; } } */ int main() { while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k)){ init();scanf(&quot;%d%d&quot;,&amp;s,&amp;t);int a,b,x; while(m--){ scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;x); for(int i=0;i&lt;=k;i++){ Edge[a].push_back({b,x}); Edge[b].push_back({a,x}); } } Dijkstra(s);int ans=INF; for(int i=0;i&lt;=k;i++) ans=min(ans,d[t][i]); printf(&quot;%d\n&quot;,ans); } return 0; } 2018南京网络赛L题：Magical Girl Haze(最短路分层图) //开long long , 有向图 #include&lt;bits/stdc++.h&gt; typedef long long ll; #define pii pair&lt;ll,ll&gt; using namespace std; const int maxn=1e5+5; const int maxk=15; //const int INF=0x3f3f3f3f; const ll INF=1e15; int n,m,s,t,k; ll d[maxn][maxk]; bool vis[maxn][maxk]; vector&lt;pii&gt; Edge[maxn]; void init(){ for(int i=0;i&lt;=n*2;i++) Edge[i].clear(); for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=k;j++) d[i][j]=INF; memset(vis,0,sizeof(vis)); } void Dijkstra(int s){ d[s][0]=0;priority_queue&lt;pii&gt; que;que.push({0,s}); while(!que.empty()){ int u=que.top().second;que.pop(); ll c=u/n;u%=n; if(vis[u][c]) continue;vis[u][c]=1; for(int j=0;j&lt;Edge[u].size();j++){ ll v=Edge[u][j].first; if(!vis[v][c]&amp;&amp;d[v][c]&gt;d[u][c]+Edge[u][j].second){ d[v][c]=d[u][c]+Edge[u][j].second;que.push({-d[v][c],v+c*n}); } } if(c&lt;k){ for(int j=0;j&lt;Edge[u].size();j++){ ll v=Edge[u][j].first; if(!vis[v][c+1]&amp;&amp;d[v][c+1]&gt;d[u][c]){ d[v][c+1]=d[u][c];que.push({-d[v][c+1],v+(c+1)*n}); } } } } } int main() { int T;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); init();int a,b;ll x; while(m--){ scanf(&quot;%d%d%lld&quot;,&amp;a,&amp;b,&amp;x); for(int i=0;i&lt;=k;i++){ Edge[a].push_back({b,x}); //Edge[b].push_back({a,x}); } } Dijkstra(1);ll ans=INF; for(int i=0;i&lt;=k;i++) ans=min(ans,d[n][i]); printf(&quot;%lld\n&quot;,ans); } return 0; } P2939 [USACO09FEB]改造路Revamping Trails 交上面那份ll就错 ， 交int模版就过 ？？？？？？？？？？ https://www.luogu.org/problem/P2939 待补P3063 [USACO12DEC]牛奶的路由Milk Routing 与上面不同的是允许把边权减半 HDU 3499 分层图最短路+Trie树 给n个城市和m条无向边，然后给了起点和终点，然后你有一次机会使得其中的一张票价减半，问最小花费是多少 NEFU 1132 分层图最短路 https://blog.csdn.net/dan__ge/article/details/51702663 #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; typedef pair&lt;int,int&gt; P; const int inf=0x3f3f3f3f; const ll INF=0x3f3f3f3f3f3f3f3fll; const int maxn=10010; struct edge{ int to,cost; edge(int a,int b){to=a;cost=b;} }; vector&lt;edge&gt;G[maxn]; int vis[maxn],dis[maxn],n,m,k; int dijkstra(int s,int t){ memset(dis,inf,sizeof(dis)); memset(vis,0,sizeof(vis)); priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt;que; dis[s]=0;que.push(P(0,s)); while (!que.empty()){ P p=que.top();que.pop(); int v=p.second; if (vis[v]) continue; vis[v]=1; for(int i=0;i&lt;G[v].size();i++){ edge e=G[v][i]; if(dis[v]+e.cost&lt;dis[e.to]){ dis[e.to]=dis[v]+e.cost; que.push(P(dis[e.to],e.to)); } } } int ans=inf; for(int i=0;i&lt;=k;i++) ans=min(ans,dis[i*n+t]); if(ans==inf) return -1; return ans; } int U[maxn],V[maxn],COST[maxn],num[110][110]; int main(){ int st,en; while(scanf(&quot;%d%d%d&quot;,&amp;st,&amp;en,&amp;k)!=-1){ for(int i=0;i&lt;maxn;i++) G[i].clear(); st++;en++; n=max(st,en); scanf(&quot;%d&quot;,&amp;m); memset(num,inf,sizeof(num)); for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;U[i],&amp;V[i],&amp;COST[i]); U[i]++;V[i]++;num[U[i]][V[i]]=min(COST[i],num[U[i]][V[i]]); n=max(n,max(U[i],V[i])); } for(int i=1;i&lt;=m;i++){ for(int j=0;j&lt;=k;j++){ G[j*n+U[i]].push_back(edge(j*n+V[i],num[U[i]][V[i]])); if(j&lt;k) G[j*n+U[i]].push_back(edge((j+1)*n+V[i],num[U[i]][V[i]]/2)); } } int ans=dijkstra(st,en); if(ans==-1) printf(&quot;KengDie\n&quot;); else printf(&quot;%d\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F07%2F26%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线段树NB网友Blog(https://blog.csdn.net/huangzihaoal/article/details/81813454) 线段树，是一种二叉搜索树。它将一段区间划分为若干单位区间，每一个节点都储存着一个区间。 它功能强大，支持区间求和，区间最大值，区间修改，单点修改等操作。 线段树的每一个节点都储存着一段区间[L…R]的信息，其中叶子节点L=R。 它的大致思想是：将一段大区间平均地划分成2个小区间，每一个小区间都再平均分成2个更小区间……以此类推， 直到每一个区间的L等于R（这样这个区间仅包含一个节点的信息，无法被划分）。通过对这些区间进行修改、查询，来实现对大区间的修改、查询。 这样一来，每一次修改、查询的时间复杂度都只为O(logn) 但是，可以用线段树维护的问题必须满足区间加法，否则是不可能将大问题划分成子问题来解决的。 初阶线段树单点修改区间查询区间求和//HDU 1166 单点更新区间求和 #include&lt;bits/stdc++.h&gt; using namespace std; #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 const int maxn=1e5+5; int sum[maxn&lt;&lt;2],a[maxn],n; void pushup(int rt) {sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];} void build(int l,int r,int rt){ if(l==r) {sum[rt]=a[l];return;} int m=(l+r)&gt;&gt;1;build(lson);build(rson);pushup(rt); } void update(int p,int t,int l,int r,int rt){ if(l==r) {sum[rt]+=t;return;} int m=(l+r)&gt;&gt;1; if(p&lt;=m) update(p,t,lson); else update(p,t,rson); pushup(rt); } int query(int L,int R,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r) return sum[rt]; int m=(l+r)&gt;&gt;1,ans=0; if(L&lt;=m) ans+=query(L,R,lson); if(R&gt;m) ans+=query(L,R,rson); return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); int t;cin&gt;&gt;t;int ca=1; while(t--){ cin&gt;&gt;n;for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; cout&lt;&lt;&quot;Case &quot;&lt;&lt;ca++&lt;&lt;&quot;:&quot;&lt;&lt;endl;build(1,n,1);string s; while(cin&gt;&gt;s){ if(s[0]==&apos;E&apos;) break;int x,y;cin&gt;&gt;x&gt;&gt;y; if(s[0]==&apos;Q&apos;) cout&lt;&lt;query(x,y,1,n,1)&lt;&lt;endl; else if(s[0]==&apos;A&apos;) update(x,y,1,n,1); else update(x,-y,1,n,1); } } } 区间最值//HDU-1754 单点更新区间最值 #include&lt;bits/stdc++.h&gt; using namespace std; #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 const int maxn=2e5+5; int ans[maxn&lt;&lt;2],a[maxn],n,m; void pushup(int rt) {ans[rt]=max(ans[rt&lt;&lt;1],ans[rt&lt;&lt;1|1]);} void build(int l,int r,int rt){ if(l==r) {ans[rt]=a[l];return;} int m=(l+r)&gt;&gt;1;build(lson);build(rson);pushup(rt); } void update(int p,int t,int l,int r,int rt){ if(l==r){ans[rt]=t;return;} int m=(l+r)&gt;&gt;1; if(p&lt;=m) update(p,t,lson); else update(p,t,rson); pushup(rt); } int query(int L,int R,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r) return ans[rt]; int m=(l+r)&gt;&gt;1,ret=0; if(L&lt;=m) ret=max(ret,query(L,R,lson)); if(R&gt;m) ret=max(ret,query(L,R,rson)); return ret; } int main() { ios::sync_with_stdio(0);cin.tie(0); while(cin&gt;&gt;n&gt;&gt;m){ for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; build(1,n,1);char c;int x,y; while(cin&gt;&gt;c&gt;&gt;x&gt;&gt;y){ if(c==&apos;U&apos;) update(x,y,1,n,1); else cout&lt;&lt;query(x,y,1,n,1)&lt;&lt;endl; } } } 区间修改区间查询需要lazy标记 区间替换//HDU-1698 区间替换 #include&lt;bits/stdc++.h&gt; using namespace std; #define lson l,m+1,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 const int maxn=1e5+5; int sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],a[maxn],n; void pushup(int rt){ sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1]; } void pushdown(int rt,int m){ if(lazy[rt]){ lazy[rt&lt;&lt;1]=lazy[rt&lt;&lt;1|1]=lazy[rt]; sum[rt&lt;&lt;1]=(m-(m&gt;&gt;1))*lazy[rt]; sum[rt&lt;&lt;1|1]=(m&gt;&gt;1)*lazy[rt]; lazy[rt]=0; } } void build(int l,int r,int rt){ lazy[rt]=0; if(l==r) {sum[rt]=a[l];return;} int m=(l+r)&gt;&gt;1; build(lson);build(rson);pushup(rt); } void update(int L,int R,int c,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r){ lazy[rt]=c;sum[rt]=(r-l+1)*c;return; } pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; if(L&lt;=m) update(L,R,c,lson); if(R&gt;m) update(L,R,c,rson); pushup(rt); } int query(int L,int R,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r) return sum[rt]; pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; int ans=0; if(L&lt;=m) ans+=query(L,R,lson); if(R&gt;m) ans+=query(L,R,rson); cout&lt;&lt;ans&lt;&lt;endl; } int main() { ios::sync_with_stdio(0);cin.tie(0); int t,n,m,ca=1;cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; build(1,n,1); while(m--){ int x,y,z;cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; update(x,y,z,1,n,1); } cout&lt;&lt;&quot;Case &quot;&lt;&lt;ca++&lt;&lt;&quot;: The total value of the hook is &quot;&lt;&lt;sum[1]&lt;&lt;&quot;.&quot;&lt;&lt;endl; } } 区间增减//POJ-3468 区间增减 #include&lt;iostream&gt; typedef long long ll; using namespace std; #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 const int maxn=1e5+5; ll sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],a[maxn]; int n,m; void pushup(int rt){ sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1]; } void build(int l,int r,int rt){ lazy[rt]=0; if(l==r) {sum[rt]=a[l];return;} int m=(l+r)&gt;&gt;1; build(lson);build(rson);pushup(rt); } void pushdown(int rt,int m){ if(lazy[rt]){ lazy[rt&lt;&lt;1]+=lazy[rt]; lazy[rt&lt;&lt;1|1]+=lazy[rt]; sum[rt&lt;&lt;1]+=(m-(m&gt;&gt;1))*lazy[rt]; sum[rt&lt;&lt;1|1]+=((m&gt;&gt;1))*lazy[rt]; lazy[rt]=0; } } void update(int L,int R,int c,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r){sum[rt]+=(r-l+1)*c;lazy[rt]+=c;return;} pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; if(L&lt;=m) update(L,R,c,lson); if(R&gt;m) update(L,R,c,rson); pushup(rt); } ll query(int L,int R,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r) return sum[rt]; pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; ll ans=0; if(L&lt;=m) ans+=(ll)query(L,R,lson); if(R&gt;m) ans+=(ll)query(L,R,rson); return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); while(cin&gt;&gt;n&gt;&gt;m){ for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; build(1,n,1); char c;int x,y,z; while(m--){ cin&gt;&gt;c&gt;&gt;x&gt;&gt;y; if(c==&apos;Q&apos;) cout&lt;&lt;query(x,y,1,n,1)&lt;&lt;endl; else {cin&gt;&gt;z;update(x,y,z,1,n,1);} } } } 中阶线段树乘法线段树//https://www.luogu.org/problem/P3373 题意：三种操作：将某区间每一个数乘上x、将某区间每一个数加上x、求出某区间每一个数的和 思路：注意加法和乘法的优先级，维护两种lazy标记。 输入： 输出： 5 5 38 17 1 5 4 2 3 2 2 1 4 1 3 2 5 1 2 4 2 2 3 5 5 3 1 4 #include&lt;bits/stdc++.h&gt; #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 using namespace std; const int maxn=1e5+5; typedef long long ll; ll sum[maxn&lt;&lt;2],mlz[maxn&lt;&lt;2],plz[maxn&lt;&lt;2]; ll n,m,p; inline void pushup(int rt){sum[rt]=(sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1])%p;} inline void Build(int l,int r,int rt){ mlz[rt]=1;plz[rt]=0; if(l==r){ll t;cin&gt;&gt;t;sum[rt]=t%p;return;} int m=(l+r)&gt;&gt;1;Build(lson);Build(rson);pushup(rt); } inline void pushdown(int rt,int m){ ll k1=mlz[rt],k2=plz[rt]; sum[rt&lt;&lt;1]=(sum[rt&lt;&lt;1]*k1+(m-(m&gt;&gt;1))*k2)%p;//左边和乘以乘法lazy+元素总数*加法lazy sum[rt&lt;&lt;1|1]=(sum[rt&lt;&lt;1|1]*k1+((m&gt;&gt;1))*k2)%p;//右边和乘以乘法lazy+元素总数*加法lazy mlz[rt&lt;&lt;1]=(mlz[rt&lt;&lt;1]*k1)%p;//乘法标记向左下推 mlz[rt&lt;&lt;1|1]=(mlz[rt&lt;&lt;1|1]*k1)%p;//乘法标记向右下推 plz[rt&lt;&lt;1]=(plz[rt&lt;&lt;1]*k1+k2)%p;//左下加法lazy*父节点的乘法lazy+左下乘法lazy plz[rt&lt;&lt;1|1]=(plz[rt&lt;&lt;1|1]*k1+k2)%p;//右下加法lazy*父节点的乘法lazy+左下乘法lazy mlz[rt]=1;plz[rt]=0;//lazy标记置位 } inline void add(int L,int R,int x,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r){ sum[rt]+=(r-l+1)*x%p; plz[rt]=(plz[rt]+x)%p;//修改加法lazy return; } pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; if(L&lt;=m) add(L,R,x,lson); if(R&gt;m) add(L,R,x,rson); pushup(rt); } inline void mul(int L,int R,int x,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r){ sum[rt]=sum[rt]*x%p; mlz[rt]=(mlz[rt]*x)%p;//乘以一个数后，加法的lazy标记应该也被乘以这个数 plz[rt]=(plz[rt]*x)%p;//修改乘法lazy return; } pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; if(L&lt;=m) mul(L,R,x,lson); if(R&gt;m) mul(L,R,x,rson); pushup(rt); } inline ll query(int L,int R,int l,int r,int rt){ if(L&lt;=l&amp;&amp;R&gt;=r) {return sum[rt];} pushdown(rt,r-l+1);//查询记得将lazy下推 int m=(l+r)&gt;&gt;1; ll ans=0; if(L&lt;=m) ans+=query(L,R,lson); if(R&gt;m) ans+=query(L,R,rson); return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;Build(1,n,1); for(int i=0;i&lt;m;i++){ int f,a,b,c;cin&gt;&gt;f; if(f==1){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;c%=p;mul(a,b,c,1,n,1); } else if(f==2){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;c%=p;add(a,b,c,1,n,1); } else{ cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;query(a,b,1,n,1)%p&lt;&lt;endl; } } } 根号线段树//HDU-4027 根号线段树 题意：两种操作：将某区间每一个数取根号、求出某区间每一个数的和 思路：注意优化，如果区间和位区间长度，则无需取根号，1e18的数取根号6~7次变为1 输入： 输出： 10 Case #1: 1 2 3 4 5 6 7 8 9 10 19 5 7 0 1 10 6 1 1 10 1 1 5 0 5 8 1 4 8 #include&lt;bits/stdc++.h&gt; using namespace std; #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 const int maxn=1e5+5; typedef long long ll; ll sum[maxn&lt;&lt;2]; void PushUP(int rt){sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];} void build(int l,int r,int rt){ if(l==r){scanf(&quot;%lld&quot;,&amp;sum[rt]);return;} int m=(l+r)&gt;&gt;1;build(lson);build(rson);PushUP(rt); } void Sqrt(int L,int R,int l,int r,int rt) { if(l==r){sum[rt]=sqrt(sum[rt]);return;} if(L&lt;=l&amp;&amp;R&gt;=r&amp;&amp;sum[rt]==r-l+1) return;//如果区间内的所有数都是1则不必更新 int m=(l+r)&gt;&gt;1; if(L&lt;=m) Sqrt(L,R,lson); if(m&lt;R) Sqrt(L,R,rson); PushUP(rt); } ll query(int L,int R,int l,int r,int rt) { if(L&lt;=l&amp;&amp;r&lt;=R) return sum[rt]; int m=(l+r)&gt;&gt;1; ll ans=0; if(L&lt;=m) ans+=query(L,R,lson); if(R&gt;m) ans+=query(L,R,rson); return ans; } int main() { int n,m,t=0; while(scanf(&quot;%d&quot;,&amp;n)==1) { int a,b,c; build(1,n,1); scanf(&quot;%d&quot;,&amp;m); printf(&quot;Case #%d:\n&quot;,++t); while(m--) { scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); if(b&gt;c) swap(b,c); if(a) printf(&quot;%lld\n&quot;,query(b,c,1,n,1)); else Sqrt(b,c,1,n,1); } printf(&quot;\n&quot;); } return 0; }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈常见模型]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%8D%9A%E5%BC%88%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Bash Game(巴什博奕)1堆物品有n,两个人轮流取,每次至少取1个,最多m个,取完者胜。 结论：n%(m+1)!=0 先手必胜，这个可以用SG函数证明. 比如n=10,m=3;先手先取2个,后手取x个，先手再取4-x个，如此往复，先手必胜 Bash Game变形:每次取的个数在[p,q]之间(HDU2897,取完的输，注意) 通过n%(p+q)判断胜负； 1.n=k∗(p+q)时，先手第一次取q个，随后的回合若后手取x个，先手再取p+q−x个，那么最后就会留给后手p个，先手胜。 2.n=k∗(p+q)+s时，则要分情况考虑： 若s在[1,p]之间，先手取x，后手可以取p+q−x，最后留给先手s个，后手胜； 若s在(p,p+q)之间，先手任取x个(1≤s−x&lt;p)，后手取y个，先手可以再取p+q−y，最后留给后手s-x 个，先手胜； #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ll n,p,q; while(~scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;p,&amp;q)){ if(n%(p+q)==0||n%(p+q)&gt;p) cout&lt;&lt;&quot;WIN&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;LOST&quot;&lt;&lt;endl; } } Wythoff’s Game(威佐夫博弈)有两堆石子，一堆有m个，另一堆有n个。 双方轮流取走一些石子，合法的取法有如下两种： 1. 在一堆石子中取走任意多颗； 2. 在两堆石子中取走相同多的任意颗. 取走最后一颗石子的人为赢家。 (1,2)与(2,1)视为同一状态，第k个必败状态是(⌊(√5+1)/2∗k⌋+k,⌊(√5+1)/2∗k⌋)。 拓展性质： 1.令(m(k),n(k))=(⌊(√5+1)/2∗k⌋+k,⌊(√5+1)/2∗k⌋)则m(k)也表示前k个必败状态中没出现的自然数。 2.每个自然数都会出现在必败状态中且仅会出现一次。 /HDU 1527 模板题 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a,b ; while(cin&gt;&gt;a&gt;&gt;b){ if(a&lt;b) swap(a,b); int k=a-b; int n=(int)(k*(sqrt(5.0)+1.0)/2); bool win=(n!=b) ; cout&lt;&lt;win&lt;&lt;endl ; } return 0; } HDU-2177 加强版 //待补。。。 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+5; bool check(int n,int m){ if(n&lt;m) swap(n,m); int k=n-m; int t=(int)(k*(sqrt(5)+1.0)/2.0); return t==n; } int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m; while(cin&gt;&gt;n&gt;&gt;m,n+m){ if(!check(n,m)) cout&lt;&lt;0&lt;&lt;endl; else{ } } } Fibonacci’s Game(斐波那契博弈)//详见：https://blog.csdn.net/acdreamers/article/details/8586135 有一堆个数为n&gt;=2的石子。 双方轮流取石子，满足以下条件： 1. 先手不能在第一次把所有的石子取完； 2. 之后每次可以取的石子数介于 1 到对手刚取的石子数的 2 倍之间（包含 1 和对手刚取的石子数的 2 倍） 取走最后一个石子的人为赢家。如果 n 是斐波那契数，则后手胜；反之，先手胜。 Zeckendorf定理：任何正整数可以表示为若干个不连续的 Fibonacci 数之和。 \\HDU 2516 模板题 #include&lt;bits/stdc++.h&gt; using namespace std; const string win[2]= { &quot;Second win&quot; , &quot;First win&quot; } ; long long fib[100] ; int init() { fib[0] = 1 ; fib[1] = 1 ; for ( int i = 2 ; i &lt; 100 ; i++ ) { fib[i] = fib[i-1] + fib[i-2] ; if ( fib[i] &gt; ( 1LL &lt;&lt; 35 ) ) return i ; } return 100 ; } int main() { int n ; int len = init() ; while ( cin &gt;&gt; n &amp;&amp; n ) { int ok = 1 ; for ( int i = 0 ; i &lt;= len ; i++ ) { if ( fib[i] == n ) { ok = 0 ; break ; } } cout &lt;&lt; win[ok] &lt;&lt; endl ; } return 0; } Nim博弈(尼姆博弈)有n堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 把每一项异或起来，结果为0则先手必败，否则先手胜利。 //HDU-2176 如果先手胜利，则输出第一次它可以取哪一堆，即在一堆中取走若干使得剩下的数字异或之和为0 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e5+5; int a[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int n; while(cin&gt;&gt;n,n){ int ans=0; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i];ans^=a[i]; } if(ans==0) cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; else{ cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; for(int i=0;i&lt;n;i++){ int t=ans;t^=a[i]; if(t&lt;=a[i]) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl; } } } }]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SG函数与SG定理]]></title>
    <url>%2F2019%2F07%2F26%2FSG%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[SG函数-引入SG函数用来判断博弈问题的输赢，当SG函数值为0时表示输，不为0表示赢。 定义mex(s)表示不属于s集合的最小非负整数，例如:mex{0,1,2}=3、mex{1,2,3}=0、mex{0,1,3}=2 定义SG函数:SG(x)=mex{SG(y)|y是x的后继,也就是经过操作可以取得的剩下值} S是x后继状态的SG函数值的集合。如x有三个后继状态分别为SG(a),SG(b),SG(c)那么SG(x)=mex{SG(x)}=mex{SG(a,SG(b),SG(c))}。这样集合S的终态必然是空集，所以SG函数的终态为SG(x)=0,当且仅当x为必败点P时。 例如：一堆石子，我们可以取任意个，那么x个石子的石子的sg值是多少呢？ 可以知道，0个石子sg为0，1的时候我们可以取1个，剩下0，而0的sg是0，那么mex{0}就是1，所以1的sg为1。即SG(1)=mex{SG(0)}=mex{0}=1; SG(2)=mex{SG(0),SG(1)}=mex{0,1}=2;SG(3)=mex(SG(0),SG(1),SG(2))=mex{0,1,2}=3 继续往下，当为x的时候我们可以取1~x个，那么剩下的值石子个数就是x-1到0个，他的mex（...）就是x，所以这个例子的x值得sg值就是x，即SG(x)=mex{SG(0),SG(1),SG(2),SG(3),...,SG(x-1)=x; SG函数的作用： Nimm博弈中，对于多堆，只需将每堆的SG值异或一下(每堆的数量)，如果是0则为输，否则为赢 组合游戏在竞赛中，组合游戏的题目一般有以下特点 1.题目描述一般为A,B 2人做游戏 2.A,B交替进行某种游戏规定的操作，每操作一次，选手可以在有限的操作（操作必须合法）集合中任选一种。 3.对于游戏的任何一种可能的局面，合法的操作集合只取决于这个局面本身，不取决于其它因素（跟选手，以前的所有操作无关） 4.如果当前选手无法进行合法的操作，则为负 必胜点与必败点必败点(P点) 前一个(previous player)选手将取胜的点称为必败点 必胜点(N点) 下一个(next player)选手将取胜的点称为必胜点 必胜点和必败点的性质： - 所有的终结点都是必败点 - 从任何必胜点操作，至少有一种方式进入必败点 - 无论如何操作， 从必败点都只能进入必胜点. SG定理游戏和的SG函数等于各个游戏SG函数的Nim和。这样就可以将每一个子游戏分而治之，从而简化了问题。而Bouton定理就是Sprague-Grundy定理在Nim游戏中的直接应用，因为单堆的Nim游戏SG函数满足SG(x)=x。 举栗-取石子游戏有1堆n个的石子，每次只能取{1,3,4}个石子，先取完石子者胜利，那么各个数的SG值为多少？ SG(0)=0,f[]={1,3,4}. x=1时，可以取走1-f[1]个石子,剩余{0}个，所以SG(1)=mex{SG(0)}=mex{0}=1; x=2时，可以取走2-f[1]个石子,剩余{1}个，所以SG(2)=mex{SG(1)}=mex{1}=0; x=3时，可以取走3-f[1,3]个石子,剩余{2,0}个，所以SG(3)=mex{SG(0),SG(2)}=mex{0,0}=0; x=4时，可以取走4-f[1,2,3]个石子,剩余{3,1,0}个，所以SG(4)=mex{SG(3),SG(1),SG(0)}=mex{0,1}=2; x=5时，可以取走5-f[1,2,3]个石子,剩余{4,2,1}个，所以SG(5)=mex{SG(4),SG(2),SG(1)}=mex{2,1,0}=3; 继续推：SG(6)=2、SG(7)=0、SG(8)=1 ..... 编程时只需模拟上述过程计算1~n的SG函数值： 1.使用数组f将 可改变当前状态 的方式记录下来。 2.然后我们使用 另一个数组 将当前状态x的后继状态标记。 3.最后模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x)。 4.我们不断的重复2-3的步骤，就完成了计算1~n的函数值。 //f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理 //SG[]:0~n的SG函数值 //S[]:为x后继状态的集合 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e5+5; int f[3]={1,2,4},SG[maxn],S[maxn];//S为状态集合 int N=3;//f的个数 void getSG(int n){ memset(SG,0,sizeof(SG)); for(int i=1;i&lt;=n;i++){//因为SG[0]始终等于0，所以i从1开始 memset(S,0,sizeof(S));//每一次都要将上一状态 的 后继集合 重置 for(int j=0;f[j]&lt;=i&amp;&amp;j&lt;=N;j++) S[SG[i-f[j]]]=1;//将后继状态的SG函数值进行标记 for(int j=0;;j++) //查询当前后继状态SG值中最小的非零值 if(!S[j]){SG[i]=j;break;} } } int main() { ios::sync_with_stdio(0);cin.tie(0); int n,x;cin&gt;&gt;n;getSG(n); while(cin&gt;&gt;x){ cout&lt;&lt;SG[x]&lt;&lt;endl; } } 题目HDU-4388(找1个数的奇偶性)(博弈+找规律)//HDU-4388 Stone Game II 题意：给出n堆物品，每堆物品都有若干件，现在A和B进行游戏，每人每轮操作一次，按照如下规则： 1. 任意选择一个堆，假设该堆有x个物品，从中选择k个，要保证0&lt;k&lt;x且0&lt;(x^k)&lt;k。 2. 再增加一个大小为x^k的堆，另外有一个技能，可以将这个大小为x^k的堆变成(2*k)^x的堆，但是这个技能每个人只有一次机会可以使用。 现在问两人轮流操作，都采取最优策略，最后不能操作的人输，问谁会赢。 思路：不考虑技能的话，一堆x分为k和k^x，实际上在二进制下x中1的个数与k和k^x中1的个数的奇偶性保持一致。 考虑技能，一堆x分为k和(k&lt;&lt;1)^x,其中二者之间的奇偶性也没变，可以写一个试一下。 游戏终止的条件是一堆不能再分了，即分到最后每堆中1的个数都为1，于是原来的n堆可以分为n个数中1(二进制下)的个数之和堆(设为cnt)， 需要分(cnt-n)次才行，于是变成了判断(cnt-n)的奇偶性，为奇数时先手赢否则先手输。 ^.^貌似和SG没啥关系。。。但是大佬的博客把这一题归在SG #include&lt;bits/stdc++.h&gt; using namespace std; int cal(int x){ int ans=0; while(x){ ans+=(x&amp;1); x&gt;&gt;=1; } return ans; } int main() { ios::sync_with_stdio(0);cin.tie(0); int T;cin&gt;&gt;T;int ca=1; while(T--){ int n,ans=0;cin&gt;&gt;n; while(n--){ int t;cin&gt;&gt;t;ans+=cal(t)-1; } cout&lt;&lt;&quot;Case &quot;&lt;&lt;ca++&lt;&lt;&quot;: &quot;; if(ans&amp;1) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } }]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2019%2F07%2F23%2F%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[背包问题参考背包九讲的内容，首先给定一个有容量的背包(限定条件)，再给出每件(种)物品的价值和体积，背包问题大致可分为以下几种： 1.01背包(n个物品，对每个物品选或不选) 2.完全背包(n种物品，每种可取无数件，每件物品选或不选) 3.多重背包(n种物品，每种可取k[i]件,不选/选/选几件) 4.分组背包(n组物品，每组最多选一件，选/不选) 5.二维费用背包(两个维度的限制条件) 6.混合背包(1.2.3三种情况的混合) 7.其他(问法不同(最值与可行性)、泛化物品) 01背包最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放 F[i,v] 表示前 i 件物品恰放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程便是： F[i,v]=max{F[i−1,v],F[i−1,v−C[i]]+W[i]} 伪代码(时间和空间复杂度均为O(VN))： F[0,0..V ] ← 0 for i ← 1 to N for v ← C i to V F[i,v]=max{F[i−1,v],F[i−1,v−C[i]]+W[i]} 滚动数组优化空间复杂度：F[v]=max{F[v],F[v−C[i]]+W[i]} 伪代码(时间复杂度O(VN)、空间复杂度为O(N))： F[0..V ]←0 for i ← 1 to N for v ← V to C i //注意递推是从上一次的正上方和左边过来的，这里就不难理解了 F[v]=max{F[v],F[v−C[i]]+W[i]} 不同的问法：恰好装满 与 不必装满 若是恰好装满，那么在初始化时除了F[0]为0，其它F[1..V]均设为 −∞ ，这样就可以保证最终得到的F[V]是一种恰好装满背包的最优解。 可以理解为：初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满， 那么此时只有容量为 0 的背包可以在什么也不装且价值为0的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 -∞ 了。 如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为0了。 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 F[0..V ]全部设为 0 。 01背包题目HDU-2995 小数/概率 背包题意：抢劫银行，给定被抓最大概率P，给出n个银行(其价值和被抓概率)，求被抓概率小于P的情况下，可抢到的最大价值。 注意：概率不是累加而是累乘，同时应把最抓概率转换成不被抓概率，因为被抓概率累乘会变得更小，显然错误，应该是不被抓概率累乘变得更小。 思路：开始直接想到背包容量定为最大概率P，但是它是小数，想到P*100(or 1ek)转化为整数 结果WA； 于是转变思路，让背包容量等于所有银行价值之和，dp[i]-&gt;不被抓概率 //HDU-2995 小数/概率 背包 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=105; int w[maxn]; double v[maxn],dp[maxn*100]; int main() { ios::sync_with_stdio(0);cin.tie(0); int T;cin&gt;&gt;T; //int V=0 开始在这里定义 结果TLE 怎么又犯这种错误. while(T--){ int V=0; double P;int n;cin&gt;&gt;P&gt;&gt;n;P=1.0-P;//转为不被抓概率 for(int i=0;i&lt;n;i++){ cin&gt;&gt;w[i]&gt;&gt;v[i];v[i]=1.0-v[i];V+=w[i]; } for(int i=0;i&lt;n*100;i++) dp[i]=0;dp[0]=1; for(int i=0;i&lt;n;i++){ for(int j=V;j&gt;=w[i];j--){ dp[j]=max(dp[j],dp[j-w[i]]*v[i]); } } int ans=0; for(int i=V;i&gt;=0;i--){ if(dp[i]&gt;=P){ ans=i;break; } } cout&lt;&lt;ans&lt;&lt;endl; } } CF-366C 转化为01背包题意:有n个水果, 每个水果都有两个属性值ai表示美味程度, bi表示能量值, 现在要求选出一个或多个水果, 使得选出的水果的ai和与bi和的比例是k 问在这种情形可能出现的情况下ai的和最多是多少, 如果这样的情形不存在输出 -1 思路：每个物品的耗费是a[i]-k*b[i]的物品，这样就可以转化为01背包，求dp[i][0]，但是这样算耗值可能是负值，所以我们数组平移n*100个单位，就可以求出dp[n][m] 注意：此题不能用一个dp数组完成滚动，因为a[i]-k*b[i]可能为负值，转移可能来自上一层的左上方或右上方，若滚动会覆盖冲突。 //CF-366C 转化为01背包 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=105; const int INF=0x3f3f3f3f; int n,k; int a[maxn],b[maxn],dp[maxn][maxn*300]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;k; memset(dp,-INF,sizeof(dp));//无意义状态 dp[0][100*n]=0;//不选时合法 for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;b[i];b[i]=a[i]-k*b[i]; } for(int i=1;i&lt;=n;i++){ for(int j=b[i];j&lt;=200*n;j++){ dp[i][j]=max(dp[i-1][j],dp[i-1][j-b[i]]+a[i]); } } int ans=dp[n][100*n]; cout&lt;&lt;(ans?ans:-1)&lt;&lt;endl; } 完全背包完全背包与01背包唯一不同的是完全背包的每件物品可重复使用无数次。 状态转移： F[i,v] = max{F[i−1,v−kC[i]]+kW[i] | 0 ≤ kC[i]≤ v} 伪代码： F[0..V]←0 for i ← 1 to N for v ← C i to V F[v] ← max(F[v],F[v − C[i]] + W[i]) 有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。 第 i 种物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤1000 0&lt;vi,wi≤1000 样例 输入:4 5 输出：10 1 2 2 4 3 4 4 5 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; int v[maxn],w[maxn],dp[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int N,V;cin&gt;&gt;N&gt;&gt;V; for(int i=0;i&lt;N;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=0;i&lt;N;i++) dp[i]=0; for(int i=0;i&lt;N;i++) for(int j=v[i];j&lt;=V;j++)//注意循环方向 dp[j]=max(dp[j],dp[j-v[i]]+w[i]); cout&lt;&lt;dp[V]&lt;&lt;endl; } 多重背包(待补单调队列优化)多重背包中每个物品可使用的次数是有限制条件的，因此要假如第三重循环，限制选的次数。 注意：背包问题中第一重循环是物品种类 ，第二重是背包体积 ，第三重是限制条件 多重背包的优化： 二进制优化、单调队列优化 模版题： 有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 无优化 O(n*V*S)： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; int dp[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int N,V;cin&gt;&gt;N&gt;&gt;V; for(int i=0;i&lt;N;i++) dp[i]=0; for(int i=0;i&lt;N;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; for(int j=V;j&gt;=v;j--) for(int k=0;k&lt;=s&amp;&amp;k*v&lt;=j;k++) dp[j]=max(dp[j],dp[j-k*v]+k*w); } cout&lt;&lt;dp[V]&lt;&lt;endl; } 二进制优化 O(n*V*ΣS)： 数据范围：0&lt;N≤1000 0&lt;V≤2000 0&lt;vi,wi,si≤2000 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e3+5; int dp[maxn]; struct node{ int v,w; }; vector&lt;node&gt; goods; int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m;cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; for(int k=1;k&lt;=s;k*=2){ s-=k;goods.push_back({v*k,w*k}); } if(s) goods.push_back({v*s,w*s}); } for(auto good:goods) for(int j=m;j&gt;=good.v;j--) dp[j]=max(dp[j],dp[j-good.v]+good.w); cout&lt;&lt;dp[m]&lt;&lt;endl; } 单调队列优化 0(N*V): //未懂，待补+双端队列(滑动窗口) 数据范围：0&lt;N≤1000 0&lt;V≤20000 0&lt;vi,wi,si≤20000 双端队列思想优化背包问题-&gt; https://blog.csdn.net/hebtu666/article/details/83018230 首先优化思路来自最最原始的无优化的方程。 仔细观察，对于任意的j，都是从v[i]的倍数转移过来的。它们本来应该是连续的，可以用滑动窗口（不熟悉此问题的同学可以先行百度）解决。但在无优化的时候却每次把所有的倍数都遍历了一遍。 所以可以把m根据模v[i]的余数分为v[i]类。 for(int j=0;j&lt;v;j++) 此时对于任意的j，只需要向v[i]的倍数去转移。所以我们在下一层循环的时候把k定义为j+k*v[i] for(int k=j;k&lt;=m;k+=v) 此时的k相当于原来的j，但是我们可以利用k和v之间存在的倍数关系去做滑动窗口。 由于滑动窗口记录的是下标，但每一个k所对应的下标都是在变化的。所以要根据当前的k判断窗口里存在的k对应的值包含了多少个v，以便于计算新的价值 v的个数=(下标-余数)/v 价值=(下标-余数)/v*w =(q[h]-j)/v =(k-j)/v*w 然后每次只用了前i-1的值，所以可以滚动数组优化一下空间 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=2e4+5; int n,m,dp[maxn],q[maxn],g[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; memcpy(g,dp,sizeof(dp));//滚动数组优化空间，g[]即dp[i-1][]; for(int j=0;j&lt;v;j++){ int h=0,t=-1; for(int k=j;k&lt;=m;k+=v){ dp[k]=g[k]; if(h&lt;t&amp;&amp;k-s*v&gt;q[h]) h++;//如果当前窗口的内容超过了s个; if(h&lt;=t) dp[k]=max(dp[k],g[q[h]]+(k-q[h])/v*w);//max(f[i-1][k],f[i-1][能转移里最大]+个数*v[i]); while(h&lt;=t&amp;&amp;g[q[t]]-(q[t]-j)/v*w&lt;=g[k]-(k-j)/v*w) t--; q[++t]=k; } } } cout&lt;&lt;dp[m]&lt;&lt;endl; } 混合背包混合背包就是把以上三种背包问题混合在一起，什么物品可以选几次有响应的限制条件，根据条件选择不同的dp方程即可 模版题： 有 N 种物品和一个容量是 V 的背包。物品一共有三类： * 第一类物品只能用1次（01背包）； * 第二类物品可以用无限次（完全背包）； * 第三类物品最多只能用 si 次（多重背包）； 每种体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式： 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 si=−1 表示第 i 种物品只能用1次； si=0 表示第 i 种物品可以用无限次； si&gt;0 表示第 i 种物品可以使用 si 次； 输出格式： 输出一个整数，表示最大价值。 数据范围：0&lt;N,V≤1000 ，0&lt;vi,wi≤1000 ，−1≤si≤1000 输入样例： 输出样例： 4 5 8 1 2 -1 2 4 1 3 4 0 4 5 2 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e3+5; int dp[maxn]; struct node{ int v,w,s; }; int n,V; vector&lt;node&gt; G; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=0;i&lt;n;i++){ int v,w,s;cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; if(s==-1) G.push_back({v,w,-1}); else if(s==0) G.push_back({v,w,0}); else{ for(int k=1;k&lt;=s;k*=2){ G.push_back({v*k,w*k,-1});s-=k; } if(s) G.push_back({v*s,w*s,-1}); } } for(auto g:G){ if(g.s==-1) for(int j=V;j&gt;=g.v;j--) dp[j]=max(dp[j],dp[j-g.v]+g.w); else if(g.s==0) for(int j=g.v;j&lt;=V;j++) dp[j]=max(dp[j],dp[j-g.v]+g.w); } cout&lt;&lt;dp[V]&lt;&lt;endl; } 二维费用背包二维费用背包就是加了重限制条件，物品的总体积与物品的总重量都不能超过背包可承受范围。 有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。 每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。 输出最大价值。 输入格式： 第一行两个整数，N，V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。 接下来有 N 行，每行三个整数 vi,mi,wi，用空格隔开，分别表示第 i 件物品的体积、重量和价值。 输出格式： 输出一个整数，表示最大价值。 数据范围： 0&lt;N≤1000 ，0&lt;V,M≤100 ，0&lt;vi,mi≤100 ，0&lt;wi≤1000 输入样例： 输出样例： 4 5 6 8 1 2 3 2 4 4 3 4 5 4 5 6 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e3+5; int n,V,M; int v[maxn],m[maxn],w[maxn]; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V&gt;&gt;M; for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i]&gt;&gt;m[i]&gt;&gt;w[i]; for(int i=0;i&lt;n;i++) for(int j=V;j&gt;=v[i];j--) for(int k=M;k&gt;=m[i];k--) dp[j][k]=max(dp[j][k],dp[j-v[i]][k-m[i]]+w[i]); cout&lt;&lt;dp[V][M]&lt;&lt;endl; } 分组背包分组背包就是把物品分为很多组，限定每组最多可选的个数 有 N 组物品和一个容量是 V 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。 每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。 接下来有 N 组数据： 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量； 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值； 输出格式 输出一个整数，表示最大价值。 数据范围：0&lt;N,V≤100，0&lt;Si≤100，0&lt;vij,wij≤100 输入样例： 输出样例： 3 5 8 2 1 2 2 4 1 3 4 1 4 5 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=1e2+5; int n,V; int v[maxn],w[maxn];//体积和价值 int dp[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=0;i&lt;n;i++){ int s;cin&gt;&gt;s; for(int j=1;j&lt;=s;j++) cin&gt;&gt;v[j]&gt;&gt;w[j]; for(int j=V;j&gt;=0;j--) for(int k=1;k&lt;=s;k++)每组选一个使价值最大化 if(j&gt;=v[k]) dp[j]=max(dp[j],dp[j-v[k]]+w[k]); } cout&lt;&lt;dp[V]&lt;&lt;endl; } 有依赖的背包问题(待补) 有 N 个物品和一个容量是 V 的背包。 物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。 如上图所示： 如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。 每件物品的编号是 i，体积是 vi，价值是 wi，依赖的父节点编号是 pi。物品的下标范围是 1…N。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式： 第一行有两个整数 N，V，用空格隔开，分别表示物品个数和背包容量。 接下来有 N 行数据，每行数据表示一个物品。 第 i 行有三个整数 vi,wi,pi，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。 如果 pi=−1，表示根节点。 数据保证所有物品构成一棵树。 输出格式： 输出一个整数，表示最大价值。 数据范围：1≤N,V≤100，1≤vi,wi≤100 父节点编号范围： 内部结点：1≤pi≤N; 根节点 pi=−1; 输入样例 输出样例： 5 7 11 2 3 -1 2 2 1 3 5 1 4 7 2 3 6 2 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 110; int n, m; int h[N], e[N], ne[N], idx; int v[N], w[N]; int f[N][N]; void add(int x, int y) { e[idx] = y, ne[idx] = h[x], h[x] = idx++; } void dfs(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int y = e[i]; dfs(y); for (int j = m - v[x]; j &gt;= 0; j--) { for (int k = 0; k &lt;= j; k++) { f[x][j] = max(f[x][j], f[x][j - k] + f[y][k]); } } } for (int i = m; i &gt;= v[x]; i--) { f[x][i] = f[x][i - v[x]] + w[x]; } for (int i = 0; i &lt; v[x]; i++) { f[x][i] = 0; } } int main() { memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int root; for (int i = 1; i &lt;= n; i++) { int p; cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p; if (p == -1) { root = i; } else { add(p, i); } } dfs(root); cout &lt;&lt; f[root][m] &lt;&lt; endl; return 0; } 背包问题求方案数有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 1e9+7 的结果。 输入格式: 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式: 输出一个整数，表示 方案数 模 109+7 的结果。 数据范围: 0&lt;N,V≤1000, 0&lt;vi,wi≤1000 输入样例: 输出样例: 4 5 2 1 2 2 4 3 4 4 6 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; const ll mod=1e9+7; int n,V; int v[maxn],w[maxn]; int dp[maxn]; ll num[maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=0;i&lt;=V;i++) num[i]=1; for(int i=1;i&lt;=n;i++){ for(int j=V;j&gt;=v[i];j--){ if(dp[j]&lt;dp[j-v[i]]+w[i]){ dp[j]=dp[j-v[i]]+w[i]; num[j]=num[j-v[i]]%mod; } else if(dp[j]==dp[j-v[i]]+w[i]){ num[j]=(num[j-v[i]]+num[j])%mod; } } } cout&lt;&lt;num[V]&lt;&lt;endl; } 背包问题求具有方案有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 1e9+7 的结果。 输入格式: 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式: 输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。 物品编号范围是 1…N 数据范围: 0&lt;N,V≤1000, 0&lt;vi,wi≤1000 输入样例: 输出样例: 4 5 1 4 1 2 2 4 3 4 4 6 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+5; const ll mod=1e9+7; int n,V; int v[maxn],w[maxn]; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); cin&gt;&gt;n&gt;&gt;V; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=n;i&gt;=1;i--) for(int j=0;j&lt;=V;j++){//这样写dp方程是因为dp[i][j]的意义与之前的不同 //dp[i][j] -&gt;从前i件物品中选，使得背包容量大于j的 方案的价值 if(j&gt;=v[i]) dp[i][j]=max(dp[i+1][j],dp[i+1][j-v[i]]+w[i]); else dp[i][j]=dp[i+1][j]; } for(int i=1;i&lt;=n;i++){ if(i==n&amp;&amp;V&gt;=v[i]){ cout&lt;&lt;i&lt;&lt;&quot; &quot;;break; } if(V-v[i]&gt;=0&amp;&amp;dp[i][V]==dp[i+1][V-v[i]]+w[i]){ cout&lt;&lt;i&lt;&lt;&quot; &quot;;V-=v[i]; } if(V&lt;0) break; } }]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCA]]></title>
    <url>%2F2019%2F07%2F17%2FLCA%2F</url>
    <content type="text"><![CDATA[LCA解决树上两点间的最近公共祖先，三种方式： 1.Tarjan 离线算法 O(n+q) 2.倍增 在线算法 O((n+q)*logn) 3.RMQ(ST表) 优秀的在线算法 O(nlogn+q) TarjanTarjan 算法求 LCA 的时间复杂度为 O(n+q) ，是一种离线算法，要用到并查集。（注：这里的复杂度其实应该不是 O(n+q) ，还需要考虑并查集操作的复杂度 ，但是由于在多数情况下，路径压缩并查集的单次操作复杂度可以看做 O(1)，所以写成了 O(n+q) 。） Tarjan 算法基于 dfs ，在 dfs 的过程中，对于每个节点位置的询问做出相应的回答。 dfs 的过程中，当一棵子树被搜索完成之后，就把他和他的父亲合并成同一集合；在搜索当前子树节点的询问时，如果该询问的另一个节点已经被访问过， 那么该编号的询问是被标记了的，于是直接输出当前状态下，另一个节点所在的并查集的祖先；如果另一个节点还没有被访问过，那么就做下标记，继续 dfs 。 板子1(NBWY)//离线Tarjan O(n+q) from NBWY //POJ-1470 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; const int maxn=905; vector&lt;int&gt; G[maxn],query[maxn]; int ans[maxn],fa[maxn]; bool vis[maxn],in[maxn]; int n,m; void init(){ for(int i=1;i&lt;=n;i++){ G[i].clear();query[i].clear(); fa[i]=i;in[i]=0;ans[i]=0;vis[i]=0; } } int find(int x){return fa[x]==x?x:find(fa[x]);} void add_edge(int u,int v){G[u].push_back(v);} void add_query(int u,int v){query[u].push_back(v);} void Tarjan(int u){ vis[u]=1; int size=query[u].size(); for(int i=0;i&lt;size;i++){ int v=query[u][i]; if(vis[v]) ans[find(v)]++; } size=G[u].size(); for(int i=0;i&lt;size;i++){ int v=G[u][i]; if(!vis[v]){ Tarjan(v);fa[v]=u; } } } int main() { while(~scanf(&quot;%d&quot;,&amp;n)){ init(); int u,v; for(int i=0;i&lt;n;i++){ scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;m); while(m--){ scanf(&quot;%d&quot;,&amp;v);in[v]=1; add_edge(u,v);add_edge(v,u); } } scanf(&quot;%d&quot;,&amp;m); while(m--){ scanf(&quot; (%d %d)&quot;,&amp;u,&amp;v); add_query(u,v);add_query(v,u); } for(int i=1;i&lt;=n;i++) if(!in[i]){ Tarjan(i);break; } for(int i=1;i&lt;=n;i++) if(ans[i]) printf(&quot;%d:%d\n&quot;,i,ans[i]); } } 板子2(Kuangbin)/* POJ 1470 离线处理 G++ 1204ms 8788K C++ 954ms 8304K */ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;math.h&gt; #include&lt;vector&gt; using namespace std; const int MAXN=1000; const int MAXM=500000;//最大查询数 int F[MAXN];//并查集 int r[MAXN];//并查集中集合的个数 bool vis[MAXN];//访问标记 int ancestor[MAXN];//祖先 struct Node { int to,next; }edge[MAXN*2]; int head[MAXN]; int tol; void addedge(int a,int b) { edge[tol].to=b; edge[tol].next=head[a]; head[a]=tol++; edge[tol].to=a; edge[tol].next=head[b]; head[b]=tol++; } struct Query { int q,next; int index;//查询编号 }query[MAXM*2];//查询数 int answer[MAXM];//查询结果 int cnt; int h[MAXM]; int tt; int Q;//查询个数 void add_query(int a,int b,int i) { query[tt].q=b; query[tt].next=h[a]; query[tt].index=i; h[a]=tt++; query[tt].q=a; query[tt].next=h[b]; query[tt].index=i; h[b]=tt++; } void init(int n) { for(int i=1;i&lt;=n;i++) { F[i]=-1; r[i]=1; vis[i]=false; ancestor[i]=0; tol=0; tt=0; cnt=0;//已经查询到的个数 } memset(head,-1,sizeof(head)); memset(h,-1,sizeof(h)); } int find(int x) { if(F[x]==-1)return x; return F[x]=find(F[x]); } void Union(int x,int y)//合并 { int t1=find(x); int t2=find(y); if(t1!=t2) { if(r[t1]&lt;=r[t2]) { F[t1]=t2; r[t2]+=r[t1]; } else { F[t2]=t1; r[t1]+=r[t2]; } } } void LCA(int u) { // if(cnt&gt;=Q)return;//这个不能加，加了就WR了 ancestor[u]=u; vis[u]=true;//这个一定要放在前面 for(int i=head[u];i!=-1;i=edge[i].next) { int v=edge[i].to; if(vis[v])continue; LCA(v); Union(u,v); ancestor[find(u)]=u; } for(int i=h[u];i!=-1;i=query[i].next) { int v=query[i].q; if(vis[v]) { answer[query[i].index]=ancestor[find(v)]; cnt++;//已经找到的答案数 } } } int Count_num[MAXN]; bool flag[MAXN]; int main() { // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int N; int u,v,m; char ch; while(scanf(&quot;%d&quot;,&amp;N)!=EOF) { init(N); memset(flag,false,sizeof(flag)); for(int i=1;i&lt;=N;i++) { scanf(&quot;%d:(%d)&quot;,&amp;u,&amp;m); while(m--) { scanf(&quot;%d&quot;,&amp;v); flag[v]=true; addedge(u,v); } } scanf(&quot;%d&quot;,&amp;Q); for(int i=0;i&lt;Q;i++) { cin&gt;&gt;ch; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); cin&gt;&gt;ch; add_query(u,v,i); } int root; for(int i=1;i&lt;=N;i++) if(!flag[i]) { root=i; break; } LCA(root); memset(Count_num,0,sizeof(Count_num)); for(int i=0;i&lt;Q;i++) Count_num[answer[i]]++; for(int i=1;i&lt;=N;i++) if(Count_num[i]&gt;0) printf(&quot;%d:%d\n&quot;,i,Count_num[i]); } return 0; } 倍增我们可以用倍增来在线求 LCA ，时间和空间复杂度分别是 O((n+q)logn) 和 O(nlogn) 。 对于这个算法，我们从最暴力的算法开始： 1.如果 a 和 b 深度不同，先把深度调浅，使他变得和浅的那个一样 2.现在已经保证了 a 和 b 的深度一样，所以我们只要把两个一起一步一步往上移动，直到他们到达同一个节点，也就是他们的最近公共祖先了。 板子1(zhouzhendong)//在线倍增 O((n+q)logn) #include&lt;bits/stdc++.h&gt; using namespace std; const int N=10000+5; vector &lt;int&gt; son[N]; int T,n,depth[N],fa[N][20],in[N],a,b; void dfs(int prev,int rt){ depth[rt]=depth[prev]+1; fa[rt][0]=prev; for (int i=1;i&lt;20;i++) fa[rt][i]=fa[fa[rt][i-1]][i-1]; for (int i=0;i&lt;son[rt].size();i++) dfs(rt,son[rt][i]); } int LCA(int x,int y){ if (depth[x]&lt;depth[y]) swap(x,y); for (int i=19;i&gt;=0;i--) if (depth[x]-(1&lt;&lt;i)&gt;=depth[y]) x=fa[x][i]; if (x==y) return x; for (int i=19;i&gt;=0;i--) if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; } int main(){ scanf(&quot;%d&quot;,&amp;T); while (T--){ scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) son[i].clear(); memset(in,0,sizeof in); for (int i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;a,&amp;b); son[a].push_back(b); in[b]++; } depth[0]=-1; int rt=0; for (int i=1;i&lt;=n&amp;&amp;rt==0;i++) if (in[i]==0) rt=i; dfs(0,rt); scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\n&quot;,LCA(a,b)); } return 0; } 板子2(Kuangbin)//倍增(Kuangbin) POJ1330 #include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1e4+5; const int h=20; struct Edge{int to,nxt;}edge[maxn*2]; int head[maxn],tot; void add_edge(int u,int v){edge[tot].to=v;edge[tot].nxt=head[u];head[u]=tot++;} void init(){tot=0;mem(head,-1);} int fa[maxn][h];//fa[i][j]表示结点i的第2^j个祖先 int depth[maxn];//深度数组 void bfs(int r){ queue&lt;int&gt; que;depth[r]=0; fa[r][0]=r;que.push(r); while(!que.empty()){ int tmp=que.front();que.pop(); for(int i=1;i&lt;h;i++) fa[tmp][i]=fa[fa[tmp][i-1]][i-1]; for(int i=head[tmp];i!=-1;i=edge[i].nxt){ int v=edge[i].to;if(v==fa[tmp][0]) continue; depth[v]=depth[tmp]+1;fa[v][0]=tmp; que.push(v); } } } int LCA(int u,int v){ if(depth[u]&gt;depth[v]) swap(u,v); int hu=depth[u],hv=depth[v]; int tu=u,tv=v; for(int det=hv-hu,i=0;det;det&gt;&gt;=1,i++) if(det&amp;1) tv=fa[tv][i]; if(tu==tv) return tu; for(int i=h-1;i&gt;=0;i--){ if(fa[tu][i]==fa[tv][i]) continue; tu=fa[tu][i];tv=fa[tv][i]; } return fa[tu][0]; } bool flag[maxn]; int main() { int T,n,u,v;scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;n);init();mem(flag,0); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v);add_edge(u,v);add_edge(v,u);flag[v]=1; } int root; for(int i=1;i&lt;=n;i++) if(!flag[i]){root=i;break;} bfs(root); scanf(&quot;%d%d&quot;,&amp;u,&amp;v); printf(&quot;%d\n&quot;,LCA(u,v)); } } RMQ(ST)一种O(nlogn)预处理+O(1)查询的在线算法(优秀) 一个子树中深度最浅的节点必定是该子树的树根。两个节点的 LCA 不仅是两个节点的最近公共祖先， 而且是囊括这两个节点的最小子树的根，即囊括这两个节点的最小子树中的深度最小的节点 如何得到这个子树根节点呢？ 现在，我们稍微修改一下 dfs 序，搞一个欧拉序。 欧拉序，就是每次从 father(x) 进入节点 x 或者从子节点回溯到 x 都要把 x 这个编号扔到一个数组的最后。 这样最终会得到一个长度约为 2n 的数列。（考虑每一个节点贡献为 2 ，分别是从其父亲进入该节点，和从该节点回到其父亲） 下图这棵树的一个欧拉序为 8,5,9,5,8,4,6,15,6,7,6,4,10,11,10,16,3,16,12,16,10,2,10,4,8,1,14,1,13,1,8 再注意到，一对点的 LCA 不仅是囊括这两个节点的最小子树中的深度最小的节点，还是连接这对点的简单路径上深度最小的点。 而且从离开 a 到进入 b 的这段欧拉序必然包括所有这对点之间的简单路径上的所有点，所以我们考虑求得这段欧拉序中所包含的节点中的 深度最小的点即其 LCA 。 从 a 到 b 的这段欧拉序会包含这棵子树中的其他节点，但是不会影响这个最浅点的求得，因为“一对点的 LCA 是囊括这两个节点的最小子树中的深度最小的节点”。 显然， a 到 b 这段欧拉序是个连续区间。 你可以用线段树维护，但是线段树太 low 了。 现在我们考虑通过预处理来 O(1) 获得这个最浅点。 于是我们要学习一个叫做 ST表 的东西来搞定这个。（和之前倍增中处理的 fa 数组差不多） 板子1(Vector from CSL)//RMQ O(nlogn+q) CSL #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e4+5; vector&lt;int&gt; edge[maxn],sp; int dep[maxn],dfn[maxn]; pair&lt;int,int&gt; dp[21][maxn&lt;&lt;1]; void init(int n){ for(int i=0;i&lt;=n;i++) edge[i].clear(); sp.clear(); } void dfs(int u,int fa){ dep[u]=dep[fa]+1; dfn[u]=sp.size();//欧拉序列 sp.push_back(u); for(auto&amp; v:edge[u]){ if(v==fa) continue; dfs(v,u);sp.push_back(u); } } void initrmq(){ int n=sp.size(); for(int i=0;i&lt;n;i++) dp[0][i]={dfn[sp[i]],sp[i]}; for(int i=1;(1&lt;&lt;i)&lt;=n;i++)//注意从1开始 ST表维护最小时间戳 for(int j=0;j+(1&lt;&lt;i)-1&lt;n;j++) dp[i][j]=min(dp[i-1][j],dp[i-1][j+(1&lt;&lt;(i-1))]); } int lca(int u,int v){ int l=dfn[u],r=dfn[v]; if(l&gt;r) swap(l,r); int k=31-__builtin_clz(r-l+1); return min(dp[k][l],dp[k][r-(1&lt;&lt;k)+1]).second; } int main() { /* */ } 验板子(HDU - 2586 Vector)//RMQ O(nlogn+q) CSL #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=5e4+5; struct Edge{ int to,w; Edge(int t,int W):to(t),w(W){} }; vector&lt;Edge&gt; edge[maxn]; vector&lt;int&gt; sp; int dep[maxn],dfn[maxn]; pair&lt;int,int&gt; dp[21][maxn&lt;&lt;1]; int dist[maxn]; void init(int n){ for(int i=0;i&lt;=n;i++) {edge[i].clear();dep[i]=dist[i]=0;} sp.clear(); } void dfs(int u,int fa){ dep[u]=dep[fa]+1; dfn[u]=sp.size(); sp.push_back(u); for(auto&amp; v:edge[u]){ if(v.to==fa) continue; dist[v.to]=dist[u]+v.w; dfs(v.to,u);sp.push_back(u); } } void initrmq(){ int n=sp.size(); for(int i=0;i&lt;n;i++) dp[0][i]={dfn[sp[i]],sp[i]}; for(int i=1;(1&lt;&lt;i)&lt;=n;i++) for(int j=0;j+(1&lt;&lt;i)-1&lt;n;j++) dp[i][j]=min(dp[i-1][j],dp[i-1][j+(1&lt;&lt;(i-1))]); } int lca(int u,int v){ int l=dfn[u],r=dfn[v]; if(l&gt;r) swap(l,r); int k=31-__builtin_clz(r-l+1); return min(dp[k][l],dp[k][r-(1&lt;&lt;k)+1]).second; } int main() { int T;scanf(&quot;%d&quot;,&amp;T); int u,v,w; while(T--){ int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(n); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); edge[u].push_back(Edge(v,w)); edge[v].push_back(Edge(u,w)); } dfs(1,0);initrmq(); while(m--){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v); printf(&quot;%d\n&quot;,dist[u]+dist[v]-2*dist[lca(u,v)]); } } } 验板子(HDU - 2586 前向星)#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=4e4+5; struct Edge{ int to,w,nxt; }edge[maxn&lt;&lt;1]; int tot,head[maxn]; vector&lt;int&gt; sp; int dep[maxn],dfn[maxn]; pair&lt;int,int&gt; dp[21][maxn&lt;&lt;1]; int dist[maxn]; void Addedge(int u,int v,int w){ edge[tot].to=v;edge[tot].w=w;edge[tot].nxt=head[u];head[u]=tot++; } void init(int n){ for(int i=0;i&lt;=n;i++) {head[i]=-1;dep[i]=dist[i]=0;} sp.clear();tot=0; } void dfs(int u,int fa){ dep[u]=dep[fa]+1; dfn[u]=sp.size(); sp.push_back(u); for(int i=head[u];i!=-1;i=edge[i].nxt){ int v=edge[i].to; if(v==fa) continue; dist[v]=dist[u]+edge[i].w; dfs(v,u);sp.push_back(u); } } void initrmq(){ int n=sp.size(); for(int i=0;i&lt;n;i++) dp[0][i]={dfn[sp[i]],sp[i]}; for(int i=1;(1&lt;&lt;i)&lt;=n;i++) for(int j=0;j+(1&lt;&lt;i)-1&lt;n;j++) dp[i][j]=min(dp[i-1][j],dp[i-1][j+(1&lt;&lt;(i-1))]); } int lca(int u,int v){ int l=dfn[u],r=dfn[v]; if(l&gt;r) swap(l,r); int k=31-__builtin_clz(r-l+1); return min(dp[k][l],dp[k][r-(1&lt;&lt;k)+1]).second; } int main() { int T;scanf(&quot;%d&quot;,&amp;T); int u,v,w; while(T--){ int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(n); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); Addedge(u,v,w);Addedge(v,u,w); } dfs(1,0);initrmq(); while(m--){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v); printf(&quot;%d\n&quot;,dist[u]+dist[v]-2*dist[lca(u,v)]); } } } 题目总结LCA题目总结 好像LCA的题目并不多，现在就做了10道左右，但是找不到别的了，在此做个小总结，将来有更好的题目会不断更新 解决LCA问题，一般用3种方法 1.朴素方法：两个点都一直沿路径往上走，直到有某一个节点被经过两次并且是第一次出现这样的点，那么这个就是LCA 此方法最好理解，但是用得不多，但不代表没作用，有些题目还是需要用到的 2.LCA转RMQ（在线算法）：一般是将LCA转为RMQ问题，用ST算法求解，当然求解RMQ问题有很多方法，不过ST比较常用而已，这样做能及时回答每一个询问 3.Tarjan算法（离线算法）：利用Tarjan算法，不过要先读入所有询问再一并回答，建议认真学习Tarjan算法本质 ******具体问题具体分析，但是可以使用Tarjan算法的时候推荐使用Tarjan算法，代码量少速度快，另外Tarjan算法容易产生变形，值得深究************* 待补题poj 1986 Distance Queries 模板题，直接求LCA hdu 2874 Connections between cities 模板题，不过不是树是森林，所以某些点不存在LCA，要做判断 zoj 3195 Design the city 任然算是模板题，上面的题要求两点间的最短距离，这里要求3点间的最短距离，其实就是两两之间求一次LCA并计算出距离，然后相加除以2即可 hdu 3078 Network LCA + 修改点权值 + 排序：每个点有初始的权值，一边查询一边伴随着修改某些点的权值，查询是从a到b路径中第k大的权值是多少。不需要太多的技巧，修改操作就直接修改，查询操作先求LCA，然后从a走到b保存下所有的权值，排序，然后直接输出即可 poj 2763 Housewife Wind LCA + 修改边权：一边查询两点间的距离，一边修改某些边权。对于修改了某些边的边权，就要从此开始遍历下面的子孙后代更改他们的dir值（点到根的距离）。也不需要太多技巧，直接按题意实现即可，不过时间比较糟糕，用线段树或树状数组可以对修改操作进行优化，时间提升很多 poj 3694 Network 连通分量 + LCA ： 先缩点，再求LCA，并且不断更新，这题用了朴素方法来找LCA，并且在路径上做了一些操作 poj 3417 Network LCA + Tree DP : 在运行Tarjan处理完所有的LCA询问后，进行一次树DP，树DP不难，但是要想到用树DP并和这题结合还是有点难度 poj 3728 The merchant LCA + 并查集的变形，优化：好题，难题，思维和代码实现都很有难度，需要很好地理解Tarjan算法中并查集的本质然后灵活变形，需要记录很多信息（有点dp的感觉） hdu 3830 Checkers LCA + 二分：好题，有一定思维难度。先建立出二叉树模型，然后将要查询的两个点调整到深度一致，然后二分LCA所在的深度，然后检验]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)为什么printf()用%f输出double型，而scanf却用%lf]]></title>
    <url>%2F2019%2F07%2F16%2Fprintf%2F</url>
    <content type="text"><![CDATA[问：有人告诉我不能在printf中使用%lf。为什么printf()用%f输出double型，而scanf却用%lf呢？ 答：printf的%f说明符的确既可以输出float型又可以输出double型。 根据”默认参数提升”规则（在printf这样的函数的可变参数列表中 ，不论作用域内有没有原型，都适用这一规则）float型会被提升为double型。因此printf()只会看到双精度数。参见问题15.2。 对于scanf，情况就完全不同了，它接受指针，这里没有类似的类型提升。（通过指针）向float存储和向double存储大不一样，因此，scanf区别%f和%lf。 下表列出了printf和scanf对于各种格式说明符可以接受的参数类型。 （严格地讲，%lf在printf下是未定义的，但是很多系统可能会接受它。要确保可移植性，就要坚持使用%f。）]]></content>
  </entry>
  <entry>
    <title><![CDATA[最小树形图]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最小树形图简单来说，最小树形图就是有向图的最小生成树 给出一个带权有向图，从中指定一个特殊的节点root，求一棵以root为根的有向生成树，且使得T中所有边权之和最小 朱刘算法 O(VE) 网上讲解无证明，了解过程 - 会套模版 - 分清有定根与无定根 - 重在建图 在选出入边集后，若有向图中不存在有向环，则说明该图是最小树形图 1）选入边集，找到除 root 点之外，每一个点的所有入边中权值最小的权值，用数组 in[] 记录这个最小权值，用 pre[] 记录到达该点的前驱。 2）判断图中是否存在独立点，若存在除 root 外的孤立点，则说明 root 无法到达该点，说明最小树形图不存在。 3）在图中寻找环，对环进行缩点并用数组 id[] 记录节点所属环的编号。 4）更新其他点到环上的距离。 5）重复 3、4 直到 图中不存在环 为止，此时图是最小树形图。 套公式记得下标统一。 模版（NB网友）#include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=4e4+5; const int INF=0x3f3f3f3f; struct Edge{ int x,y,w; }edge[maxm]; int vis[maxn]; int id[maxn];//结点所属环编号 int in[maxn],pre[maxn];//in[]为最小入边权,pre[]为其对应的起点 int zhuLiu(int root,int n,int m){//root结点、点数、边数 int res=0;//最小树形图总权值 while(true){ for(int i=0;i&lt;n;i++)//初始化为无穷大 in[i]=INF; //寻找每个点的最小入边 for(int i=0;i&lt;m;i++){//遍历每条边 int x=edge[i].x; int y=edge[i].y; if(edge[i].w&lt;in[y] &amp;&amp; x!=y){//更新最小入边 pre[y]=x;//记录前驱 in[y]=edge[i].w;//更新 } } //判断是否存在最小树形图 for(int i=0;i&lt;n;i++){ if(i==root) continue; if(in[i]==INF)//除根节点外的点存在孤立点 return -1; } //寻找所有的环 int cnt=0;//记录环数 in[root]=0; memset(id,-1,sizeof(id)); memset(vis,-1,sizeof(vis)); for(int i=0;i&lt;n;i++){//标记每个环 res+=in[i];//记录权值 int y=i; while(vis[y]!=i&amp;&amp;id[y]==-1&amp;&amp;y!=root){//寻找图中有向环 //三种情况会终止：找到出现同样标记的点、结点已属其他环、遍历到根 vis[y]=i;//标记 y=pre[y];//向上找 } if(y!=root&amp;&amp;id[y]==-1){//没有遍历到根或没有找到结点属于其他环,说明找到有向环 for(int x=pre[y];x!=y;x=pre[x])//标记结点x为第几个环 id[x]=cnt;//记录结点所属环号 id[y]=cnt++;//记录结点所属环号并累加 } } if(cnt==0)//无环 break; for(int i=0;i&lt;n;i++)//可能存在独立点 if(id[i]==-1)//环数累加 id[i]=cnt++; //建立新图,缩点重新标记 for(int i=0;i&lt;m;i++){ int x=edge[i].x; int y=edge[i].y; edge[i].x=id[x]; edge[i].y=id[y]; if(id[x]!=id[y])//两点不在同一环内,更新边权值 edge[i].w-=in[y];//x到y的距离为边权-in[y] } n=cnt;//以环数为下次操作的点数,继续上述操作,直到无环 root=id[root]; } return res; } int main(){ int n,m;//n个点m条有向边 scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++){//建图 scanf(&quot;%d%d%d&quot;,&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].w); if(edge[i].x==edge[i].y)//除去自环,即点到自身距离为INF edge[i].w=INF; } int res=zhuLiu(0,n,m); if(res==-1) printf(&quot;No\n&quot;); else printf(&quot;%d\n&quot;,res); return 0; } 模版（邝斌）#include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=4e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; }edge[maxm]; int pre[maxn],id[maxn],vis[maxn],in[maxn]; int zhuliu(int root,int n,int m,Edge edge[]){ int res=0,u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++) if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u; in[edge[i].v]=edge[i].cost; } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int tn=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=tn; id[v]=tn++; } } if(tn==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=tn++; for(int i=0;i&lt;m;){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i++].cost-=in[v]; else swap(edge[i],edge[--m]); } n=tn;root=id[root]; } return res; } int g[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m,ca=0,T;cin&gt;&gt;T; while(T--){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) g[i][j]=INF; int u,v,cost; while(m--){ int u,v,cost;cin&gt;&gt;u&gt;&gt;v&gt;&gt;cost; if(u==v) continue; g[u][v]=min(g[u][v],cost); } int L=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(g[i][j]&lt;INF){ edge[L].u=i;edge[L].v=j;edge[L++].cost=g[i][j]; } int ans=zhuliu(0,n,L,edge); cout&lt;&lt;&quot;Case #&quot;&lt;&lt;ca++&lt;&lt;&quot;: &quot;; if(ans==-1) cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; } } 题目有定根//POJ-3164 有定根的最小树形图 题意：给出 n 个点 m 条有向边，首先给出从 1 号点到 n 号点的笛卡尔坐标，然后再给出 m 条边，1 号点始终为根节点，求最小树形图 思路：朱刘算法第一题。。。边的权值用 double 型，求一下距离直接建图后，然后套模版。。。注意模版需要改为 double 型 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=105; const int maxm=1e4+5; const double INF=0x3f3f3f3f; struct Node{ double x,y; }node[maxn]; struct Edge{ int u,v;double cost; }edge[maxm]; double cal(Node a,Node b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } int pre[maxn],id[maxn],vis[maxn]; double in[maxn]; double zhuliu(int root,int n,int m){ double res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ u=edge[i].u;v=edge[i].v; if(u!=v&amp;&amp;edge[i].cost&lt;in[v]){ pre[v]=u;in[v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int main() { int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;(n+m)){ for(int i=0;i&lt;n;i++) scanf(&quot;%lf%lf&quot;,&amp;node[i].x,&amp;node[i].y); for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v); edge[i].u--;edge[i].v--; if(edge[i].u!=edge[i].v) edge[i].cost=cal(node[edge[i].u],node[edge[i].v]); else edge[i].cost=INF; } double ans=zhuliu(0,n,m); if(ans==-1) printf(&quot;poor snoopy\n&quot;); else printf(&quot;%.2f\n&quot;,ans); } } 无定根//HDU-2121 图不需要自己额外建(即题目给好了N个点,M条边),只是没有给定根 题意：n 个点 m 条有向边，现要在 n 个点中选一个点作为首都，要求首都与其他点是可达的， 给出 m 条道路修建要花费的价格，求最小花费并给出首都的序号，点的标号从 0 开始。 无根最小树形图，构造根节点0，从0到各点建立权值大于整张图权值和的边（此处取sum+1）， 这样一来0为根节点求最小树形图，如果不存在最小树形图或者所得最小树形图的权值和不小于2*(sum+1) 说明原图的最小树形图不存在，至于如何求编号最小的根节点，这个可以在求最短弧集合的时候得到， 即如果一条边被加入最短弧集合且这条边的起点是0，那么这条边的终点就是所求最小树形图的根 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; }edge[maxm+maxn]; int pos;//实际起点 int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; if(edge[i].u==root) pos=i; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; //else swap(edge[i],edge[--m]); } n=cnt;root=id[root]; } return res; } int main() { int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ int sum=0; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].cost); edge[i].u++;edge[i].v++;sum+=edge[i].cost; } sum++;//去掉就WA for(int i=0;i&lt;n;i++){ edge[i+m].u=0;edge[i+m].v=i+1;edge[i+m].cost=sum; } int ans=zhuliu(0,n+1,m+n); ////若差值大于sum说明结点0的出度不止为1,即原图不是连通图 if(ans==-1||ans-sum&gt;=sum) printf(&quot;impossible\n&quot;); else printf(&quot;%d %d\n&quot;,ans-sum,pos-m); printf(&quot;\n&quot;); } } 建图+无定根//HDU-4009 图需要自己建,同时也没有给定根 题意：n户人家，每家对应一个三维坐标(x, y, z)，z代表这家的海拔高度。 每家可以通过挖井获得水，也可以通过从别的人家引一条水渠获得水，其花费如下： 1.挖井花费z*X； 2.从不比自己低的人家引水渠花费Y*两家之间的曼哈顿距离； 3.从比自己低的人家引水渠与2中的相同，但需要多花Z来购买一个水泵 此外有的人家不允许一些人家从他们家引水渠，求使得所有人家都能获得水的最少花费 思路：对应这个题,其初始点就可以设为这n个点,然后权值为在这个点建井的花费,而对于它给的其他边,我们直接在对应的两个点上建边即可,然后跑一下朱刘算法,就可得出答案 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Node{ int x,y,z; }node[maxn]; struct Edge{ int u,v,cost; }edge[maxm+maxn*maxn]; int dis(Node a,Node b){ return abs(a.x-b.x)+abs(a.y-b.y)+abs(a.z-b.z); } int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int main() { int n,X,Y,Z; while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;X,&amp;Y,&amp;Z)&amp;&amp;(n+X+Y+Z)){ for(int i=0;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;node[i].x,&amp;node[i].y,&amp;node[i].z); } int cnt=0,a,b; for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a); while(a--){ scanf(&quot;%d&quot;,&amp;b); edge[cnt].cost=dis(node[i],node[--b])*Y; if(node[b].z&gt;node[i].z) edge[cnt].cost+=Z; edge[cnt].u=i;edge[cnt++].v=b; } } for(int i=0;i&lt;n;i++){ edge[cnt].u=n;edge[cnt].v=i;edge[cnt++].cost=node[i].z*X; } printf(&quot;%d\n&quot;,zhuliu(n,n+1,cnt)); } } 建图+无定根//HYSBZ - 4349 无定根 题意：攻打每一个人的堡垒需要一个代价,而且必须攻打若干次,各个堡垒之间会相互提供援助, 小C只要攻打某个堡垒一次之后，某些堡垒就只需要花更小的代价攻击了,求消灭所有堡垒的最小代价。 思路: 如题目，最小树形图裸题，建立一个虚点，连向所有点，然后跑出每个点都打一次的最小代价。 然后再来以每次都是最小代价的打法，对每个点再打times[i]−1次。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const double INF=0x3f3f3f3f; struct Edge{ int u,v; double cost; Edge(int U=0,int V=0,double C=0):u(U),v(V),cost(C){} }edge[maxn*maxn+maxn]; int pre[maxn],id[maxn],vis[maxn]; double in[maxn]; double zhuliu(int root,int n,int m){ double res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int times[maxn];//times[i] 记录 i 点需要打几次 double cost[maxn];//cost[i] 记录打 i 点的花费 int main() { int n,m; while(~scanf(&quot;%d&quot;,&amp;n)){ int cnt=0; for(int i=1;i&lt;=n;i++){ scanf(&quot;%lf%d&quot;,&amp;cost[i],&amp;times[i]); edge[cnt++]=Edge(0,i,cost[i]);//建 0-&gt;i 初始花费的边(设0为虚根) } scanf(&quot;%d&quot;,&amp;m); int u,v;double c; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%lf&quot;,&amp;u,&amp;v,&amp;c); edge[cnt++]=Edge(u,v,c);//建 u-&gt;v 较小花费的边 cost[v]=min(cost[v],c); } double ans=0; for(int i=1;i&lt;=n;i++) ans+=(times[i]-1)*cost[i];//需要打times[i]次，所以需要加上(time[i]-1)次 * 较小花费 printf(&quot;%.2f\n&quot;,zhuliu(0,n+1,cnt)+ans);//0-&gt;根 n+1个点 cnt条边 } } /* 3 10 1 1.8 1 2.5 2 2 1 3 2 3 2 1.5 3 10 1 9 1 8 1 0 */ 建图+无定根+多点(一个课程好多点)题意：给你n门课的最高等级及m条升级方法，开始时你每门课的等级都在等级0，升级方法的5个参数代表，你要上这门课，你的课程c的等级至少要到达L1i， 你才能达到课程d的等级L2i，同时花费金钱moi，现在问你，每门课的等级都要到达最高等级所需要花费的最小费用是多少，如果不能都达到最高级别，输出-1 思路：图论的题，精华都是在构图，这道题很明显是一道有向的最小生成树，也就是最小树形图，那么问题来了，因为条件中是至少到达，这样如果中间断开， 按正常的建边就不能使得这棵树完整，那么精妙的方法就来了，外面把所有的边都往反向建一次，及课程a的等级i+1连向i，这就可以保证， 如果我已经达到了等级i+1，就不用再对i作花费，同时，等级i如果能连向终点，也可以直接在树的结构中体现出来。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; Edge(int U=0,int V=0,int C=0):u(U),v(V),cost(C){} }edge[maxn*maxn+maxn]; int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int a[maxn],sum[maxn]; int main() { int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n+m)){ sum[0]=0; for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);a[i]++;//a[i]表示一个课程的a[i]++(0~a[i])个等级，共a[i]++个点 sum[i+1]=sum[i]+a[i];//sum[i]~sum[i+1]-1记录i课程的a[i]个点的序号 } int cnt=0; for(int i=0;i&lt;n;i++){ for(int j=sum[i+1]-1;j&gt;sum[i];j--){ edge[cnt++]=Edge(j,j-1,0); }//将所有等级作为一个节点，对于等级i,可以建一条对等级i-1的边，边权为0 edge[cnt++]=Edge(sum[n],sum[i],0); }//其中sum[n]为虚拟的跟，指向所有的课程的level0的点 int c,d,l1,l2,mo; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%d%d%d&quot;,&amp;c,&amp;l1,&amp;d,&amp;l2,&amp;mo); edge[cnt++]=Edge(sum[c-1]+l1,sum[d-1]+l2,mo); }//建立c课程的level0+l1 到 d课程的level0+l1 之间的边 权值为价格 printf(&quot;%d\n&quot;,zhuliu(sum[n],sum[n]+1,cnt)); } } 代补题：UVA - 11865 ----&gt;二分加最小树形图 CodeForces - 240E -------&gt;最小树形图+路径输出 (自己独立思考出这个题就应该能完全掌握最小树形图)]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错排公式]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[第一篇博客，写个错排公式 实践一下md语法 dp[i] = (i-1) * (dp[i-1] + dp[i-2]) 问题：把n封信装进n个信封，有多少种方法？ 公式很easy，写在上面了，现在理解一下： 假设现在已经有i-1封已经完成错排，有dp[i-1]种方式，下面处理第i封从前i-1封中取出一封(k位置)换一下，有i-1个选择，取出的信怎么处理呢？(1)放在原来的第i个位置，剩下i-2封错排之后有dp[i-2]种方式，这很容易理解。(2)不放在第i个位置,同时也不能放在k位置，只能再和剩下的i-2封换了，仔细想一下，这不就是原来的问题嘛！只不过数据规模减少了1，所以有dp[i-2]种方式。综上：dp[i] = (i-1) * (dp[i-1] + dp[i-2])&emsp;&emsp;&emsp;dp[1]=0;dp[2]=1;递归搞一搞，得结果。 就酱，第一篇结束。。。排版很low 内容很low 我也很low哎，几个月前就开了博客，一直没写过，感觉还是把接触到的有意义东西记录一下吧！毕竟记性不好，现在会的东西两个月之后也忘得差不多了。应该会写点ACM的东西吧，再传点其他方面的笔记，嗯嗯，希望自己真的能做到,结束自闭，努力学习。]]></content>
      <categories>
        <category>递推</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[(转)为什么printf不能用%lf输出double型，而用%f？]]></title>
    <url>%2F2019%2F07%2F16%2Fprintf%2F</url>
    <content type="text"><![CDATA[问：有人告诉我不能在printf中使用%lf。为什么printf()用%f输出double型，而scanf却用%lf呢？ 答：printf的%f说明符的确既可以输出float型又可以输出double型。 根据”默认参数提升”规则（在printf这样的函数的可变参数列表中 ，不论作用域内有没有原型，都适用这一规则）float型会被提升为double型。因此printf()只会看到双精度数。参见问题15.2。 对于scanf，情况就完全不同了，它接受指针，这里没有类似的类型提升。（通过指针）向float存储和向double存储大不一样，因此，scanf区别%f和%lf。 下表列出了printf和scanf对于各种格式说明符可以接受的参数类型。 （严格地讲，%lf在printf下是未定义的，但是很多系统可能会接受它。要确保可移植性，就要坚持使用%f。）]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小树形图]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最小树形图简单来说，最小树形图就是有向图的最小生成树 给出一个带权有向图，从中指定一个特殊的节点root，求一棵以root为根的有向生成树，且使得T中所有边权之和最小 朱刘算法 O(VE) 网上讲解无证明，了解过程 - 会套模版 - 分清有定根与无定根 - 重在建图 在选出入边集后，若有向图中不存在有向环，则说明该图是最小树形图 1）选入边集，找到除 root 点之外，每一个点的所有入边中权值最小的权值，用数组 in[] 记录这个最小权值，用 pre[] 记录到达该点的前驱。 2）判断图中是否存在独立点，若存在除 root 外的孤立点，则说明 root 无法到达该点，说明最小树形图不存在。 3）在图中寻找环，对环进行缩点并用数组 id[] 记录节点所属环的编号。 4）更新其他点到环上的距离。 5）重复 3、4 直到 图中不存在环 为止，此时图是最小树形图。 模版（NB网友）#include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=4e4+5; const int INF=0x3f3f3f3f; struct Edge{ int x,y,w; }edge[maxm]; int vis[maxn]; int id[maxn];//结点所属环编号 int in[maxn],pre[maxn];//in[]为最小入边权,pre[]为其对应的起点 int zhuLiu(int root,int n,int m){//root结点、点数、边数 int res=0;//最小树形图总权值 while(true){ for(int i=0;i&lt;n;i++)//初始化为无穷大 in[i]=INF; //寻找每个点的最小入边 for(int i=0;i&lt;m;i++){//遍历每条边 int x=edge[i].x; int y=edge[i].y; if(edge[i].w&lt;in[y] &amp;&amp; x!=y){//更新最小入边 pre[y]=x;//记录前驱 in[y]=edge[i].w;//更新 } } //判断是否存在最小树形图 for(int i=0;i&lt;n;i++){ if(i==root) continue; if(in[i]==INF)//除根节点外的点存在孤立点 return -1; } //寻找所有的环 int cnt=0;//记录环数 in[root]=0; memset(id,-1,sizeof(id)); memset(vis,-1,sizeof(vis)); for(int i=0;i&lt;n;i++){//标记每个环 res+=in[i];//记录权值 int y=i; while(vis[y]!=i&amp;&amp;id[y]==-1&amp;&amp;y!=root){//寻找图中有向环 //三种情况会终止：找到出现同样标记的点、结点已属其他环、遍历到根 vis[y]=i;//标记 y=pre[y];//向上找 } if(y!=root&amp;&amp;id[y]==-1){//没有遍历到根或没有找到结点属于其他环,说明找到有向环 for(int x=pre[y];x!=y;x=pre[x])//标记结点x为第几个环 id[x]=cnt;//记录结点所属环号 id[y]=cnt++;//记录结点所属环号并累加 } } if(cnt==0)//无环 break; for(int i=0;i&lt;n;i++)//可能存在独立点 if(id[i]==-1)//环数累加 id[i]=cnt++; //建立新图,缩点重新标记 for(int i=0;i&lt;m;i++){ int x=edge[i].x; int y=edge[i].y; edge[i].x=id[x]; edge[i].y=id[y]; if(id[x]!=id[y])//两点不在同一环内,更新边权值 edge[i].w-=in[y];//x到y的距离为边权-in[y] } V=cnt;//以环数为下次操作的点数,继续上述操作,直到无环 root=id[root]; } return res; } int main(){ int n,m;//n个点m条有向边 scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++){//建图 scanf(&quot;%d%d%d&quot;,&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].w); if(edge[i].x==edge[i].y)//除去自环,即点到自身距离为INF edge[i].w=INF; } int res=zhuLiu(0,n,m); if(res==-1) printf(&quot;No\n&quot;); else printf(&quot;%d\n&quot;,res); return 0; } 模版（邝斌）#include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=4e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; }edge[maxm]; int pre[maxn],id[maxn],vis[maxn],in[maxn]; int zhuliu(int root,int n,int m,Edge edge[]){ int res=0,u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++) if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u; in[edge[i].v]=edge[i].cost; } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int tn=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=tn; id[v]=tn++; } } if(tn==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=tn++; for(int i=0;i&lt;m;){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i++].cost-=in[v]; else swap(edge[i],edge[--m]); } n=tn;root=id[root]; } return res; } int g[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m,ca=0,T;cin&gt;&gt;T; while(T--){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) g[i][j]=INF; int u,v,cost; while(m--){ int u,v,cost;cin&gt;&gt;u&gt;&gt;v&gt;&gt;cost; if(u==v) continue; g[u][v]=min(g[u][v],cost); } int L=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(g[i][j]&lt;INF){ edge[L].u=i;edge[L].v=j;edge[L++].cost=g[i][j]; } int ans=zhuliu(0,n,L,edge); cout&lt;&lt;&quot;Case #&quot;&lt;&lt;ca++&lt;&lt;&quot;: &quot;; if(ans==-1) cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; } } 题目有定根//POJ-3164 有定根的最小树形图 题意：给出 n 个点 m 条有向边，首先给出从 1 号点到 n 号点的笛卡尔坐标，然后再给出 m 条边，1 号点始终为根节点，求最小树形图 思路：朱刘算法第一题。。。边的权值用 double 型，求一下距离直接建图后，然后套模版。。。注意模版需要改为 double 型 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=105; const int maxm=1e4+5; const double INF=0x3f3f3f3f; struct Node{ double x,y; }node[maxn]; struct Edge{ int u,v;double cost; }edge[maxm]; double cal(Node a,Node b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } int pre[maxn],id[maxn],vis[maxn]; double in[maxn]; double zhuliu(int root,int n,int m){ double res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ u=edge[i].u;v=edge[i].v; if(u!=v&amp;&amp;edge[i].cost&lt;in[v]){ pre[v]=u;in[v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int main() { int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;(n+m)){ for(int i=0;i&lt;n;i++) scanf(&quot;%lf%lf&quot;,&amp;node[i].x,&amp;node[i].y); for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v); edge[i].u--;edge[i].v--; if(edge[i].u!=edge[i].v) edge[i].cost=cal(node[edge[i].u],node[edge[i].v]); else edge[i].cost=INF; } double ans=zhuliu(0,n,m); if(ans==-1) printf(&quot;poor snoopy\n&quot;); else printf(&quot;%.2f\n&quot;,ans); } } 无定根//HDU-2121 图不需要自己额外建(即题目给好了N个点,M条边),只是没有给定根 题意：n 个点 m 条有向边，现要在 n 个点中选一个点作为首都，要求首都与其他点是可达的， 给出 m 条道路修建要花费的价格，求最小花费并给出首都的序号，点的标号从 0 开始。 无根最小树形图，构造根节点0，从0到各点建立权值大于整张图权值和的边（此处取sum+1）， 这样一来0为根节点求最小树形图，如果不存在最小树形图或者所得最小树形图的权值和不小于2*(sum+1) 说明原图的最小树形图不存在，至于如何求编号最小的根节点，这个可以在求最短弧集合的时候得到， 即如果一条边被加入最短弧集合且这条边的起点是0，那么这条边的终点就是所求最小树形图的根 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; }edge[maxm+maxn]; int pos;//实际起点 int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; if(edge[i].u==root) pos=i; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; //else swap(edge[i],edge[--m]); } n=cnt;root=id[root]; } return res; } int main() { int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ int sum=0; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].cost); edge[i].u++;edge[i].v++;sum+=edge[i].cost; } sum++;//去掉就WA for(int i=0;i&lt;n;i++){ edge[i+m].u=0;edge[i+m].v=i+1;edge[i+m].cost=sum; } int ans=zhuliu(0,n+1,m+n); ////若差值大于sum说明结点0的出度不止为1,即原图不是连通图 if(ans==-1||ans-sum&gt;=sum) printf(&quot;impossible\n&quot;); else printf(&quot;%d %d\n&quot;,ans-sum,pos-m); printf(&quot;\n&quot;); } } 建图+无定根//HDU-4009 图需要自己建,同时也没有给定根 题意：n户人家，每家对应一个三维坐标(x, y, z)，z代表这家的海拔高度。 每家可以通过挖井获得水，也可以通过从别的人家引一条水渠获得水，其花费如下： 1.挖井花费z*X； 2.从不比自己低的人家引水渠花费Y*两家之间的曼哈顿距离； 3.从比自己低的人家引水渠与2中的相同，但需要多花Z来购买一个水泵 此外有的人家不允许一些人家从他们家引水渠，求使得所有人家都能获得水的最少花费 思路：对应这个题,其初始点就可以设为这n个点,然后权值为在这个点建井的花费,而对于它给的其他边,我们直接在对应的两个点上建边即可,然后跑一下朱刘算法,就可得出答案 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Node{ int x,y,z; }node[maxn]; struct Edge{ int u,v,cost; }edge[maxm+maxn*maxn]; int dis(Node a,Node b){ return abs(a.x-b.x)+abs(a.y-b.y)+abs(a.z-b.z); } int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int main() { int n,X,Y,Z; while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;X,&amp;Y,&amp;Z)&amp;&amp;(n+X+Y+Z)){ for(int i=0;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;node[i].x,&amp;node[i].y,&amp;node[i].z); } int cnt=0,a,b; for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a); while(a--){ scanf(&quot;%d&quot;,&amp;b); edge[cnt].cost=dis(node[i],node[--b])*Y; if(node[b].z&gt;node[i].z) edge[cnt].cost+=Z; edge[cnt].u=i;edge[cnt++].v=b; } } for(int i=0;i&lt;n;i++){ edge[cnt].u=n;edge[cnt].v=i;edge[cnt++].cost=node[i].z*X; } printf(&quot;%d\n&quot;,zhuliu(n,n+1,cnt)); } } 建图+无定根//HYSBZ - 4349 无定根 题意：攻打每一个人的堡垒需要一个代价,而且必须攻打若干次,各个堡垒之间会相互提供援助, 小C只要攻打某个堡垒一次之后，某些堡垒就只需要花更小的代价攻击了,求消灭所有堡垒的最小代价。 思路: 如题目，最小树形图裸题，建立一个虚点，连向所有点，然后跑出每个点都打一次的最小代价。 然后再来以每次都是最小代价的打法，对每个点再打times[i]−1次。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const double INF=0x3f3f3f3f; struct Edge{ int u,v; double cost; Edge(int U=0,int V=0,double C=0):u(U),v(V),cost(C){} }edge[maxn*maxn+maxn]; int pre[maxn],id[maxn],vis[maxn]; double in[maxn]; double zhuliu(int root,int n,int m){ double res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int times[maxn];//times[i] 记录 i 点需要打几次 double cost[maxn];//cost[i] 记录打 i 点的花费 int main() { int n,m; while(~scanf(&quot;%d&quot;,&amp;n)){ int cnt=0; for(int i=1;i&lt;=n;i++){ scanf(&quot;%lf%d&quot;,&amp;cost[i],&amp;times[i]); edge[cnt++]=Edge(0,i,cost[i]);//建 0-&gt;i 初始花费的边(设0为虚根) } scanf(&quot;%d&quot;,&amp;m); int u,v;double c; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%lf&quot;,&amp;u,&amp;v,&amp;c); edge[cnt++]=Edge(u,v,c);//建 u-&gt;v 较小花费的边 cost[v]=min(cost[v],c); } double ans=0; for(int i=1;i&lt;=n;i++) ans+=(times[i]-1)*cost[i];//需要打times[i]次，所以需要加上(time[i]-1)次 * 较小花费 printf(&quot;%.2f\n&quot;,zhuliu(0,n+1,cnt)+ans);//0-&gt;根 n+1个点 cnt条边 } } /* 3 10 1 1.8 1 2.5 2 2 1 3 2 3 2 1.5 3 10 1 9 1 8 1 0 */ 建图+无定根+多点(一个课程好多点)题意：给你n门课的最高等级及m条升级方法，开始时你每门课的等级都在等级0，升级方法的5个参数代表，你要上这门课，你的课程c的等级至少要到达L1i， 你才能达到课程d的等级L2i，同时花费金钱moi，现在问你，每门课的等级都要到达最高等级所需要花费的最小费用是多少，如果不能都达到最高级别，输出-1 思路：图论的题，精华都是在构图，这道题很明显是一道有向的最小生成树，也就是最小树形图，那么问题来了，因为条件中是至少到达，这样如果中间断开， 按正常的建边就不能使得这棵树完整，那么精妙的方法就来了，外面把所有的边都往反向建一次，及课程a的等级i+1连向i，这就可以保证， 如果我已经达到了等级i+1，就不用再对i作花费，同时，等级i如果能连向终点，也可以直接在树的结构中体现出来。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; Edge(int U=0,int V=0,int C=0):u(U),v(V),cost(C){} }edge[maxn*maxn+maxn]; int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int a[maxn],sum[maxn]; int main() { int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;(n+m)){ sum[0]=0; for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a[i]);a[i]++;//a[i]表示一个课程的a[i]++(0~a[i])个等级，共a[i]++个点 sum[i+1]=sum[i]+a[i];//sum[i]~sum[i+1]-1记录i课程的a[i]个点的序号 } int cnt=0; for(int i=0;i&lt;n;i++){ for(int j=sum[i+1]-1;j&gt;sum[i];j--){ edge[cnt++]=Edge(j,j-1,0); }//将所有等级作为一个节点，对于等级i,可以建一条对等级i-1的边，边权为0 edge[cnt++]=Edge(sum[n],sum[i],0); }//其中sum[n]为虚拟的跟，指向所有的课程的level0的点 int c,d,l1,l2,mo; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%d%d%d&quot;,&amp;c,&amp;l1,&amp;d,&amp;l2,&amp;mo); edge[cnt++]=Edge(sum[c-1]+l1,sum[d-1]+l2,mo); }//建立c课程的level0+l1 到 d课程的level0+l1 之间的边 权值为价格 printf(&quot;%d\n&quot;,zhuliu(sum[n],sum[n]+1,cnt)); } } 代补题：UVA - 11865 ----&gt;二分加最小树形图 CodeForces - 240E -------&gt;最小树形图+路径输出 (自己独立思考出这个题就应该能完全掌握最小树形图)]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错排公式]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[第一篇博客，写个错排公式 实践一下md语法 dp[i] = (i-1) * (dp[i-1] + dp[i-2]) 问题：把n封信装进n个信封，有多少种方法？ 公式很easy，写在上面了，现在理解一下： 假设现在已经有i-1封已经完成错排，有dp[i-1]种方式，下面处理第i封从前i-1封中取出一封(k位置)换一下，有i-1个选择，取出的信怎么处理呢？(1)放在原来的第i个位置，剩下i-2封错排之后有dp[i-2]种方式，这很容易理解。(2)不放在第i个位置,同时也不能放在k位置，只能再和剩下的i-2封换了，仔细想一下，这不就是原来的问题嘛！只不过数据规模减少了1，所以有dp[i-2]种方式。综上：dp[i] = (i-1) * (dp[i-1] + dp[i-2])&emsp;&emsp;&emsp;dp[1]=0;dp[2]=1;递归搞一搞，得结果。 就酱，第一篇结束。。。排版很low 内容很low 我也很low哎，几个月前就开了博客，一直没写过，感觉还是把接触到的有意义东西记录一下吧！毕竟记性不好，现在会的东西两个月之后也忘得差不多了。应该会写点ACM的东西吧，再传点其他方面的笔记，嗯嗯，希望自己真的能做到,结束自闭，努力学习。]]></content>
      <categories>
        <category>递推</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 问：有人告诉我不能在printf中使用%lf。为什么printf()用%f输出double型，而scanf却用%lf呢？ 答：printf的%f说明符的确既可以输出float型又可以输出double型。 根据”默认参数提升”规则（在printf这样的函数的可变参数列表中 ，不论作用域内有没有原型，都适用这一规则）float型会被提升为double型。因此printf()只会看到双精度数。参见问题15.2。 对于scanf，情况就完全不同了，它接受指针，这里没有类似的类型提升。（通过指针）向float存储和向double存储大不一样，因此，scanf区别%f和%lf。 下表列出了printf和scanf对于各种格式说明符可以接受的参数类型。 （严格地讲，%lf在printf下是未定义的，但是很多系统可能会接受它。要确保可移植性，就要坚持使用%f。）]]></content>
  </entry>
</search>

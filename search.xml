<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最小树形图]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最小树形图简单来说，最小树形图就是有向图的最小生成树 给出一个带权有向图，从中指定一个特殊的节点root，求一棵以root为根的有向生成树，且使得T中所有边权之和最小 朱刘算法 网上讲解无证明，了解过程 - 会套模版 - 分清有定根与无定根 - 重在建图 在选出入边集后，若有向图中不存在有向环，则说明该图是最小树形图 1）选入边集，找到除 root 点之外，每一个点的所有入边中权值最小的权值，用数组 in[] 记录这个最小权值，用 pre[] 记录到达该点的前驱。 2）判断图中是否存在独立点，若存在除 root 外的孤立点，则说明 root 无法到达该点，说明最小树形图不存在。 3）在图中寻找环，对环进行缩点并用数组 id[] 记录节点所属环的编号。 4）更新其他点到环上的距离。 5）重复 3、4 直到 图中不存在环 为止，此时图是最小树形图。 模版（NB网友）#include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=4e4+5; const int INF=0x3f3f3f3f; struct Edge{ int x,y,w; }edge[maxm]; int vis[maxn]; int id[maxn];//结点所属环编号 int in[maxn],pre[maxn];//in[]为最小入边权,pre[]为其对应的起点 int zhuLiu(int root,int n,int m){//root结点、点数、边数 int res=0;//最小树形图总权值 while(true){ for(int i=0;i&lt;n;i++)//初始化为无穷大 in[i]=INF; //寻找每个点的最小入边 for(int i=0;i&lt;m;i++){//遍历每条边 int x=edge[i].x; int y=edge[i].y; if(edge[i].w&lt;in[y] &amp;&amp; x!=y){//更新最小入边 pre[y]=x;//记录前驱 in[y]=edge[i].w;//更新 } } //判断是否存在最小树形图 for(int i=0;i&lt;n;i++){ if(i==root) continue; if(in[i]==INF)//除根节点外的点存在孤立点 return -1; } //寻找所有的环 int cnt=0;//记录环数 in[root]=0; memset(id,-1,sizeof(id)); memset(vis,-1,sizeof(vis)); for(int i=0;i&lt;n;i++){//标记每个环 res+=in[i];//记录权值 int y=i; while(vis[y]!=i&amp;&amp;id[y]==-1&amp;&amp;y!=root){//寻找图中有向环 //三种情况会终止：找到出现同样标记的点、结点已属其他环、遍历到根 vis[y]=i;//标记 y=pre[y];//向上找 } if(y!=root&amp;&amp;id[y]==-1){//没有遍历到根或没有找到结点属于其他环,说明找到有向环 for(int x=pre[y];x!=y;x=pre[x])//标记结点x为第几个环 id[x]=cnt;//记录结点所属环号 id[y]=cnt++;//记录结点所属环号并累加 } } if(cnt==0)//无环 break; for(int i=0;i&lt;n;i++)//可能存在独立点 if(id[i]==-1)//环数累加 id[i]=cnt++; //建立新图,缩点重新标记 for(int i=0;i&lt;m;i++){ int x=edge[i].x; int y=edge[i].y; edge[i].x=id[x]; edge[i].y=id[y]; if(id[x]!=id[y])//两点不在同一环内,更新边权值 edge[i].w-=in[y];//x到y的距离为边权-in[y] } V=cnt;//以环数为下次操作的点数,继续上述操作,直到无环 root=id[root]; } return res; } int main(){ int n,m;//n个点m条有向边 scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++){//建图 scanf(&quot;%d%d%d&quot;,&amp;edge[i].x,&amp;edge[i].y,&amp;edge[i].w); if(edge[i].x==edge[i].y)//除去自环,即点到自身距离为INF edge[i].w=INF; } int res=zhuLiu(0,n,m); if(res==-1) printf(&quot;No\n&quot;); else printf(&quot;%d\n&quot;,res); return 0; } 模版（邝斌）#include&lt;bits/stdc++.h&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=4e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; }edge[maxm]; int pre[maxn],id[maxn],vis[maxn],in[maxn]; int zhuliu(int root,int n,int m,Edge edge[]){ int res=0,u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++) if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u; in[edge[i].v]=edge[i].cost; } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int tn=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=tn; id[v]=tn++; } } if(tn==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=tn++; for(int i=0;i&lt;m;){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i++].cost-=in[v]; else swap(edge[i],edge[--m]); } n=tn;root=id[root]; } return res; } int g[maxn][maxn]; int main() { ios::sync_with_stdio(0);cin.tie(0); int n,m,ca=0,T;cin&gt;&gt;T; while(T--){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) g[i][j]=INF; int u,v,cost; while(m--){ int u,v,cost;cin&gt;&gt;u&gt;&gt;v&gt;&gt;cost; if(u==v) continue; g[u][v]=min(g[u][v],cost); } int L=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(g[i][j]&lt;INF){ edge[L].u=i;edge[L].v=j;edge[L++].cost=g[i][j]; } int ans=zhuliu(0,n,L,edge); cout&lt;&lt;&quot;Case #&quot;&lt;&lt;ca++&lt;&lt;&quot;: &quot;; if(ans==-1) cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; } } 题目//POJ-3164 有定根的最小树形图 题意：给出 n 个点 m 条有向边，首先给出从 1 号点到 n 号点的笛卡尔坐标，然后再给出 m 条边，1 号点始终为根节点，求最小树形图 思路：朱刘算法第一题。。。边的权值用 double 型，求一下距离直接建图后，然后套模版。。。注意模版需要改为 double 型 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=105; const int maxm=1e4+5; const double INF=0x3f3f3f3f; struct Node{ double x,y; }node[maxn]; struct Edge{ int u,v;double cost; }edge[maxm]; double cal(Node a,Node b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } int pre[maxn],id[maxn],vis[maxn]; double in[maxn]; double zhuliu(int root,int n,int m){ double res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ u=edge[i].u;v=edge[i].v; if(u!=v&amp;&amp;edge[i].cost&lt;in[v]){ pre[v]=u;in[v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int main() { int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;(n+m)){ for(int i=0;i&lt;n;i++) scanf(&quot;%lf%lf&quot;,&amp;node[i].x,&amp;node[i].y); for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v); edge[i].u--;edge[i].v--; if(edge[i].u!=edge[i].v) edge[i].cost=cal(node[edge[i].u],node[edge[i].v]); else edge[i].cost=INF; } double ans=zhuliu(0,n,m); if(ans==-1) printf(&quot;poor snoopy\n&quot;); else printf(&quot;%.2f\n&quot;,ans); } } //HDU-2121 图不需要自己额外建(即题目给好了N个点,M条边),只是没有给定根 题意：n 个点 m 条有向边，现要在 n 个点中选一个点作为首都，要求首都与其他点是可达的， 给出 m 条道路修建要花费的价格，求最小花费并给出首都的序号，点的标号从 0 开始。 无根最小树形图，构造根节点0，从0到各点建立权值大于整张图权值和的边（此处取sum+1）， 这样一来0为根节点求最小树形图，如果不存在最小树形图或者所得最小树形图的权值和不小于2*(sum+1) 说明原图的最小树形图不存在，至于如何求编号最小的根节点，这个可以在求最短弧集合的时候得到， 即如果一条边被加入最短弧集合且这条边的起点是0，那么这条边的终点就是所求最小树形图的根 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Edge{ int u,v,cost; }edge[maxm+maxn]; int pos;//实际起点 int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; if(edge[i].u==root) pos=i; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; //else swap(edge[i],edge[--m]); } n=cnt;root=id[root]; } return res; } int main() { int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)){ int sum=0; for(int i=0;i&lt;m;i++){ scanf(&quot;%d%d%d&quot;,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].cost); edge[i].u++;edge[i].v++;sum+=edge[i].cost; } sum++;//去掉就WA for(int i=0;i&lt;n;i++){ edge[i+m].u=0;edge[i+m].v=i+1;edge[i+m].cost=sum; } int ans=zhuliu(0,n+1,m+n); ////若差值大于sum说明结点0的出度不止为1,即原图不是连通图 if(ans==-1||ans-sum&gt;=sum) printf(&quot;impossible\n&quot;); else printf(&quot;%d %d\n&quot;,ans-sum,pos-m); printf(&quot;\n&quot;); } } //HDU-4009 图需要自己建,同时也没有给定根 题意：n户人家，每家对应一个三维坐标(x, y, z)，z代表这家的海拔高度。 每家可以通过挖井获得水，也可以通过从别的人家引一条水渠获得水，其花费如下： 1.挖井花费z*X； 2.从不比自己低的人家引水渠花费Y*两家之间的曼哈顿距离； 3.从比自己低的人家引水渠与2中的相同，但需要多花Z来购买一个水泵 此外有的人家不允许一些人家从他们家引水渠，求使得所有人家都能获得水的最少花费 思路：对应这个题,其初始点就可以设为这n个点,然后权值为在这个点建井的花费,而对于它给的其他边,我们直接在对应的两个点上建边即可,然后跑一下朱刘算法,就可得出答案 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof(a)) using namespace std; const int maxn=1005; const int maxm=1e4+5; const int INF=0x3f3f3f3f; struct Node{ int x,y,z; }node[maxn]; struct Edge{ int u,v,cost; }edge[maxm+maxn*maxn]; int dis(Node a,Node b){ return abs(a.x-b.x)+abs(a.y-b.y)+abs(a.z-b.z); } int pre[maxn],id[maxn],vis[maxn]; int in[maxn]; int zhuliu(int root,int n,int m){ int res=0;int u,v; while(1){ for(int i=0;i&lt;n;i++) in[i]=INF; for(int i=0;i&lt;m;i++){ if(edge[i].u!=edge[i].v&amp;&amp;edge[i].cost&lt;in[edge[i].v]){ pre[edge[i].v]=edge[i].u;in[edge[i].v]=edge[i].cost; } } for(int i=0;i&lt;n;i++) if(i!=root&amp;&amp;in[i]==INF) return -1; int cnt=0;in[root]=0; mem(id,-1);mem(vis,-1); for(int i=0;i&lt;n;i++){ res+=in[i];v=i; while(vis[v]!=i&amp;&amp;id[v]==-1&amp;&amp;v!=root){ vis[v]=i;v=pre[v]; } if(v!=root&amp;&amp;id[v]==-1){ for(int u=pre[v];u!=v;u=pre[u]) id[u]=cnt; id[v]=cnt++; } } if(cnt==0) break; for(int i=0;i&lt;n;i++) if(id[i]==-1) id[i]=cnt++; for(int i=0;i&lt;m;i++){ v=edge[i].v; edge[i].u=id[edge[i].u]; edge[i].v=id[edge[i].v]; if(edge[i].u!=edge[i].v) edge[i].cost-=in[v]; } n=cnt;root=id[root]; } return res; } int main() { int n,X,Y,Z; while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;X,&amp;Y,&amp;Z)&amp;&amp;(n+X+Y+Z)){ for(int i=0;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;node[i].x,&amp;node[i].y,&amp;node[i].z); } int cnt=0,a,b; for(int i=0;i&lt;n;i++){ scanf(&quot;%d&quot;,&amp;a); while(a--){ scanf(&quot;%d&quot;,&amp;b); edge[cnt].cost=dis(node[i],node[--b])*Y; if(node[b].z&gt;node[i].z) edge[cnt].cost+=Z; edge[cnt].u=i;edge[cnt++].v=b; } } for(int i=0;i&lt;n;i++){ edge[cnt].u=n;edge[cnt].v=i;edge[cnt++].cost=node[i].z*X; } printf(&quot;%d\n&quot;,zhuliu(n,n+1,cnt)); } }]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错排公式]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[第一篇博客，写个错排公式 实践一下md语法 dp[i] = (i-1) * (dp[i-1] + dp[i-2]) 问题：把n封信装进n个信封，有多少种方法？ 公式很easy，写在上面了，现在理解一下： 假设现在已经有i-1封已经完成错排，有dp[i-1]种方式，下面处理第i封从前i-1封中取出一封(k位置)换一下，有i-1个选择，取出的信怎么处理呢？(1)放在原来的第i个位置，剩下i-2封错排之后有dp[i-2]种方式，这很容易理解。(2)不放在第i个位置,同时也不能放在k位置，只能再和剩下的i-2封换了，仔细想一下，这不就是原来的问题嘛！只不过数据规模减少了1，所以有dp[i-2]种方式。综上：dp[i] = (i-1) * (dp[i-1] + dp[i-2])&emsp;&emsp;&emsp;dp[1]=0;dp[2]=1;递归搞一搞，得结果。 就酱，第一篇结束。。。排版很low 内容很low 我也很low哎，几个月前就开了博客，一直没写过，感觉还是把接触到的有意义东西记录一下吧！毕竟记性不好，现在会的东西两个月之后也忘得差不多了。应该会写点ACM的东西吧，再传点其他方面的笔记，嗯嗯，希望自己真的能做到,结束自闭，努力学习。]]></content>
      <categories>
        <category>递推</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
